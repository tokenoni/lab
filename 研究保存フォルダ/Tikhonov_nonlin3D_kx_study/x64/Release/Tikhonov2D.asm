; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.31101.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_05IOMEMJEC@count?$AA@			; `string'
PUBLIC	??_C@_0BG@DILIGMMN@output?1prac?1count?4itx?$AA@ ; `string'
PUBLIC	??_C@_0BH@EAMCBOFL@output?1debug?1count?4itx?$AA@ ; `string'
PUBLIC	??_C@_0BD@GOPMHKAF@output?1debug?1f?4itx?$AA@	; `string'
PUBLIC	??_C@_0BE@KCMMJAFM@output?1debug?1df?4itx?$AA@	; `string'
PUBLIC	??_C@_02CJKHOMHP@vv?$AA@			; `string'
PUBLIC	??_C@_0BD@GNCKHIJO@output?1debug?1v?4itx?$AA@	; `string'
PUBLIC	??_C@_02ECEBANDL@Af?$AA@			; `string'
PUBLIC	??_C@_0BE@DPEJIGGH@output?1debug?1Af?4itx?$AA@	; `string'
PUBLIC	??_C@_0BE@KBBKJCMH@output?1debug?1dv?4itx?$AA@	; `string'
PUBLIC	??_C@_03BFACDLAE@dff?$AA@			; `string'
PUBLIC	??_C@_0BF@CHCIFIMP@output?1debug?1dff?4itx?$AA@	; `string'
PUBLIC	??_C@_0HC@FBBJGPCH@aliasing?5detected?5during?5transpo@ ; `string'
PUBLIC	??_C@_1LE@ODIDILMJ@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	??_C@_1CCG@OOFKGNBC@?$AA?$CI?$AA?$CB?$AAc?$AAh?$AAe?$AAc?$AAk?$AA_?$AAt?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AA_?$AAa?$AAl?$AAi?$AAa?$AAs?$AAi?$AAn?$AAg?$AA_?$AAr?$AAu?$AAn?$AA_?$AAt@ ; `string'
;	COMDAT ??_C@_1CCG@OOFKGNBC@?$AA?$CI?$AA?$CB?$AAc?$AAh?$AAe?$AAc?$AAk?$AA_?$AAt?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AA_?$AAa?$AAl?$AAi?$AAa?$AAs?$AAi?$AAn?$AAg?$AA_?$AAr?$AAu?$AAn?$AA_?$AAt@
CONST	SEGMENT
??_C@_1CCG@OOFKGNBC@?$AA?$CI?$AA?$CB?$AAc?$AAh?$AAe?$AAc?$AAk?$AA_?$AAt?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AA_?$AAa?$AAl?$AAi?$AAa?$AAs?$AAi?$AAn?$AAg?$AA_?$AAr?$AAu?$AAn?$AA_?$AAt@ DB '('
	DB	00H, '!', 00H, 'c', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H
	DB	'_', 00H, 't', 00H, 'r', 00H, 'a', 00H, 'n', 00H, 's', 00H, 'p'
	DB	00H, 'o', 00H, 's', 00H, 'e', 00H, '_', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 'a', 00H, 's', 00H, 'i', 00H, 'n', 00H, 'g', 00H, '_'
	DB	00H, 'r', 00H, 'u', 00H, 'n', 00H, '_', 00H, 't', 00H, 'i', 00H
	DB	'm', 00H, 'e', 00H, '_', 00H, 's', 00H, 'e', 00H, 'l', 00H, 'e'
	DB	00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '<', 00H
	DB	't', 00H, 'y', 00H, 'p', 00H, 'e', 00H, 'n', 00H, 'a', 00H, 'm'
	DB	00H, 'e', 00H, ' ', 00H, 'D', 00H, 'e', 00H, 'r', 00H, 'i', 00H
	DB	'v', 00H, 'e', 00H, 'd', 00H, ':', 00H, ':', 00H, 'S', 00H, 'c'
	DB	00H, 'a', 00H, 'l', 00H, 'a', 00H, 'r', 00H, ',', 00H, 'b', 00H
	DB	'l', 00H, 'a', 00H, 's', 00H, '_', 00H, 't', 00H, 'r', 00H, 'a'
	DB	00H, 'i', 00H, 't', 00H, 's', 00H, '<', 00H, 'D', 00H, 'e', 00H
	DB	'r', 00H, 'i', 00H, 'v', 00H, 'e', 00H, 'd', 00H, '>', 00H, ':'
	DB	00H, ':', 00H, 'I', 00H, 's', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'n', 00H, 's', 00H, 'p', 00H, 'o', 00H, 's', 00H, 'e', 00H, 'd'
	DB	00H, ',', 00H, 'O', 00H, 't', 00H, 'h', 00H, 'e', 00H, 'r', 00H
	DB	'D', 00H, 'e', 00H, 'r', 00H, 'i', 00H, 'v', 00H, 'e', 00H, 'd'
	DB	00H, '>', 00H, ' ', 00H, ':', 00H, ':', 00H, 'r', 00H, 'u', 00H
	DB	'n', 00H, '(', 00H, 'e', 00H, 'x', 00H, 't', 00H, 'r', 00H, 'a'
	DB	00H, 'c', 00H, 't', 00H, '_', 00H, 'd', 00H, 'a', 00H, 't', 00H
	DB	'a', 00H, '(', 00H, 'd', 00H, 's', 00H, 't', 00H, ')', 00H, ','
	DB	00H, ' ', 00H, 'o', 00H, 't', 00H, 'h', 00H, 'e', 00H, 'r', 00H
	DB	')', 00H, ')', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '"'
	DB	00H, 'a', 00H, 'l', 00H, 'i', 00H, 'a', 00H, 's', 00H, 'i', 00H
	DB	'n', 00H, 'g', 00H, ' ', 00H, 'd', 00H, 'e', 00H, 't', 00H, 'e'
	DB	00H, 'c', 00H, 't', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'd', 00H
	DB	'u', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 't'
	DB	00H, 'r', 00H, 'a', 00H, 'n', 00H, 's', 00H, 'p', 00H, 'o', 00H
	DB	's', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, ','
	DB	00H, ' ', 00H, 'u', 00H, 's', 00H, 'e', 00H, ' ', 00H, 't', 00H
	DB	'r', 00H, 'a', 00H, 'n', 00H, 's', 00H, 'p', 00H, 'o', 00H, 's'
	DB	00H, 'e', 00H, 'I', 00H, 'n', 00H, 'P', 00H, 'l', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, '(', 00H, ')', 00H, ' ', 00H, '"', 00H, ' '
	DB	00H, '"', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'e', 00H, 'v', 00H
	DB	'a', 00H, 'l', 00H, 'u', 00H, 'a', 00H, 't', 00H, 'e', 00H, ' '
	DB	00H, 't', 00H, 'h', 00H, 'e', 00H, ' ', 00H, 'r', 00H, 'h', 00H
	DB	's', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'o', 00H, ' '
	DB	00H, 'a', 00H, ' ', 00H, 't', 00H, 'e', 00H, 'm', 00H, 'p', 00H
	DB	'o', 00H, 'r', 00H, 'a', 00H, 'r', 00H, 'y', 00H, ' ', 00H, 'u'
	DB	00H, 's', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, '.', 00H
	DB	'e', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '(', 00H, ')', 00H, '"'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1LE@ODIDILMJ@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1LE@ODIDILMJ@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '2', 00H, '.', 00H, '0', 00H, '\', 00H, 'v'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H
	DB	'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'e', 00H, 'i', 00H, 'g'
	DB	00H, 'e', 00H, 'n', 00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H
	DB	'/', 00H, 'C', 00H, 'o', 00H, 'r', 00H, 'e', 00H, '/', 00H, 'T'
	DB	00H, 'r', 00H, 'a', 00H, 'n', 00H, 's', 00H, 'p', 00H, 'o', 00H
	DB	's', 00H, 'e', 00H, '.', 00H, 'h', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HC@FBBJGPCH@aliasing?5detected?5during?5transpo@
CONST	SEGMENT
??_C@_0HC@FBBJGPCH@aliasing?5detected?5during?5transpo@ DB 'aliasing dete'
	DB	'cted during transposition, use transposeInPlace() or evaluate'
	DB	' the rhs into a temporary using .eval()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CHCIFIMP@output?1debug?1dff?4itx?$AA@
CONST	SEGMENT
??_C@_0BF@CHCIFIMP@output?1debug?1dff?4itx?$AA@ DB 'output/debug/dff.itx', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03BFACDLAE@dff?$AA@
CONST	SEGMENT
??_C@_03BFACDLAE@dff?$AA@ DB 'dff', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KBBKJCMH@output?1debug?1dv?4itx?$AA@
CONST	SEGMENT
??_C@_0BE@KBBKJCMH@output?1debug?1dv?4itx?$AA@ DB 'output/debug/dv.itx', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DPEJIGGH@output?1debug?1Af?4itx?$AA@
CONST	SEGMENT
??_C@_0BE@DPEJIGGH@output?1debug?1Af?4itx?$AA@ DB 'output/debug/Af.itx', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02ECEBANDL@Af?$AA@
CONST	SEGMENT
??_C@_02ECEBANDL@Af?$AA@ DB 'Af', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GNCKHIJO@output?1debug?1v?4itx?$AA@
CONST	SEGMENT
??_C@_0BD@GNCKHIJO@output?1debug?1v?4itx?$AA@ DB 'output/debug/v.itx', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02CJKHOMHP@vv?$AA@
CONST	SEGMENT
??_C@_02CJKHOMHP@vv?$AA@ DB 'vv', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KCMMJAFM@output?1debug?1df?4itx?$AA@
CONST	SEGMENT
??_C@_0BE@KCMMJAFM@output?1debug?1df?4itx?$AA@ DB 'output/debug/df.itx', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GOPMHKAF@output?1debug?1f?4itx?$AA@
CONST	SEGMENT
??_C@_0BD@GOPMHKAF@output?1debug?1f?4itx?$AA@ DB 'output/debug/f.itx', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@EAMCBOFL@output?1debug?1count?4itx?$AA@
CONST	SEGMENT
??_C@_0BH@EAMCBOFL@output?1debug?1count?4itx?$AA@ DB 'output/debug/count.'
	DB	'itx', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DILIGMMN@output?1prac?1count?4itx?$AA@
CONST	SEGMENT
??_C@_0BG@DILIGMMN@output?1prac?1count?4itx?$AA@ DB 'output/prac/count.it'
	DB	'x', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_05IOMEMJEC@count?$AA@
CONST	SEGMENT
??_C@_05IOMEMJEC@count?$AA@ DB 'count', 00H		; `string'
CONST	ENDS
;	COMDAT ?PacketSize@?1???$first_aligned@N_J@internal@Eigen@@YA_JPEBN_J@Z@4_JB
CONST	SEGMENT
?PacketSize@?1???$first_aligned@N_J@internal@Eigen@@YA_JPEBN_J@Z@4_JB DQ 0000000000000002H ; `Eigen::internal::first_aligned<double,__int64>'::`2'::PacketSize
CONST	ENDS
;	COMDAT ?PacketAlignedMask@?1???$first_aligned@N_J@internal@Eigen@@YA_JPEBN_J@Z@4_JB
CONST	SEGMENT
?PacketAlignedMask@?1???$first_aligned@N_J@internal@Eigen@@YA_JPEBN_J@Z@4_JB DQ 0000000000000001H ; `Eigen::internal::first_aligned<double,__int64>'::`2'::PacketAlignedMask
PUBLIC	?extractScalarFactor@?$blas_traits@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@Eigen@@@internal@Eigen@@SA?BNAEBV?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@3@@Z ; Eigen::internal::blas_traits<Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >::extractScalarFactor
PUBLIC	?extract@?$blas_traits@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@Eigen@@@internal@Eigen@@SAAEBV?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@3@AEBV43@@Z ; Eigen::internal::blas_traits<Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >::extract
PUBLIC	?rhs@?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEBAAEBV?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@XZ ; Eigen::ProductBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >::rhs
PUBLIC	?lhs@?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEBAAEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@XZ ; Eigen::ProductBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >::lhs
PUBLIC	??$run@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@?$gemv_selector@$01$0A@$00@internal@Eigen@@SAXAEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEBN@Z ; Eigen::internal::gemv_selector<2,0,1>::run<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,1,0,-1,1> >
PUBLIC	??$scaleAndAddTo@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@QEBAXAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBN@Z ; Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>::scaleAndAddTo<Eigen::Matrix<double,-1,1,0,-1,1> >
PUBLIC	??$copyCoeff@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$DenseCoeffsBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$00@Eigen@@QEAAX_JAEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z ; Eigen::DenseCoeffsBase<Eigen::Matrix<double,-1,-1,0,-1,-1>,1>::copyCoeff<Eigen::Matrix<double,-1,1,0,-1,1> >
PUBLIC	??$packet@$0A@@?$MapBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEBA?AU__m128d@@_J0@Z ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,0>::packet<0>
PUBLIC	??$packet@$00@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEBA?AU__m128d@@_J0@Z ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,1,0,-1,1> >::packet<1>
PUBLIC	??$scaleAndAddTo@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEBAXAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBN@Z ; Eigen::ProductBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >::scaleAndAddTo<Eigen::Matrix<double,-1,1,0,-1,1> >
PUBLIC	?run@?$checkTransposeAliasing_impl@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$0A@@internal@Eigen@@SAXAEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z ; Eigen::internal::checkTransposeAliasing_impl<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::Matrix<double,-1,1,0,-1,1>,0>::run
PUBLIC	?const_cast_derived@?$EigenBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBAAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@XZ ; Eigen::EigenBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::const_cast_derived
PUBLIC	?coeff@?$MapBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEBAAEBN_J0@Z ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,0>::coeff
PUBLIC	??$run@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@@?$unaligned_assign_impl@$0A@@internal@Eigen@@SAXAEBV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@_J2@Z ; Eigen::internal::unaligned_assign_impl<0>::run<Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Matrix<double,-1,-1,0,-1,-1> >
PUBLIC	??$copyPacket@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$00$00@?$DenseCoeffsBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$00@Eigen@@QEAAX_JAEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z ; Eigen::DenseCoeffsBase<Eigen::Matrix<double,-1,-1,0,-1,-1>,1>::copyPacket<Eigen::Matrix<double,-1,1,0,-1,1>,1,1>
PUBLIC	??$run@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@@?$unaligned_assign_impl@$00@internal@Eigen@@SAXAEBV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@_J2@Z ; Eigen::internal::unaligned_assign_impl<1>::run<Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Matrix<double,-1,-1,0,-1,-1> >
PUBLIC	??$copyPacket@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$00$0A@@?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@1@@Z ; Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::copyPacket<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,1,0>
PUBLIC	??$copyCoeff@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@1@@Z ; Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::copyCoeff<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >
PUBLIC	??$writePacket@$00@?$MapBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBU__m128d@@@Z ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,1>::writePacket<1>
PUBLIC	??$packet@$0A@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA?AU__m128d@@_J0@Z ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::packet<0>
PUBLIC	??$writePacket@$00@?$MapBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBU__m128d@@@Z ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,1>::writePacket<1>
PUBLIC	??$packet@$0A@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEBA?AU__m128d@@_J0@Z ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,1,0,-1,1> >::packet<0>
PUBLIC	??$checkTransposeAliasing@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEBAXAEBV?$Matrix@N$0?0$00$0A@$0?0$00@1@@Z ; Eigen::DenseBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::checkTransposeAliasing<Eigen::Matrix<double,-1,1,0,-1,1> >
PUBLIC	??$resizeLike@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAXAEBU?$EigenBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::resizeLike<Eigen::Matrix<double,-1,1,0,-1,1> >
PUBLIC	??$evalTo@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEBAXAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@@Z ; Eigen::ProductBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >::evalTo<Eigen::Matrix<double,-1,1,0,-1,1> >
PUBLIC	??$resizeLike@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAXAEBU?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,1,0,-1,1> >::resizeLike<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4> >
PUBLIC	??$resizeLike@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAXAEBU?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,1,0,-1,1> >::resizeLike<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const >,4> >
PUBLIC	?derived@?$EigenBase@V?$Transpose@$$CBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@Eigen@@QEAAAEAV?$Transpose@$$CBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@XZ ; Eigen::EigenBase<Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> const > >::derived
PUBLIC	?nestedExpression@?$Transpose@$$CBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@XZ ; Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> const >::nestedExpression
PUBLIC	?extract@?$blas_traits@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@internal@Eigen@@SAAEBV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV43@@Z ; Eigen::internal::blas_traits<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::extract
PUBLIC	?data@?$MapBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEBAPEBNXZ ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,1>::data
PUBLIC	?data@?$TransposeImpl@$$CBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@UDense@2@@Eigen@@QEAAPEBNXZ ; Eigen::TransposeImpl<Eigen::Matrix<double,-1,-1,0,-1,-1> const ,Eigen::Dense>::data
PUBLIC	?run@?$extract_data_selector@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@$00@internal@Eigen@@SAPEBNAEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Z ; Eigen::internal::extract_data_selector<Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> >,1>::run
PUBLIC	?run@?$extract_data_selector@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@internal@Eigen@@SAPEBNAEBV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@@Z ; Eigen::internal::extract_data_selector<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,1>::run
PUBLIC	?run@?$checkTransposeAliasing_impl@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@$0A@@internal@Eigen@@SAXAEBV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@3@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Z ; Eigen::internal::checkTransposeAliasing_impl<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,0>::run
PUBLIC	?run@?$assign_impl@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$02$0A@$0A@@internal@Eigen@@SAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z ; Eigen::internal::assign_impl<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::Matrix<double,-1,1,0,-1,1>,3,0,0>::run
PUBLIC	?colIndexByOuterInner@?$DenseCoeffsBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@$0A@@Eigen@@QEBA_J_J0@Z ; Eigen::DenseCoeffsBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >,0>::colIndexByOuterInner
PUBLIC	?rowIndexByOuterInner@?$DenseCoeffsBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@$0A@@Eigen@@QEBA_J_J0@Z ; Eigen::DenseCoeffsBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >,0>::rowIndexByOuterInner
PUBLIC	?coeff@?$TransposeImpl@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@UDense@2@@Eigen@@QEBAAEBN_J0@Z ; Eigen::TransposeImpl<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::Dense>::coeff
PUBLIC	??$extract_data@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@YAPEBNAEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@1@@Z ; Eigen::internal::extract_data<Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> > >
PUBLIC	??$copyPacketByOuterInner@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$00$0A@@?$DenseCoeffsBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@1@@Z ; Eigen::DenseCoeffsBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >,1>::copyPacketByOuterInner<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,1,0>
PUBLIC	??$copyCoeffByOuterInner@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@?$DenseCoeffsBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@1@@Z ; Eigen::DenseCoeffsBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >,1>::copyCoeffByOuterInner<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >
PUBLIC	??$extract_data@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@internal@Eigen@@YAPEBNAEBV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@1@@Z ; Eigen::internal::extract_data<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >
PUBLIC	??$copyCoeff@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@1@@Z ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,1>::copyCoeff<Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> > >
PUBLIC	??$copyPacket@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$00$0A@@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@1@@Z ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,1>::copyPacket<Eigen::Matrix<double,-1,-1,0,-1,-1>,1,0>
PUBLIC	??$copyCoeff@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@1@@Z ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,1>::copyCoeff<Eigen::Matrix<double,-1,-1,0,-1,-1> >
PUBLIC	??$copyPacket@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$00$0A@@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,1>::copyPacket<Eigen::Matrix<double,-1,1,0,-1,1>,1,0>
PUBLIC	??$copyCoeff@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,1>::copyCoeff<Eigen::Matrix<double,-1,1,0,-1,1> >
PUBLIC	??$checkTransposeAliasing@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@?$DenseBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@IEBAXAEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@1@@Z ; Eigen::DenseBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> > >::checkTransposeAliasing<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >
PUBLIC	??$lazyAssign@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z ; Eigen::DenseBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::lazyAssign<Eigen::Matrix<double,-1,1,0,-1,1> >
PUBLIC	??$_resize_to_match@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAAXAEBU?$EigenBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::_resize_to_match<Eigen::Matrix<double,-1,1,0,-1,1> >
PUBLIC	??$lazyAssign@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@?$MatrixBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@1@@Z ; Eigen::MatrixBase<Eigen::Matrix<double,-1,1,0,-1,1> >::lazyAssign<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >
PUBLIC	??$_resize_to_match@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@IEAAXAEBU?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,1,0,-1,1> >::_resize_to_match<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4> >
PUBLIC	??$lazyAssign@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@?$MatrixBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@1@@Z ; Eigen::MatrixBase<Eigen::Matrix<double,-1,1,0,-1,1> >::lazyAssign<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const > >
PUBLIC	??$_resize_to_match@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@IEAAXAEBU?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,1,0,-1,1> >::_resize_to_match<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const >,4> >
PUBLIC	?derived@?$EigenBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@QEBAAEBV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@2@XZ ; Eigen::EigenBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> > >::derived
PUBLIC	?size@?$EigenBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::EigenBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> > >::size
PUBLIC	?cols@?$EigenBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::EigenBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> > >::cols
PUBLIC	?rows@?$EigenBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::EigenBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> > >::rows
PUBLIC	?run@?$check_transpose_aliasing_run_time_selector@N$0A@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@SA_NPEBNAEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Z ; Eigen::internal::check_transpose_aliasing_run_time_selector<double,0,Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> > >::run
PUBLIC	?innerSize@?$DenseBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::DenseBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> > >::innerSize
PUBLIC	?outerSize@?$DenseBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::DenseBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> > >::outerSize
PUBLIC	?coeffRef@?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@QEAAAEAN_J0@Z ; Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::coeffRef
PUBLIC	?outerStride@?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@QEBA_JXZ ; Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::outerStride
PUBLIC	?run@?$assign_impl@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@3@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Z ; Eigen::internal::assign_impl<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,4,0,0>::run
PUBLIC	?run@?$checkTransposeAliasing_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@$00@internal@Eigen@@SAXAEBV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Z ; Eigen::internal::checkTransposeAliasing_impl<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> >,1>::run
PUBLIC	?run@?$checkTransposeAliasing_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$0A@@internal@Eigen@@SAXAEBV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@Z ; Eigen::internal::checkTransposeAliasing_impl<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,Eigen::Matrix<double,-1,-1,0,-1,-1>,0>::run
PUBLIC	?run@?$checkTransposeAliasing_impl@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$0A@@internal@Eigen@@SAXAEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z ; Eigen::internal::checkTransposeAliasing_impl<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,Eigen::Matrix<double,-1,1,0,-1,1>,0>::run
PUBLIC	?cols@?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@QEBA_JXZ ; Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::cols
PUBLIC	?rows@?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@QEBA_JXZ ; Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::rows
PUBLIC	?colIndexByOuterInner@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEBA_J_J0@Z ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,0>::colIndexByOuterInner
PUBLIC	?rowIndexByOuterInner@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEBA_J_J0@Z ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,0>::rowIndexByOuterInner
PUBLIC	?colIndexByOuterInner@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEBA_J_J0@Z ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,0>::colIndexByOuterInner
PUBLIC	?rowIndexByOuterInner@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEBA_J_J0@Z ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,0>::rowIndexByOuterInner
PUBLIC	??$copyCoeffByOuterInner@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@1@@Z ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,1>::copyCoeffByOuterInner<Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> > >
PUBLIC	??$copyPacketByOuterInner@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$00$0A@@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@1@@Z ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,1>::copyPacketByOuterInner<Eigen::Matrix<double,-1,-1,0,-1,-1>,1,0>
PUBLIC	??$copyCoeffByOuterInner@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@1@@Z ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,1>::copyCoeffByOuterInner<Eigen::Matrix<double,-1,-1,0,-1,-1> >
PUBLIC	??$copyPacketByOuterInner@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$00$0A@@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,1>::copyPacketByOuterInner<Eigen::Matrix<double,-1,1,0,-1,1>,1,0>
PUBLIC	??$copyCoeffByOuterInner@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,1>::copyCoeffByOuterInner<Eigen::Matrix<double,-1,1,0,-1,1> >
PUBLIC	??$lazyAssign@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@QEAAAEAV01@AEBV?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@1@@Z ; Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::lazyAssign<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >
PUBLIC	??$lazyAssign@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::lazyAssign<Eigen::Matrix<double,-1,1,0,-1,1> >
PUBLIC	??$lazyAssign@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$DenseBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,1,0,-1,1> >::lazyAssign<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4> >
PUBLIC	??$lazyAssign@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$DenseBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,1,0,-1,1> >::lazyAssign<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const >,4> >
PUBLIC	??$checkTransposeAliasing@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@?$DenseBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@IEBAXAEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@1@@Z ; Eigen::DenseBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::checkTransposeAliasing<Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> > >
PUBLIC	??$checkTransposeAliasing@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@?$DenseBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@IEBAXAEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@@Z ; Eigen::DenseBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::checkTransposeAliasing<Eigen::Matrix<double,-1,-1,0,-1,-1> >
PUBLIC	??$checkTransposeAliasing@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@IEBAXAEBV?$Matrix@N$0?0$00$0A@$0?0$00@1@@Z ; Eigen::DenseBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::checkTransposeAliasing<Eigen::Matrix<double,-1,1,0,-1,1> >
PUBLIC	??$_set_selector@V?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@IEAAXAEBV?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@1@AEBUfalse_type@internal@1@@Z ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,1,0,-1,1> >::_set_selector<Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>,Eigen::ReturnByValue<Eigen::internal::solve_retval_base<Eigen::PartialPivLU<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::Matrix<double,-1,1,0,-1,1> > > const > >
PUBLIC	?innerStride@?$BlockImpl_dense@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@$00@internal@Eigen@@QEBA_JXZ ; Eigen::internal::BlockImpl_dense<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0,1>::innerStride
PUBLIC	?innerStride@?$BlockImpl_dense@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@$00@internal@Eigen@@QEBA_JXZ ; Eigen::internal::BlockImpl_dense<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0,1>::innerStride
PUBLIC	?outerStride@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$02@Eigen@@QEBA_JXZ ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,3>::outerStride
PUBLIC	?innerStride@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$02@Eigen@@QEBA_JXZ ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,3>::innerStride
PUBLIC	?outerStride@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$02@Eigen@@QEBA_JXZ ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,3>::outerStride
PUBLIC	?innerStride@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$02@Eigen@@QEBA_JXZ ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,3>::innerStride
PUBLIC	?size@?$EigenBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::EigenBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::size
PUBLIC	?colStride@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$02@Eigen@@QEBA_JXZ ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,3>::colStride
PUBLIC	?rowStride@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$02@Eigen@@QEBA_JXZ ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,3>::rowStride
PUBLIC	?size@?$EigenBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::EigenBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::size
PUBLIC	?colStride@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$02@Eigen@@QEBA_JXZ ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,3>::colStride
PUBLIC	?rowStride@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$02@Eigen@@QEBA_JXZ ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,3>::rowStride
PUBLIC	?derived@?$EigenBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBAAEBV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@2@XZ ; Eigen::EigenBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::derived
PUBLIC	?innerSize@?$DenseBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::DenseBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::innerSize
PUBLIC	?outerSize@?$DenseBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::DenseBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::outerSize
PUBLIC	?cols@?$MapBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEBA_JXZ ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,0>::cols
PUBLIC	?rows@?$MapBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEBA_JXZ ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,0>::rows
PUBLIC	?coeffRef@?$MapBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAAEAN_J0@Z ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,1>::coeffRef
PUBLIC	?outerStride@?$BlockImpl_dense@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@$00@internal@Eigen@@QEBA_JXZ ; Eigen::internal::BlockImpl_dense<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0,1>::outerStride
PUBLIC	?innerSize@?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::DenseBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::innerSize
PUBLIC	?outerSize@?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::DenseBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::outerSize
PUBLIC	?cols@?$MapBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEBA_JXZ ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,0>::cols
PUBLIC	?rows@?$MapBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEBA_JXZ ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,0>::rows
PUBLIC	?coeffRef@?$MapBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAAEAN_J0@Z ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,1>::coeffRef
PUBLIC	?outerStride@?$BlockImpl_dense@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@$00@internal@Eigen@@QEBA_JXZ ; Eigen::internal::BlockImpl_dense<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0,1>::outerStride
PUBLIC	?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@$0A@$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Z ; Eigen::internal::assign_impl<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> >,0,0,0>::run
PUBLIC	?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@Z ; Eigen::internal::assign_impl<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,Eigen::Matrix<double,-1,-1,0,-1,-1>,4,0,0>::run
PUBLIC	?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z ; Eigen::internal::assign_impl<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,Eigen::Matrix<double,-1,1,0,-1,1>,4,0,0>::run
PUBLIC	?run@?$assign_selector@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@$0A@$0A@@internal@Eigen@@SAAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@3@AEAV43@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Z ; Eigen::internal::assign_selector<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,0,0>::run
PUBLIC	?run@?$assign_selector@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$0A@$0A@@internal@Eigen@@SAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@AEAV43@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z ; Eigen::internal::assign_selector<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::Matrix<double,-1,1,0,-1,1>,0,0>::run
PUBLIC	?run@?$assign_selector@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@$0A@$0A@@internal@Eigen@@SAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@3@AEAV43@AEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@3@@Z ; Eigen::internal::assign_selector<Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,0,0>::run
PUBLIC	?run@?$assign_selector@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@$0A@$0A@@internal@Eigen@@SAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@3@AEAV43@AEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@3@@Z ; Eigen::internal::assign_selector<Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const >,4>,0,0>::run
PUBLIC	?derived@?$EigenBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@QEAAAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@2@XZ ; Eigen::EigenBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> > >::derived
PUBLIC	?cols@?$EigenBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::EigenBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::cols
PUBLIC	?rows@?$EigenBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::EigenBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::rows
PUBLIC	?cols@?$EigenBase@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::EigenBase<Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> > >::cols
PUBLIC	?rows@?$EigenBase@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::EigenBase<Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> > >::rows
PUBLIC	?cols@?$EigenBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::EigenBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::cols
PUBLIC	?rows@?$EigenBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::EigenBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::rows
PUBLIC	??$lazyAssign@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@?$DenseBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@1@AEBV?$DenseBase@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@1@@Z ; Eigen::DenseBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::lazyAssign<Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> > >
PUBLIC	??$lazyAssign@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@?$DenseBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@1@AEBV?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@1@@Z ; Eigen::DenseBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::lazyAssign<Eigen::Matrix<double,-1,-1,0,-1,-1> >
PUBLIC	??$lazyAssign@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@1@AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z ; Eigen::DenseBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::lazyAssign<Eigen::Matrix<double,-1,1,0,-1,1> >
PUBLIC	??$?4V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@?$MatrixBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@QEAAAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@1@AEBV?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@1@@Z ; Eigen::MatrixBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> > >::operator=<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >
PUBLIC	??$_set_noalias@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::_set_noalias<Eigen::Matrix<double,-1,1,0,-1,1> >
PUBLIC	??$_set@V?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@IEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$DenseBase@V?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@@1@@Z ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,1,0,-1,1> >::_set<Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>,Eigen::ReturnByValue<Eigen::internal::solve_retval_base<Eigen::PartialPivLU<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::Matrix<double,-1,1,0,-1,1> > > const > >
PUBLIC	??$_set_noalias@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@IEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$DenseBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,1,0,-1,1> >::_set_noalias<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4> >
PUBLIC	??$_set_noalias@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@IEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$DenseBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,1,0,-1,1> >::_set_noalias<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const >,4> >
PUBLIC	??0?$DenseBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@Eigen@@IEAA@XZ ; Eigen::DenseBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4> >::DenseBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4> >
PUBLIC	??0?$DenseBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@IEAA@XZ ; Eigen::DenseBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> > >::DenseBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> > >
PUBLIC	??0?$MatrixBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@Eigen@@IEAA@XZ ; Eigen::MatrixBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4> >::MatrixBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4> >
PUBLIC	??0?$MatrixBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@IEAA@XZ ; Eigen::MatrixBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> > >::MatrixBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> > >
PUBLIC	?derived@?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@Eigen@@QEBAAEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@XZ ; Eigen::EigenBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4> >::derived
PUBLIC	?cols@?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEBA_JXZ ; Eigen::ProductBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >::cols
PUBLIC	?rows@?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEBA_JXZ ; Eigen::ProductBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >::rows
PUBLIC	??0?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEAA@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@1@@Z ; Eigen::ProductBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >::ProductBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >
PUBLIC	?__autoclassinit2@?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@QEAAX_K@Z ; Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>::__autoclassinit2
PUBLIC	?run@?$assign_selector@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@$0A@$0A@@internal@Eigen@@SAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEAV43@AEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Z ; Eigen::internal::assign_selector<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> >,0,0>::run
PUBLIC	?run@?$assign_selector@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$0A@$0A@@internal@Eigen@@SAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEAV43@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@Z ; Eigen::internal::assign_selector<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,Eigen::Matrix<double,-1,-1,0,-1,-1>,0,0>::run
PUBLIC	?run@?$assign_selector@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$0A@$0A@@internal@Eigen@@SAAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@AEAV43@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z ; Eigen::internal::assign_selector<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,Eigen::Matrix<double,-1,1,0,-1,1>,0,0>::run
PUBLIC	??4?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@QEAAAEAV01@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@1@@Z ; Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::operator=
PUBLIC	??0?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@QEAA@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBU?$scalar_sum_op@N@internal@1@@Z ; Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >
PUBLIC	?derived@?$EigenBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@2@XZ ; Eigen::EigenBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::derived
PUBLIC	?derived@?$EigenBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBAAEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@XZ ; Eigen::EigenBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::derived
PUBLIC	?derived@?$EigenBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@XZ ; Eigen::EigenBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::derived
PUBLIC	?cols@?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::EigenBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4> >::cols
PUBLIC	?rows@?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::EigenBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4> >::rows
PUBLIC	??0?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@QEAA@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@1@@Z ; Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>
PUBLIC	?cols@?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::EigenBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const >,4> >::cols
PUBLIC	?rows@?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@Eigen@@QEBA_JXZ ; Eigen::EigenBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const >,4> >::rows
PUBLIC	??$?0V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@AEBV?$MatrixBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z ; Eigen::Matrix<double,-1,-1,0,-1,-1>::Matrix<double,-1,-1,0,-1,-1><Eigen::Matrix<double,-1,1,0,-1,1> >
PUBLIC	??$?4V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@?$MatrixBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@1@AEBV?$DenseBase@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@1@@Z ; Eigen::MatrixBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::operator=<Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> > >
PUBLIC	??$?4V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@?$MatrixBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@1@AEBV?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@1@@Z ; Eigen::MatrixBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::operator=<Eigen::Matrix<double,-1,-1,0,-1,-1> >
PUBLIC	??$?4V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$MatrixBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@1@AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z ; Eigen::MatrixBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::operator=<Eigen::Matrix<double,-1,1,0,-1,1> >
PUBLIC	??$?YV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@?$MatrixBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$MatrixBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@1@@Z ; Eigen::MatrixBase<Eigen::Matrix<double,-1,1,0,-1,1> >::operator+=<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >
PUBLIC	??$?4V?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAAAEAV01@AEBV?$MatrixBase@V?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@@1@@Z ; Eigen::Matrix<double,-1,1,0,-1,1>::operator=<Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>,Eigen::ReturnByValue<Eigen::internal::solve_retval_base<Eigen::PartialPivLU<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::Matrix<double,-1,1,0,-1,1> > > const > >
PUBLIC	??$?0V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@AEBV?$MatrixBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z ; Eigen::Matrix<double,-1,1,0,-1,1>::Matrix<double,-1,1,0,-1,1><Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4> >
PUBLIC	??$?DV?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@Eigen@@@?$MatrixBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA?BV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@1@AEBV?$MatrixBase@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@Eigen@@@1@@Z ; Eigen::MatrixBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::operator*<Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >
PUBLIC	??$?0V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@AEBV?$MatrixBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z ; Eigen::Matrix<double,-1,1,0,-1,1>::Matrix<double,-1,1,0,-1,1><Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const >,4> >
PUBLIC	??0?$DenseBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@IEAA@XZ ; Eigen::DenseBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::DenseBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >
PUBLIC	??0?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@IEAA@XZ ; Eigen::DenseBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::DenseBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >
PUBLIC	??0?$MatrixBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@IEAA@XZ ; Eigen::MatrixBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::MatrixBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >
PUBLIC	?checkSanity@?$MapBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@IEBAXXZ ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,0>::checkSanity
PUBLIC	??0?$MatrixBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@IEAA@XZ ; Eigen::MatrixBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::MatrixBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >
PUBLIC	?checkSanity@?$MapBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@IEBAXXZ ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,0>::checkSanity
PUBLIC	??0?$MapBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEAA@PEAN_J1@Z ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,0>::MapBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,0>
PUBLIC	??0?$MapBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEAA@PEAN_J1@Z ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,0>::MapBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,0>
PUBLIC	?innerStride@?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEBA_JXZ ; Eigen::Matrix<double,-1,-1,0,-1,-1>::innerStride
PUBLIC	??0?$MapBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAA@PEAN_J1@Z ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,1>::MapBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,1>
PUBLIC	?init@?$BlockImpl_dense@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@$00@internal@Eigen@@IEAAXXZ ; Eigen::internal::BlockImpl_dense<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0,1>::init
PUBLIC	??0?$MapBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAA@PEAN_J1@Z ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,1>::MapBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,1>
PUBLIC	?init@?$BlockImpl_dense@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@$00@internal@Eigen@@IEAAXXZ ; Eigen::internal::BlockImpl_dense<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0,1>::init
PUBLIC	??0?$BlockImpl_dense@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@$00@internal@Eigen@@QEAA@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@_J111@Z ; Eigen::internal::BlockImpl_dense<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0,1>::BlockImpl_dense<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0,1>
PUBLIC	??0?$BlockImpl_dense@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@$00@internal@Eigen@@QEAA@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@_J111@Z ; Eigen::internal::BlockImpl_dense<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0,1>::BlockImpl_dense<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0,1>
PUBLIC	??0?$BlockImpl@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@UDense@2@@Eigen@@QEAA@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@_J111@Z ; Eigen::BlockImpl<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0,Eigen::Dense>::BlockImpl<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0,Eigen::Dense>
PUBLIC	??0?$BlockImpl@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@UDense@2@@Eigen@@QEAA@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@_J111@Z ; Eigen::BlockImpl<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0,Eigen::Dense>::BlockImpl<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0,Eigen::Dense>
PUBLIC	??0?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@QEAA@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@_J111@Z ; Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>
PUBLIC	??0?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@QEAA@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@_J111@Z ; Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>
PUBLIC	??R?$DenseCoeffsBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$00@Eigen@@QEAAAEAN_J@Z ; Eigen::DenseCoeffsBase<Eigen::Matrix<double,-1,-1,0,-1,-1>,1>::operator()
PUBLIC	?block@?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAA?AV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@2@_J000@Z ; Eigen::DenseBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::block
PUBLIC	??R?$DenseCoeffsBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0A@@Eigen@@QEBAAEBN_J@Z ; Eigen::DenseCoeffsBase<Eigen::Matrix<double,-1,1,0,-1,1>,0>::operator()
PUBLIC	??A?$DenseCoeffsBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0A@@Eigen@@QEBAAEBN_J@Z ; Eigen::DenseCoeffsBase<Eigen::Matrix<double,-1,1,0,-1,1>,0>::operator[]
PUBLIC	?block@?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAA?AV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@_J000@Z ; Eigen::DenseBase<Eigen::Matrix<double,-1,1,0,-1,1> >::block
PUBLIC	?getAdv_ij@Tikhonov2D@@AEBAN_K0@Z		; Tikhonov2D::getAdv_ij
PUBLIC	?getA_ij@Tikhonov2D@@AEBAN_K0@Z			; Tikhonov2D::getA_ij
PUBLIC	?setJandH@Tikhonov2D@@AEAA_NNN@Z		; Tikhonov2D::setJandH
PUBLIC	?updateFandV@Tikhonov2D@@AEAA_NNNNN@Z		; Tikhonov2D::updateFandV
PUBLIC	?updateV@Tikhonov2D@@AEAA_NNN@Z			; Tikhonov2D::updateV
PUBLIC	??1?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEAA@XZ ; Eigen::ProductBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >::~ProductBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >
PUBLIC	??1?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@QEAA@XZ ; Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>::~GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>
PUBLIC	?updateF@Tikhonov2D@@AEAA_NNN@Z			; Tikhonov2D::updateF
PUBLIC	?getAf@Tikhonov2D@@QEBA?AV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@XZ ; Tikhonov2D::getAf
PUBLIC	?solve@Tikhonov2D@@QEAA_NNNNN@Z			; Tikhonov2D::solve
PUBLIC	?set_Lv_2ndDeriv@Tikhonov2D@@QEAAXXZ		; Tikhonov2D::set_Lv_2ndDeriv
PUBLIC	?set_Lf_2ndDeriv@Tikhonov2D@@QEAAXXZ		; Tikhonov2D::set_Lf_2ndDeriv
PUBLIC	??1Tikhonov2D@@QEAA@XZ				; Tikhonov2D::~Tikhonov2D
PUBLIC	??0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z ; Tikhonov2D::Tikhonov2D
_Tuple_alloc DB	01H DUP (?)
ignore	DB	01H DUP (?)
allocator_arg DB 01H DUP (?)
piecewise_construct DB 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$run@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@?$gemv_selector@$01$0A@$00@internal@Eigen@@SAXAEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEBN@Z DD imagerel $LN1729
	DD	imagerel $LN1729+732
	DD	imagerel $unwind$??$run@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@?$gemv_selector@$01$0A@$00@internal@Eigen@@SAXAEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEBN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$scaleAndAddTo@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@QEBAXAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBN@Z DD imagerel $LN28
	DD	imagerel $LN28+92
	DD	imagerel $unwind$??$scaleAndAddTo@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@QEBAXAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$scaleAndAddTo@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEBAXAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBN@Z DD imagerel $LN32
	DD	imagerel $LN32+92
	DD	imagerel $unwind$??$scaleAndAddTo@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEBAXAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$run@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@@?$unaligned_assign_impl@$0A@@internal@Eigen@@SAXAEBV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@_J2@Z DD imagerel $LN31
	DD	imagerel $LN31+169
	DD	imagerel $unwind$??$run@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@@?$unaligned_assign_impl@$0A@@internal@Eigen@@SAXAEBV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@_J2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$resizeLike@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAXAEBU?$EigenBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z DD imagerel $LN159
	DD	imagerel $LN159+181
	DD	imagerel $unwind$??$resizeLike@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAXAEBU?$EigenBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$evalTo@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEBAXAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@@Z DD imagerel $LN417
	DD	imagerel $LN417+339
	DD	imagerel $unwind$??$evalTo@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEBAXAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$resizeLike@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAXAEBU?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z DD imagerel $LN212
	DD	imagerel $LN212+168
	DD	imagerel $unwind$??$resizeLike@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAXAEBU?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$resizeLike@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAXAEBU?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z DD imagerel $LN212
	DD	imagerel $LN212+168
	DD	imagerel $unwind$??$resizeLike@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAXAEBU?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?run@?$assign_impl@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$02$0A@$0A@@internal@Eigen@@SAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z DD imagerel $LN75
	DD	imagerel $LN75+93
	DD	imagerel $unwind$?run@?$assign_impl@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$02$0A@$0A@@internal@Eigen@@SAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$lazyAssign@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z DD imagerel $LN119
	DD	imagerel $LN119+148
	DD	imagerel $unwind$??$lazyAssign@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_resize_to_match@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAAXAEBU?$EigenBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z DD imagerel $LN162
	DD	imagerel $LN162+181
	DD	imagerel $unwind$??$_resize_to_match@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAAXAEBU?$EigenBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$lazyAssign@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@?$MatrixBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@1@@Z DD imagerel $LN10
	DD	imagerel $LN10+32
	DD	imagerel $unwind$??$lazyAssign@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@?$MatrixBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_resize_to_match@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@IEAAXAEBU?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z DD imagerel $LN215
	DD	imagerel $LN215+168
	DD	imagerel $unwind$??$_resize_to_match@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@IEAAXAEBU?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$lazyAssign@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@?$MatrixBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@1@@Z DD imagerel $LN10
	DD	imagerel $LN10+32
	DD	imagerel $unwind$??$lazyAssign@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@?$MatrixBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_resize_to_match@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@IEAAXAEBU?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z DD imagerel $LN215
	DD	imagerel $LN215+168
	DD	imagerel $unwind$??$_resize_to_match@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@IEAAXAEBU?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?run@?$assign_impl@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@3@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Z DD imagerel $LN710
	DD	imagerel $LN710+23
	DD	imagerel $unwind$?run@?$assign_impl@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@3@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?run@?$assign_impl@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@3@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Z DD imagerel $LN710+23
	DD	imagerel $LN710+117
	DD	imagerel $chain$0$?run@?$assign_impl@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@3@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?run@?$assign_impl@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@3@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Z DD imagerel $LN710+117
	DD	imagerel $LN710+267
	DD	imagerel $chain$1$?run@?$assign_impl@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@3@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?run@?$assign_impl@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@3@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Z DD imagerel $LN710+267
	DD	imagerel $LN710+320
	DD	imagerel $chain$2$?run@?$assign_impl@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@3@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?run@?$assign_impl@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@3@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Z DD imagerel $LN710+320
	DD	imagerel $LN710+424
	DD	imagerel $chain$3$?run@?$assign_impl@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@3@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$lazyAssign@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@QEAAAEAV01@AEBV?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@1@@Z DD imagerel $LN38
	DD	imagerel $LN38+87
	DD	imagerel $unwind$??$lazyAssign@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@QEAAAEAV01@AEBV?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$lazyAssign@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z DD imagerel $LN284
	DD	imagerel $LN284+289
	DD	imagerel $unwind$??$lazyAssign@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$lazyAssign@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$DenseBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z DD imagerel $LN228
	DD	imagerel $LN228+195
	DD	imagerel $unwind$??$lazyAssign@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$DenseBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$lazyAssign@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$DenseBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z DD imagerel $LN228
	DD	imagerel $LN228+195
	DD	imagerel $unwind$??$lazyAssign@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$DenseBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_set_selector@V?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@IEAAXAEBV?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@1@AEBUfalse_type@internal@1@@Z DD imagerel $LN370
	DD	imagerel $LN370+407
	DD	imagerel $unwind$??$_set_selector@V?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@IEAAXAEBV?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@1@AEBUfalse_type@internal@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@$0A@$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Z DD imagerel $LN254
	DD	imagerel $LN254+35
	DD	imagerel $unwind$?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@$0A@$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@$0A@$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Z DD imagerel $LN254+35
	DD	imagerel $LN254+328
	DD	imagerel $chain$2$?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@$0A@$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@$0A@$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Z DD imagerel $LN254+328
	DD	imagerel $LN254+338
	DD	imagerel $chain$3$?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@$0A@$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@Z DD imagerel $LN746
	DD	imagerel $LN746+134
	DD	imagerel $unwind$?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@Z DD imagerel $LN746+134
	DD	imagerel $LN746+568
	DD	imagerel $chain$1$?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@Z DD imagerel $LN746+568
	DD	imagerel $LN746+593
	DD	imagerel $chain$2$?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z DD imagerel $LN746
	DD	imagerel $LN746+109
	DD	imagerel $unwind$?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z DD imagerel $LN746+109
	DD	imagerel $LN746+206
	DD	imagerel $chain$0$?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z DD imagerel $LN746+206
	DD	imagerel $LN746+315
	DD	imagerel $chain$1$?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?run@?$assign_selector@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@$0A@$0A@@internal@Eigen@@SAAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@3@AEAV43@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Z DD imagerel $LN42
	DD	imagerel $LN42+87
	DD	imagerel $unwind$?run@?$assign_selector@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@$0A@$0A@@internal@Eigen@@SAAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@3@AEAV43@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?run@?$assign_selector@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$0A@$0A@@internal@Eigen@@SAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@AEAV43@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z DD imagerel $LN289
	DD	imagerel $LN289+289
	DD	imagerel $unwind$?run@?$assign_selector@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$0A@$0A@@internal@Eigen@@SAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@AEAV43@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?run@?$assign_selector@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@$0A@$0A@@internal@Eigen@@SAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@3@AEAV43@AEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@3@@Z DD imagerel $LN233
	DD	imagerel $LN233+195
	DD	imagerel $unwind$?run@?$assign_selector@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@$0A@$0A@@internal@Eigen@@SAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@3@AEAV43@AEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?run@?$assign_selector@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@$0A@$0A@@internal@Eigen@@SAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@3@AEAV43@AEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@3@@Z DD imagerel $LN233
	DD	imagerel $LN233+195
	DD	imagerel $unwind$?run@?$assign_selector@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@$0A@$0A@@internal@Eigen@@SAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@3@AEAV43@AEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$lazyAssign@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@?$DenseBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@1@AEBV?$DenseBase@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@1@@Z DD imagerel $LN97
	DD	imagerel $LN97+132
	DD	imagerel $unwind$??$lazyAssign@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@?$DenseBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@1@AEBV?$DenseBase@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$lazyAssign@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@?$DenseBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@1@AEBV?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@1@@Z DD imagerel $LN46
	DD	imagerel $LN46+87
	DD	imagerel $unwind$??$lazyAssign@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@?$DenseBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@1@AEBV?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$lazyAssign@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@1@AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z DD imagerel $LN46
	DD	imagerel $LN46+84
	DD	imagerel $unwind$??$lazyAssign@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@1@AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?4V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@?$MatrixBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@QEAAAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@1@AEBV?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@1@@Z DD imagerel $LN48
	DD	imagerel $LN48+87
	DD	imagerel $unwind$??$?4V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@?$MatrixBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@QEAAAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@1@AEBV?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_set_noalias@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z DD imagerel $LN296
	DD	imagerel $LN296+289
	DD	imagerel $unwind$??$_set_noalias@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_set@V?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@IEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$DenseBase@V?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@@1@@Z DD imagerel $LN379
	DD	imagerel $LN379+419
	DD	imagerel $unwind$??$_set@V?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@IEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$DenseBase@V?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_set_noalias@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@IEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$DenseBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z DD imagerel $LN240
	DD	imagerel $LN240+195
	DD	imagerel $unwind$??$_set_noalias@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@IEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$DenseBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_set_noalias@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@IEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$DenseBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z DD imagerel $LN240
	DD	imagerel $LN240+195
	DD	imagerel $unwind$??$_set_noalias@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@IEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$DenseBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEAA@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@1@@Z DD imagerel $LN29
	DD	imagerel $LN29+93
	DD	imagerel $unwind$??0?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEAA@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?run@?$assign_selector@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@$0A@$0A@@internal@Eigen@@SAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEAV43@AEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Z DD imagerel $LN101
	DD	imagerel $LN101+132
	DD	imagerel $unwind$?run@?$assign_selector@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@$0A@$0A@@internal@Eigen@@SAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEAV43@AEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?run@?$assign_selector@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$0A@$0A@@internal@Eigen@@SAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEAV43@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@Z DD imagerel $LN50
	DD	imagerel $LN50+87
	DD	imagerel $unwind$?run@?$assign_selector@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$0A@$0A@@internal@Eigen@@SAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEAV43@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?run@?$assign_selector@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$0A@$0A@@internal@Eigen@@SAAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@AEAV43@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z DD imagerel $LN50
	DD	imagerel $LN50+84
	DD	imagerel $unwind$?run@?$assign_selector@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$0A@$0A@@internal@Eigen@@SAAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@AEAV43@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@QEAAAEAV01@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@1@@Z DD imagerel $LN52
	DD	imagerel $LN52+143
	DD	imagerel $unwind$??4?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@QEAAAEAV01@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@QEAA@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@1@@Z DD imagerel $LN31
	DD	imagerel $LN31+93
	DD	imagerel $unwind$??0?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@QEAA@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@AEBV?$MatrixBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z DD imagerel $LN354
	DD	imagerel $LN354+393
	DD	imagerel $unwind$??$?0V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@AEBV?$MatrixBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?4V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@?$MatrixBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@1@AEBV?$DenseBase@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@1@@Z DD imagerel $LN107
	DD	imagerel $LN107+132
	DD	imagerel $unwind$??$?4V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@?$MatrixBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@1@AEBV?$DenseBase@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?4V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@?$MatrixBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@1@AEBV?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@1@@Z DD imagerel $LN56
	DD	imagerel $LN56+87
	DD	imagerel $unwind$??$?4V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@?$MatrixBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@1@AEBV?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?4V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$MatrixBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@1@AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z DD imagerel $LN56
	DD	imagerel $LN56+84
	DD	imagerel $unwind$??$?4V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$MatrixBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@1@AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?YV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@?$MatrixBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$MatrixBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@1@@Z DD imagerel $LN62
	DD	imagerel $LN62+157
	DD	imagerel $unwind$??$?YV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@?$MatrixBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$MatrixBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?4V?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAAAEAV01@AEBV?$MatrixBase@V?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@@1@@Z DD imagerel $LN382
	DD	imagerel $LN382+419
	DD	imagerel $unwind$??$?4V?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAAAEAV01@AEBV?$MatrixBase@V?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@AEBV?$MatrixBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z DD imagerel $LN318
	DD	imagerel $LN318+289
	DD	imagerel $unwind$??$?0V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@AEBV?$MatrixBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?DV?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@Eigen@@@?$MatrixBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA?BV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@1@AEBV?$MatrixBase@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@Eigen@@@1@@Z DD imagerel $LN37
	DD	imagerel $LN37+90
	DD	imagerel $unwind$??$?DV?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@Eigen@@@?$MatrixBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA?BV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@1@AEBV?$MatrixBase@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@Eigen@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z DD imagerel ??$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z
	DD	imagerel ??$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z+517
	DD	imagerel $unwind$??$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@AEBV?$MatrixBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z DD imagerel $LN318
	DD	imagerel $LN318+289
	DD	imagerel $unwind$??$?0V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@AEBV?$MatrixBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$MapBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEAA@PEAN_J1@Z DD imagerel $LN16
	DD	imagerel $LN16+70
	DD	imagerel $unwind$??0?$MapBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEAA@PEAN_J1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$MapBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEAA@PEAN_J1@Z DD imagerel $LN16
	DD	imagerel $LN16+69
	DD	imagerel $unwind$??0?$MapBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEAA@PEAN_J1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$MapBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAA@PEAN_J1@Z DD imagerel $LN18
	DD	imagerel $LN18+70
	DD	imagerel $unwind$??0?$MapBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAA@PEAN_J1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$MapBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAA@PEAN_J1@Z DD imagerel $LN18
	DD	imagerel $LN18+69
	DD	imagerel $unwind$??0?$MapBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAA@PEAN_J1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$BlockImpl_dense@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@$00@internal@Eigen@@QEAA@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@_J111@Z DD imagerel $LN80
	DD	imagerel $LN80+119
	DD	imagerel $unwind$??0?$BlockImpl_dense@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@$00@internal@Eigen@@QEAA@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@_J111@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$BlockImpl_dense@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@$00@internal@Eigen@@QEAA@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@_J111@Z DD imagerel $LN80
	DD	imagerel $LN80+105
	DD	imagerel $unwind$??0?$BlockImpl_dense@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@$00@internal@Eigen@@QEAA@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@_J111@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$BlockImpl@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@UDense@2@@Eigen@@QEAA@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@_J111@Z DD imagerel $LN82
	DD	imagerel $LN82+119
	DD	imagerel $unwind$??0?$BlockImpl@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@UDense@2@@Eigen@@QEAA@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@_J111@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$BlockImpl@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@UDense@2@@Eigen@@QEAA@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@_J111@Z DD imagerel $LN82
	DD	imagerel $LN82+105
	DD	imagerel $unwind$??0?$BlockImpl@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@UDense@2@@Eigen@@QEAA@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@_J111@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@QEAA@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@_J111@Z DD imagerel $LN96
	DD	imagerel $LN96+226
	DD	imagerel $unwind$??0?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@QEAA@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@_J111@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@QEAA@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@_J111@Z DD imagerel $LN98
	DD	imagerel $LN98+176
	DD	imagerel $unwind$??0?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@QEAA@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@_J111@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$DenseCoeffsBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$00@Eigen@@QEAAAEAN_J@Z DD imagerel $LN30
	DD	imagerel $LN30+79
	DD	imagerel $unwind$??R?$DenseCoeffsBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$00@Eigen@@QEAAAEAN_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?block@?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAA?AV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@2@_J000@Z DD imagerel $LN6
	DD	imagerel $LN6+49
	DD	imagerel $unwind$?block@?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAA?AV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@2@_J000@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$DenseCoeffsBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0A@@Eigen@@QEBAAEBN_J@Z DD imagerel $LN30
	DD	imagerel $LN30+71
	DD	imagerel $unwind$??R?$DenseCoeffsBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0A@@Eigen@@QEBAAEBN_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$DenseCoeffsBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0A@@Eigen@@QEBAAEBN_J@Z DD imagerel $LN30
	DD	imagerel $LN30+71
	DD	imagerel $unwind$??A?$DenseCoeffsBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0A@@Eigen@@QEBAAEBN_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?block@?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAA?AV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@_J000@Z DD imagerel $LN6
	DD	imagerel $LN6+39
	DD	imagerel $unwind$?block@?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAA?AV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@_J000@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getAdv_ij@Tikhonov2D@@AEBAN_K0@Z DD imagerel $LN118
	DD	imagerel $LN118+367
	DD	imagerel $unwind$?getAdv_ij@Tikhonov2D@@AEBAN_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getA_ij@Tikhonov2D@@AEBAN_K0@Z DD imagerel $LN174
	DD	imagerel $LN174+449
	DD	imagerel $unwind$?getA_ij@Tikhonov2D@@AEBAN_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setJandH@Tikhonov2D@@AEAA_NNN@Z DD imagerel $LN5953
	DD	imagerel $LN5953+7143
	DD	imagerel $unwind$?setJandH@Tikhonov2D@@AEAA_NNN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?updateFandV@Tikhonov2D@@AEAA_NNNNN@Z DD imagerel $LN1132
	DD	imagerel $LN1132+1545
	DD	imagerel $unwind$?updateFandV@Tikhonov2D@@AEAA_NNNNN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?updateV@Tikhonov2D@@AEAA_NNN@Z DD imagerel $LN1533
	DD	imagerel $LN1533+1634
	DD	imagerel $unwind$?updateV@Tikhonov2D@@AEAA_NNN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?updateF@Tikhonov2D@@AEAA_NNN@Z DD imagerel $LN1533
	DD	imagerel $LN1533+1631
	DD	imagerel $unwind$?updateF@Tikhonov2D@@AEAA_NNN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?open@IGORdata@@YA_NAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@W4OpenCondition@1@@Z DD imagerel ?open@IGORdata@@YA_NAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@W4OpenCondition@1@@Z
	DD	imagerel ?open@IGORdata@@YA_NAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@W4OpenCondition@1@@Z+571
	DD	imagerel $unwind$?open@IGORdata@@YA_NAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@W4OpenCondition@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getAf@Tikhonov2D@@QEBA?AV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@XZ DD imagerel $LN739
	DD	imagerel $LN739+729
	DD	imagerel $unwind$?getAf@Tikhonov2D@@QEBA?AV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?solve@Tikhonov2D@@QEAA_NNNNN@Z DD imagerel $LN961
	DD	imagerel $LN961+1445
	DD	imagerel $unwind$?solve@Tikhonov2D@@QEAA_NNNNN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?set_Lv_2ndDeriv@Tikhonov2D@@QEAAXXZ DD imagerel $LN600
	DD	imagerel $LN600+127
	DD	imagerel $unwind$?set_Lv_2ndDeriv@Tikhonov2D@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?set_Lv_2ndDeriv@Tikhonov2D@@QEAAXXZ DD imagerel $LN600+127
	DD	imagerel $LN600+931
	DD	imagerel $chain$2$?set_Lv_2ndDeriv@Tikhonov2D@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?set_Lv_2ndDeriv@Tikhonov2D@@QEAAXXZ DD imagerel $LN600+931
	DD	imagerel $LN600+943
	DD	imagerel $chain$3$?set_Lv_2ndDeriv@Tikhonov2D@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?set_Lv_2ndDeriv@Tikhonov2D@@QEAAXXZ DD imagerel $LN600+943
	DD	imagerel $LN600+961
	DD	imagerel $chain$4$?set_Lv_2ndDeriv@Tikhonov2D@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?set_Lf_2ndDeriv@Tikhonov2D@@QEAAXXZ DD imagerel $LN600
	DD	imagerel $LN600+127
	DD	imagerel $unwind$?set_Lf_2ndDeriv@Tikhonov2D@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?set_Lf_2ndDeriv@Tikhonov2D@@QEAAXXZ DD imagerel $LN600+127
	DD	imagerel $LN600+931
	DD	imagerel $chain$2$?set_Lf_2ndDeriv@Tikhonov2D@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?set_Lf_2ndDeriv@Tikhonov2D@@QEAAXXZ DD imagerel $LN600+931
	DD	imagerel $LN600+943
	DD	imagerel $chain$3$?set_Lf_2ndDeriv@Tikhonov2D@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?set_Lf_2ndDeriv@Tikhonov2D@@QEAAXXZ DD imagerel $LN600+943
	DD	imagerel $LN600+961
	DD	imagerel $chain$4$?set_Lf_2ndDeriv@Tikhonov2D@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1Tikhonov2D@@QEAA@XZ DD imagerel $LN400
	DD	imagerel $LN400+286
	DD	imagerel $unwind$??1Tikhonov2D@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z DD imagerel $LN990
	DD	imagerel $LN990+1806
	DD	imagerel $unwind$??0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z DD imagerel ??0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z
	DD	0ffffffffH
	DD	imagerel ??0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z+82
	DD	01H
	DD	imagerel ??0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z+194
	DD	02H
	DD	imagerel ??0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z+419
	DD	03H
	DD	imagerel ??0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z+503
	DD	04H
	DD	imagerel ??0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z+723
	DD	05H
	DD	imagerel ??0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z+733
	DD	06H
	DD	imagerel ??0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z+745
	DD	07H
	DD	imagerel ??0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z+757
	DD	08H
	DD	imagerel ??0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z+778
	DD	09H
	DD	imagerel ??0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z+799
	DD	0aH
	DD	imagerel ??0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z+820
	DD	0bH
	DD	imagerel ??0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z+841
	DD	0cH
	DD	imagerel ??0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z+855
	DD	0dH
	DD	imagerel ??0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z+869
	DD	0eH
	DD	imagerel ??0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z+883
	DD	0fH
	DD	imagerel ??0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z+897
	DD	010H
	DD	imagerel ??0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z+911
	DD	011H
	DD	imagerel ??0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z+932
	DD	012H
	DD	imagerel ??0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z+953
	DD	013H
	DD	imagerel ??0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z+974
	DD	014H
	DD	imagerel ??0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z+995
	DD	015H
	DD	imagerel ??0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z+1009
	DD	016H
	DD	imagerel ??0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z+1023
	DD	017H
	DD	imagerel ??0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z+1037
	DD	018H
	DD	imagerel ??0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z+1051
	DD	019H
	DD	imagerel ??0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z+1741
	DD	00H
	DD	imagerel ??0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z+1751
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA
	DD	01H
	DD	imagerel ?dtor$24@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA
	DD	01H
	DD	imagerel ?dtor$2@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA
	DD	03H
	DD	imagerel ?dtor$26@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA
	DD	03H
	DD	imagerel ?dtor$3@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA
	DD	05H
	DD	imagerel ?dtor$4@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA
	DD	06H
	DD	imagerel ?dtor$5@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA
	DD	07H
	DD	imagerel ?dtor$6@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA
	DD	08H
	DD	imagerel ?dtor$7@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA
	DD	09H
	DD	imagerel ?dtor$8@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA
	DD	0aH
	DD	imagerel ?dtor$9@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA
	DD	0bH
	DD	imagerel ?dtor$10@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA
	DD	0cH
	DD	imagerel ?dtor$11@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA
	DD	0dH
	DD	imagerel ?dtor$12@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA
	DD	0eH
	DD	imagerel ?dtor$13@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA
	DD	0fH
	DD	imagerel ?dtor$14@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA
	DD	010H
	DD	imagerel ?dtor$15@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA
	DD	011H
	DD	imagerel ?dtor$16@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA
	DD	012H
	DD	imagerel ?dtor$17@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA
	DD	013H
	DD	imagerel ?dtor$18@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA
	DD	014H
	DD	imagerel ?dtor$19@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA
	DD	015H
	DD	imagerel ?dtor$20@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA
	DD	016H
	DD	imagerel ?dtor$21@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA
	DD	017H
	DD	imagerel ?dtor$22@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA
	DD	018H
	DD	imagerel ?dtor$23@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z DD 019930522H
	DD	01aH
	DD	imagerel $stateUnwindMap$??0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z
	DD	00H
	DD	00H
	DD	01cH
	DD	imagerel $ip2state$??0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z
	DD	040H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z DD 0c3319H
	DD	0156424H
	DD	0145420H
	DD	013341cH
	DD	0f00cb210H
	DD	0d008e00aH
	DD	07004c006H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$??0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z
	DD	05aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1Tikhonov2D@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?set_Lf_2ndDeriv@Tikhonov2D@@QEAAXXZ DD 060021H
	DD	08e400H
	DD	0107400H
	DD	0f3400H
	DD	imagerel $LN600
	DD	imagerel $LN600+127
	DD	imagerel $unwind$?set_Lf_2ndDeriv@Tikhonov2D@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?set_Lf_2ndDeriv@Tikhonov2D@@QEAAXXZ DD 021H
	DD	imagerel $LN600
	DD	imagerel $LN600+127
	DD	imagerel $unwind$?set_Lf_2ndDeriv@Tikhonov2D@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?set_Lf_2ndDeriv@Tikhonov2D@@QEAAXXZ DD 061d21H
	DD	08e41dH
	DD	0107414H
	DD	0f3405H
	DD	imagerel $LN600
	DD	imagerel $LN600+127
	DD	imagerel $unwind$?set_Lf_2ndDeriv@Tikhonov2D@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?set_Lf_2ndDeriv@Tikhonov2D@@QEAAXXZ DD 050b01H
	DD	0f007820bH
	DD	06003c005H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?set_Lv_2ndDeriv@Tikhonov2D@@QEAAXXZ DD 060021H
	DD	08e400H
	DD	0107400H
	DD	0f3400H
	DD	imagerel $LN600
	DD	imagerel $LN600+127
	DD	imagerel $unwind$?set_Lv_2ndDeriv@Tikhonov2D@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?set_Lv_2ndDeriv@Tikhonov2D@@QEAAXXZ DD 021H
	DD	imagerel $LN600
	DD	imagerel $LN600+127
	DD	imagerel $unwind$?set_Lv_2ndDeriv@Tikhonov2D@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?set_Lv_2ndDeriv@Tikhonov2D@@QEAAXXZ DD 061d21H
	DD	08e41dH
	DD	0107414H
	DD	0f3405H
	DD	imagerel $LN600
	DD	imagerel $LN600+127
	DD	imagerel $unwind$?set_Lv_2ndDeriv@Tikhonov2D@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?set_Lv_2ndDeriv@Tikhonov2D@@QEAAXXZ DD 050b01H
	DD	0f007820bH
	DD	06003c005H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?solve@Tikhonov2D@@QEAA_NNNNN@Z DD imagerel ?solve@Tikhonov2D@@QEAA_NNNNN@Z
	DD	0ffffffffH
	DD	imagerel ?solve@Tikhonov2D@@QEAA_NNNNN@Z+392
	DD	00H
	DD	imagerel ?solve@Tikhonov2D@@QEAA_NNNNN@Z+431
	DD	0ffffffffH
	DD	imagerel ?solve@Tikhonov2D@@QEAA_NNNNN@Z+494
	DD	01H
	DD	imagerel ?solve@Tikhonov2D@@QEAA_NNNNN@Z+533
	DD	0ffffffffH
	DD	imagerel ?solve@Tikhonov2D@@QEAA_NNNNN@Z+714
	DD	02H
	DD	imagerel ?solve@Tikhonov2D@@QEAA_NNNNN@Z+753
	DD	0ffffffffH
	DD	imagerel ?solve@Tikhonov2D@@QEAA_NNNNN@Z+816
	DD	03H
	DD	imagerel ?solve@Tikhonov2D@@QEAA_NNNNN@Z+855
	DD	0ffffffffH
	DD	imagerel ?solve@Tikhonov2D@@QEAA_NNNNN@Z+969
	DD	06H
	DD	imagerel ?solve@Tikhonov2D@@QEAA_NNNNN@Z+1008
	DD	0ffffffffH
	DD	imagerel ?solve@Tikhonov2D@@QEAA_NNNNN@Z+1071
	DD	07H
	DD	imagerel ?solve@Tikhonov2D@@QEAA_NNNNN@Z+1110
	DD	0ffffffffH
	DD	imagerel ?solve@Tikhonov2D@@QEAA_NNNNN@Z+1242
	DD	04H
	DD	imagerel ?solve@Tikhonov2D@@QEAA_NNNNN@Z+1281
	DD	0ffffffffH
	DD	imagerel ?solve@Tikhonov2D@@QEAA_NNNNN@Z+1344
	DD	05H
	DD	imagerel ?solve@Tikhonov2D@@QEAA_NNNNN@Z+1383
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?solve@Tikhonov2D@@QEAA_NNNNN@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??solve@Tikhonov2D@@QEAA_NNNNN@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$2@?0??solve@Tikhonov2D@@QEAA_NNNNN@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$4@?0??solve@Tikhonov2D@@QEAA_NNNNN@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$6@?0??solve@Tikhonov2D@@QEAA_NNNNN@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$8@?0??solve@Tikhonov2D@@QEAA_NNNNN@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$10@?0??solve@Tikhonov2D@@QEAA_NNNNN@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$12@?0??solve@Tikhonov2D@@QEAA_NNNNN@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$14@?0??solve@Tikhonov2D@@QEAA_NNNNN@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?solve@Tikhonov2D@@QEAA_NNNNN@Z DD 019930522H
	DD	08H
	DD	imagerel $stateUnwindMap$?solve@Tikhonov2D@@QEAA_NNNNN@Z
	DD	00H
	DD	00H
	DD	011H
	DD	imagerel $ip2state$?solve@Tikhonov2D@@QEAA_NNNNN@Z
	DD	030H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?solve@Tikhonov2D@@QEAA_NNNNN@Z DD 0113411H
	DD	089834H
	DD	09882fH
	DD	0a782aH
	DD	0b6826H
	DD	01e6422H
	DD	01d341eH
	DD	0180112H
	DD	07005e007H
	DD	05004H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?solve@Tikhonov2D@@QEAA_NNNNN@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?getAf@Tikhonov2D@@QEBA?AV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@XZ DD imagerel ?getAf@Tikhonov2D@@QEBA?AV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@XZ
	DD	0ffffffffH
	DD	imagerel ?getAf@Tikhonov2D@@QEBA?AV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@XZ+125
	DD	00H
	DD	imagerel ?getAf@Tikhonov2D@@QEBA?AV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@XZ+206
	DD	01H
	DD	imagerel ?getAf@Tikhonov2D@@QEBA?AV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@XZ+355
	DD	03H
	DD	imagerel ?getAf@Tikhonov2D@@QEBA?AV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@XZ+438
	DD	04H
	DD	imagerel ?getAf@Tikhonov2D@@QEBA?AV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@XZ+677
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?getAf@Tikhonov2D@@QEBA?AV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??getAf@Tikhonov2D@@QEBA?AV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@XZ@4HA
	DD	00H
	DD	imagerel ?dtor$3@?0??getAf@Tikhonov2D@@QEBA?AV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@XZ@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0??getAf@Tikhonov2D@@QEBA?AV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@XZ@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$1@?0??getAf@Tikhonov2D@@QEBA?AV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@XZ@4HA
	DD	03H
	DD	imagerel ?dtor$5@?0??getAf@Tikhonov2D@@QEBA?AV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?getAf@Tikhonov2D@@QEBA?AV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@XZ DD 019930522H
	DD	05H
	DD	imagerel $stateUnwindMap$?getAf@Tikhonov2D@@QEBA?AV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@XZ
	DD	00H
	DD	00H
	DD	06H
	DD	imagerel $ip2state$?getAf@Tikhonov2D@@QEBA?AV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@XZ
	DD	030H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getAf@Tikhonov2D@@QEBA?AV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@XZ DD 0b3619H
	DD	01e3428H
	DD	0140118H
	DD	0e00af00cH
	DD	0c006d008H
	DD	060037004H
	DD	05002H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?getAf@Tikhonov2D@@QEBA?AV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@XZ
	DD	092H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?open@IGORdata@@YA_NAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@W4OpenCondition@1@@Z DD imagerel ?open@IGORdata@@YA_NAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@W4OpenCondition@1@@Z
	DD	0ffffffffH
	DD	imagerel ?open@IGORdata@@YA_NAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@W4OpenCondition@1@@Z+52
	DD	00H
	DD	imagerel ?open@IGORdata@@YA_NAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@W4OpenCondition@1@@Z+165
	DD	01H
	DD	imagerel ?open@IGORdata@@YA_NAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@W4OpenCondition@1@@Z+212
	DD	00H
	DD	imagerel ?open@IGORdata@@YA_NAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@W4OpenCondition@1@@Z+504
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?open@IGORdata@@YA_NAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@W4OpenCondition@1@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??open@IGORdata@@YA_NAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@W4OpenCondition@1@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0??open@IGORdata@@YA_NAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@W4OpenCondition@1@@Z@4HA
	DD	00H
	DD	00H
	DD	02H
	DD	00H
	DD	02H
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?open@IGORdata@@YA_NAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@W4OpenCondition@1@@Z DD 019930522H
	DD	05H
	DD	imagerel $stateUnwindMap$?open@IGORdata@@YA_NAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@W4OpenCondition@1@@Z
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$?open@IGORdata@@YA_NAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@W4OpenCondition@1@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?open@IGORdata@@YA_NAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@W4OpenCondition@1@@Z DD 082a19H
	DD	013541bH
	DD	0123417H
	DD	0e007b20bH
	DD	060047005H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?open@IGORdata@@YA_NAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@W4OpenCondition@1@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?updateF@Tikhonov2D@@AEAA_NNN@Z DD imagerel ?updateF@Tikhonov2D@@AEAA_NNN@Z
	DD	0ffffffffH
	DD	imagerel ?updateF@Tikhonov2D@@AEAA_NNN@Z+103
	DD	00H
	DD	imagerel ?updateF@Tikhonov2D@@AEAA_NNN@Z+167
	DD	01H
	DD	imagerel ?updateF@Tikhonov2D@@AEAA_NNN@Z+288
	DD	02H
	DD	imagerel ?updateF@Tikhonov2D@@AEAA_NNN@Z+655
	DD	04H
	DD	imagerel ?updateF@Tikhonov2D@@AEAA_NNN@Z+666
	DD	05H
	DD	imagerel ?updateF@Tikhonov2D@@AEAA_NNN@Z+880
	DD	06H
	DD	imagerel ?updateF@Tikhonov2D@@AEAA_NNN@Z+921
	DD	05H
	DD	imagerel ?updateF@Tikhonov2D@@AEAA_NNN@Z+992
	DD	07H
	DD	imagerel ?updateF@Tikhonov2D@@AEAA_NNN@Z+1033
	DD	05H
	DD	imagerel ?updateF@Tikhonov2D@@AEAA_NNN@Z+1105
	DD	08H
	DD	imagerel ?updateF@Tikhonov2D@@AEAA_NNN@Z+1152
	DD	05H
	DD	imagerel ?updateF@Tikhonov2D@@AEAA_NNN@Z+1225
	DD	09H
	DD	imagerel ?updateF@Tikhonov2D@@AEAA_NNN@Z+1245
	DD	0aH
	DD	imagerel ?updateF@Tikhonov2D@@AEAA_NNN@Z+1381
	DD	0cH
	DD	imagerel ?updateF@Tikhonov2D@@AEAA_NNN@Z+1444
	DD	0dH
	DD	imagerel ?updateF@Tikhonov2D@@AEAA_NNN@Z+1485
	DD	0cH
	DD	imagerel ?updateF@Tikhonov2D@@AEAA_NNN@Z+1562
	DD	05H
	DD	imagerel ?updateF@Tikhonov2D@@AEAA_NNN@Z+1573
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?updateF@Tikhonov2D@@AEAA_NNN@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??updateF@Tikhonov2D@@AEAA_NNN@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0??updateF@Tikhonov2D@@AEAA_NNN@Z@4HA
	DD	01H
	DD	imagerel ?dtor$13@?0??updateF@Tikhonov2D@@AEAA_NNN@Z@4HA
	DD	01H
	DD	imagerel ?dtor$2@?0??updateF@Tikhonov2D@@AEAA_NNN@Z@4HA
	DD	00H
	DD	imagerel ?dtor$2@?0??updateF@Tikhonov2D@@AEAA_NNN@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$2@?0??updateF@Tikhonov2D@@AEAA_NNN@Z@4HA
	DD	05H
	DD	imagerel ?dtor$3@?0??updateF@Tikhonov2D@@AEAA_NNN@Z@4HA
	DD	05H
	DD	imagerel ?dtor$5@?0??updateF@Tikhonov2D@@AEAA_NNN@Z@4HA
	DD	05H
	DD	imagerel ?dtor$7@?0??updateF@Tikhonov2D@@AEAA_NNN@Z@4HA
	DD	05H
	DD	imagerel ?dtor$9@?0??updateF@Tikhonov2D@@AEAA_NNN@Z@4HA
	DD	09H
	DD	imagerel ?dtor$15@?0??updateF@Tikhonov2D@@AEAA_NNN@Z@4HA
	DD	09H
	DD	imagerel ?dtor$10@?0??updateF@Tikhonov2D@@AEAA_NNN@Z@4HA
	DD	05H
	DD	imagerel ?dtor$10@?0??updateF@Tikhonov2D@@AEAA_NNN@Z@4HA
	DD	0cH
	DD	imagerel ?dtor$11@?0??updateF@Tikhonov2D@@AEAA_NNN@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?updateF@Tikhonov2D@@AEAA_NNN@Z DD 019930522H
	DD	0eH
	DD	imagerel $stateUnwindMap$?updateF@Tikhonov2D@@AEAA_NNN@Z
	DD	00H
	DD	00H
	DD	013H
	DD	imagerel $ip2state$?updateF@Tikhonov2D@@AEAA_NNN@Z
	DD	0c0H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?updateF@Tikhonov2D@@AEAA_NNN@Z DD 0d3819H
	DD	014682aH
	DD	0336426H
	DD	0323422H
	DD	02a0116H
	DD	0e009f00bH
	DD	07005c007H
	DD	05004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?updateF@Tikhonov2D@@AEAA_NNN@Z
	DD	0132H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?updateV@Tikhonov2D@@AEAA_NNN@Z DD imagerel ?updateV@Tikhonov2D@@AEAA_NNN@Z
	DD	0ffffffffH
	DD	imagerel ?updateV@Tikhonov2D@@AEAA_NNN@Z+106
	DD	00H
	DD	imagerel ?updateV@Tikhonov2D@@AEAA_NNN@Z+170
	DD	01H
	DD	imagerel ?updateV@Tikhonov2D@@AEAA_NNN@Z+291
	DD	02H
	DD	imagerel ?updateV@Tikhonov2D@@AEAA_NNN@Z+655
	DD	04H
	DD	imagerel ?updateV@Tikhonov2D@@AEAA_NNN@Z+666
	DD	05H
	DD	imagerel ?updateV@Tikhonov2D@@AEAA_NNN@Z+880
	DD	06H
	DD	imagerel ?updateV@Tikhonov2D@@AEAA_NNN@Z+927
	DD	05H
	DD	imagerel ?updateV@Tikhonov2D@@AEAA_NNN@Z+998
	DD	07H
	DD	imagerel ?updateV@Tikhonov2D@@AEAA_NNN@Z+1039
	DD	05H
	DD	imagerel ?updateV@Tikhonov2D@@AEAA_NNN@Z+1110
	DD	08H
	DD	imagerel ?updateV@Tikhonov2D@@AEAA_NNN@Z+1151
	DD	05H
	DD	imagerel ?updateV@Tikhonov2D@@AEAA_NNN@Z+1228
	DD	09H
	DD	imagerel ?updateV@Tikhonov2D@@AEAA_NNN@Z+1248
	DD	0aH
	DD	imagerel ?updateV@Tikhonov2D@@AEAA_NNN@Z+1384
	DD	0cH
	DD	imagerel ?updateV@Tikhonov2D@@AEAA_NNN@Z+1447
	DD	0dH
	DD	imagerel ?updateV@Tikhonov2D@@AEAA_NNN@Z+1488
	DD	0cH
	DD	imagerel ?updateV@Tikhonov2D@@AEAA_NNN@Z+1565
	DD	05H
	DD	imagerel ?updateV@Tikhonov2D@@AEAA_NNN@Z+1576
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?updateV@Tikhonov2D@@AEAA_NNN@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??updateV@Tikhonov2D@@AEAA_NNN@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0??updateV@Tikhonov2D@@AEAA_NNN@Z@4HA
	DD	01H
	DD	imagerel ?dtor$13@?0??updateV@Tikhonov2D@@AEAA_NNN@Z@4HA
	DD	01H
	DD	imagerel ?dtor$2@?0??updateV@Tikhonov2D@@AEAA_NNN@Z@4HA
	DD	00H
	DD	imagerel ?dtor$2@?0??updateV@Tikhonov2D@@AEAA_NNN@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$2@?0??updateV@Tikhonov2D@@AEAA_NNN@Z@4HA
	DD	05H
	DD	imagerel ?dtor$3@?0??updateV@Tikhonov2D@@AEAA_NNN@Z@4HA
	DD	05H
	DD	imagerel ?dtor$5@?0??updateV@Tikhonov2D@@AEAA_NNN@Z@4HA
	DD	05H
	DD	imagerel ?dtor$7@?0??updateV@Tikhonov2D@@AEAA_NNN@Z@4HA
	DD	05H
	DD	imagerel ?dtor$9@?0??updateV@Tikhonov2D@@AEAA_NNN@Z@4HA
	DD	09H
	DD	imagerel ?dtor$15@?0??updateV@Tikhonov2D@@AEAA_NNN@Z@4HA
	DD	09H
	DD	imagerel ?dtor$10@?0??updateV@Tikhonov2D@@AEAA_NNN@Z@4HA
	DD	05H
	DD	imagerel ?dtor$10@?0??updateV@Tikhonov2D@@AEAA_NNN@Z@4HA
	DD	0cH
	DD	imagerel ?dtor$11@?0??updateV@Tikhonov2D@@AEAA_NNN@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?updateV@Tikhonov2D@@AEAA_NNN@Z DD 019930522H
	DD	0eH
	DD	imagerel $stateUnwindMap$?updateV@Tikhonov2D@@AEAA_NNN@Z
	DD	00H
	DD	00H
	DD	013H
	DD	imagerel $ip2state$?updateV@Tikhonov2D@@AEAA_NNN@Z
	DD	0c0H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?updateV@Tikhonov2D@@AEAA_NNN@Z DD 0d3819H
	DD	014682aH
	DD	0336426H
	DD	0323422H
	DD	02a0116H
	DD	0e009f00bH
	DD	07005c007H
	DD	05004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?updateV@Tikhonov2D@@AEAA_NNN@Z
	DD	0132H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?updateFandV@Tikhonov2D@@AEAA_NNNNN@Z DD imagerel ?updateFandV@Tikhonov2D@@AEAA_NNNNN@Z
	DD	0ffffffffH
	DD	imagerel ?updateFandV@Tikhonov2D@@AEAA_NNNNN@Z+92
	DD	00H
	DD	imagerel ?updateFandV@Tikhonov2D@@AEAA_NNNNN@Z+154
	DD	01H
	DD	imagerel ?updateFandV@Tikhonov2D@@AEAA_NNNNN@Z+542
	DD	00H
	DD	imagerel ?updateFandV@Tikhonov2D@@AEAA_NNNNN@Z+554
	DD	0ffffffffH
	DD	imagerel ?updateFandV@Tikhonov2D@@AEAA_NNNNN@Z+1047
	DD	02H
	DD	imagerel ?updateFandV@Tikhonov2D@@AEAA_NNNNN@Z+1090
	DD	0ffffffffH
	DD	imagerel ?updateFandV@Tikhonov2D@@AEAA_NNNNN@Z+1154
	DD	03H
	DD	imagerel ?updateFandV@Tikhonov2D@@AEAA_NNNNN@Z+1197
	DD	0ffffffffH
	DD	imagerel ?updateFandV@Tikhonov2D@@AEAA_NNNNN@Z+1261
	DD	04H
	DD	imagerel ?updateFandV@Tikhonov2D@@AEAA_NNNNN@Z+1304
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?updateFandV@Tikhonov2D@@AEAA_NNNNN@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??updateFandV@Tikhonov2D@@AEAA_NNNNN@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0??updateFandV@Tikhonov2D@@AEAA_NNNNN@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$2@?0??updateFandV@Tikhonov2D@@AEAA_NNNNN@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$4@?0??updateFandV@Tikhonov2D@@AEAA_NNNNN@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$6@?0??updateFandV@Tikhonov2D@@AEAA_NNNNN@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?updateFandV@Tikhonov2D@@AEAA_NNNNN@Z DD 019930522H
	DD	05H
	DD	imagerel $stateUnwindMap$?updateFandV@Tikhonov2D@@AEAA_NNNNN@Z
	DD	00H
	DD	00H
	DD	0bH
	DD	imagerel $ip2state$?updateFandV@Tikhonov2D@@AEAA_NNNNN@Z
	DD	078H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?updateFandV@Tikhonov2D@@AEAA_NNNNN@Z DD 0d3619H
	DD	0d7828H
	DD	0e6824H
	DD	01e0118H
	DD	0e00bf00dH
	DD	07007c009H
	DD	030056006H
	DD	05004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?updateFandV@Tikhonov2D@@AEAA_NNNNN@Z
	DD	0caH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?setJandH@Tikhonov2D@@AEAA_NNN@Z DD imagerel ?setJandH@Tikhonov2D@@AEAA_NNN@Z
	DD	0ffffffffH
	DD	imagerel ?setJandH@Tikhonov2D@@AEAA_NNN@Z+2190
	DD	00H
	DD	imagerel ?setJandH@Tikhonov2D@@AEAA_NNN@Z+2214
	DD	01H
	DD	imagerel ?setJandH@Tikhonov2D@@AEAA_NNN@Z+2229
	DD	02H
	DD	imagerel ?setJandH@Tikhonov2D@@AEAA_NNN@Z+2499
	DD	01H
	DD	imagerel ?setJandH@Tikhonov2D@@AEAA_NNN@Z+2510
	DD	00H
	DD	imagerel ?setJandH@Tikhonov2D@@AEAA_NNN@Z+2522
	DD	0ffffffffH
	DD	imagerel ?setJandH@Tikhonov2D@@AEAA_NNN@Z+2573
	DD	03H
	DD	imagerel ?setJandH@Tikhonov2D@@AEAA_NNN@Z+2594
	DD	04H
	DD	imagerel ?setJandH@Tikhonov2D@@AEAA_NNN@Z+2609
	DD	05H
	DD	imagerel ?setJandH@Tikhonov2D@@AEAA_NNN@Z+2883
	DD	04H
	DD	imagerel ?setJandH@Tikhonov2D@@AEAA_NNN@Z+2894
	DD	03H
	DD	imagerel ?setJandH@Tikhonov2D@@AEAA_NNN@Z+2906
	DD	0ffffffffH
	DD	imagerel ?setJandH@Tikhonov2D@@AEAA_NNN@Z+2944
	DD	06H
	DD	imagerel ?setJandH@Tikhonov2D@@AEAA_NNN@Z+2960
	DD	07H
	DD	imagerel ?setJandH@Tikhonov2D@@AEAA_NNN@Z+3267
	DD	06H
	DD	imagerel ?setJandH@Tikhonov2D@@AEAA_NNN@Z+3279
	DD	0ffffffffH
	DD	imagerel ?setJandH@Tikhonov2D@@AEAA_NNN@Z+3318
	DD	08H
	DD	imagerel ?setJandH@Tikhonov2D@@AEAA_NNN@Z+3334
	DD	09H
	DD	imagerel ?setJandH@Tikhonov2D@@AEAA_NNN@Z+3635
	DD	08H
	DD	imagerel ?setJandH@Tikhonov2D@@AEAA_NNN@Z+3647
	DD	0ffffffffH
	DD	imagerel ?setJandH@Tikhonov2D@@AEAA_NNN@Z+3710
	DD	0aH
	DD	imagerel ?setJandH@Tikhonov2D@@AEAA_NNN@Z+3974
	DD	0bH
	DD	imagerel ?setJandH@Tikhonov2D@@AEAA_NNN@Z+7056
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?setJandH@Tikhonov2D@@AEAA_NNN@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??setJandH@Tikhonov2D@@AEAA_NNN@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0??setJandH@Tikhonov2D@@AEAA_NNN@Z@4HA
	DD	01H
	DD	imagerel ?dtor$7@?0??setJandH@Tikhonov2D@@AEAA_NNN@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$2@?0??setJandH@Tikhonov2D@@AEAA_NNN@Z@4HA
	DD	03H
	DD	imagerel ?dtor$3@?0??setJandH@Tikhonov2D@@AEAA_NNN@Z@4HA
	DD	04H
	DD	imagerel ?dtor$8@?0??setJandH@Tikhonov2D@@AEAA_NNN@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$4@?0??setJandH@Tikhonov2D@@AEAA_NNN@Z@4HA
	DD	06H
	DD	imagerel ?dtor$9@?0??setJandH@Tikhonov2D@@AEAA_NNN@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$5@?0??setJandH@Tikhonov2D@@AEAA_NNN@Z@4HA
	DD	08H
	DD	imagerel ?dtor$10@?0??setJandH@Tikhonov2D@@AEAA_NNN@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$11@?0??setJandH@Tikhonov2D@@AEAA_NNN@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$6@?0??setJandH@Tikhonov2D@@AEAA_NNN@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?setJandH@Tikhonov2D@@AEAA_NNN@Z DD 019930522H
	DD	0cH
	DD	imagerel $stateUnwindMap$?setJandH@Tikhonov2D@@AEAA_NNN@Z
	DD	00H
	DD	00H
	DD	018H
	DD	imagerel $ip2state$?setJandH@Tikhonov2D@@AEAA_NNN@Z
	DD	0e0H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setJandH@Tikhonov2D@@AEAA_NNN@Z DD 0195919H
	DD	012b84bH
	DD	013a843H
	DD	014983eH
	DD	0158839H
	DD	0167834H
	DD	0176830H
	DD	039742cH
	DD	0386428H
	DD	0373424H
	DD	0300118H
	DD	0e00af00cH
	DD	0c006d008H
	DD	05004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?setJandH@Tikhonov2D@@AEAA_NNN@Z
	DD	0112H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getA_ij@Tikhonov2D@@AEBAN_K0@Z DD 0e4601H
	DD	04f446H
	DD	05e441H
	DD	0cd43cH
	DD	0bc437H
	DD	0a5432H
	DD	070045208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getAdv_ij@Tikhonov2D@@AEBAN_K0@Z DD 0104601H
	DD	027846H
	DD	036841H
	DD	0ff43cH
	DD	0ee437H
	DD	0dc432H
	DD	0c342dH
	DD	070047208H
	DD	050026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?block@?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAA?AV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@_J000@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$DenseCoeffsBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0A@@Eigen@@QEBAAEBN_J@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$DenseCoeffsBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0A@@Eigen@@QEBAAEBN_J@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?block@?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAA?AV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@2@_J000@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$DenseCoeffsBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$00@Eigen@@QEAAAEAN_J@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@QEAA@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@_J111@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@QEAA@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@_J111@Z DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0f0143218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$BlockImpl@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@UDense@2@@Eigen@@QEAA@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@_J111@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$BlockImpl@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@UDense@2@@Eigen@@QEAA@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@_J111@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$BlockImpl_dense@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@$00@internal@Eigen@@QEAA@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@_J111@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$BlockImpl_dense@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@$00@internal@Eigen@@QEAA@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@_J111@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$MapBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAA@PEAN_J1@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$MapBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAA@PEAN_J1@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$MapBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEAA@PEAN_J1@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$MapBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEAA@PEAN_J1@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@AEBV?$MatrixBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z DD imagerel ??$?0V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@AEBV?$MatrixBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z
	DD	0ffffffffH
	DD	imagerel ??$?0V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@AEBV?$MatrixBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z+118
	DD	00H
	DD	imagerel ??$?0V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@AEBV?$MatrixBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z+264
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@AEBV?$MatrixBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$?0V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@AEBV?$MatrixBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$?0V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@AEBV?$MatrixBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??$?0V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@AEBV?$MatrixBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??$?0V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@AEBV?$MatrixBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@AEBV?$MatrixBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z DD 082311H
	DD	0b7423H
	DD	0a641eH
	DD	093419H
	DD	0e007520bH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$?0V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@AEBV?$MatrixBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z DD imagerel ??$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z
	DD	0ffffffffH
	DD	imagerel ??$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z+60
	DD	01H
	DD	imagerel ??$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z+89
	DD	02H
	DD	imagerel ??$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z+150
	DD	01H
	DD	imagerel ??$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z+178
	DD	00H
	DD	imagerel ??$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z+209
	DD	0ffffffffH
	DD	imagerel ??$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z+232
	DD	02H
	DD	imagerel ??$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z+395
	DD	01H
	DD	imagerel ??$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z+423
	DD	00H
	DD	imagerel ??$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z+454
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z@4HA
	DD	01H
	DD	imagerel ?dtor$2@?0???$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z DD 019930522H
	DD	03H
	DD	imagerel $stateUnwindMap$??$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z
	DD	00H
	DD	00H
	DD	0aH
	DD	imagerel $ip2state$??$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z
	DD	040H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z DD 072919H
	DD	030010eH
	DD	07005e007H
	DD	050036004H
	DD	03002H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$??$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z
	DD	0172H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?DV?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@Eigen@@@?$MatrixBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA?BV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@1@AEBV?$MatrixBase@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@Eigen@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@AEBV?$MatrixBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z DD imagerel ??$?0V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@AEBV?$MatrixBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z
	DD	0ffffffffH
	DD	imagerel ??$?0V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@AEBV?$MatrixBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z+118
	DD	00H
	DD	imagerel ??$?0V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@AEBV?$MatrixBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z+264
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@AEBV?$MatrixBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$?0V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@AEBV?$MatrixBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$?0V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@AEBV?$MatrixBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??$?0V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@AEBV?$MatrixBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??$?0V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@AEBV?$MatrixBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@AEBV?$MatrixBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z DD 082311H
	DD	0b7423H
	DD	0a641eH
	DD	093419H
	DD	0e007520bH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$?0V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@AEBV?$MatrixBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?4V?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAAAEAV01@AEBV?$MatrixBase@V?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@@1@@Z DD 062a01H
	DD	0a742aH
	DD	060043208H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?YV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@?$MatrixBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$MatrixBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@1@@Z DD 021519H
	DD	03002d206H
	DD	imagerel __GSHandlerCheck
	DD	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?4V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$MatrixBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@1@AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?4V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@?$MatrixBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@1@AEBV?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@1@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?4V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@?$MatrixBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@1@AEBV?$DenseBase@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@1@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@AEBV?$MatrixBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z DD imagerel ??$?0V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@AEBV?$MatrixBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z
	DD	0ffffffffH
	DD	imagerel ??$?0V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@AEBV?$MatrixBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z+123
	DD	00H
	DD	imagerel ??$?0V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@AEBV?$MatrixBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z+371
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@AEBV?$MatrixBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$?0V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@AEBV?$MatrixBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$?0V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@AEBV?$MatrixBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??$?0V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@AEBV?$MatrixBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??$?0V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@AEBV?$MatrixBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@AEBV?$MatrixBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z DD 081c11H
	DD	0d541cH
	DD	0c3417H
	DD	0e0055209H
	DD	060027003H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$?0V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@AEBV?$MatrixBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@QEAA@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@QEAAAEAV01@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@1@@Z DD 021519H
	DD	030029206H
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?run@?$assign_selector@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$0A@$0A@@internal@Eigen@@SAAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@AEAV43@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?run@?$assign_selector@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$0A@$0A@@internal@Eigen@@SAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEAV43@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?run@?$assign_selector@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@$0A@$0A@@internal@Eigen@@SAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEAV43@AEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEAA@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_set_noalias@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@IEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$DenseBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_set_noalias@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@IEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$DenseBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_set@V?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@IEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$DenseBase@V?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@@1@@Z DD 062a01H
	DD	0a742aH
	DD	060043208H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_set_noalias@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z DD 060d01H
	DD	0a340dH
	DD	0e009320dH
	DD	060067007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?4V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@?$MatrixBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@QEAAAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@1@AEBV?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@1@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$lazyAssign@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@1@AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$lazyAssign@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@?$DenseBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@1@AEBV?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@1@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$lazyAssign@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@?$DenseBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@1@AEBV?$DenseBase@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@1@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?run@?$assign_selector@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@$0A@$0A@@internal@Eigen@@SAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@3@AEAV43@AEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@3@@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?run@?$assign_selector@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@$0A@$0A@@internal@Eigen@@SAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@3@AEAV43@AEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@3@@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?run@?$assign_selector@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$0A@$0A@@internal@Eigen@@SAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@AEAV43@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z DD 060d01H
	DD	0a340dH
	DD	0e009320dH
	DD	060067007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?run@?$assign_selector@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@$0A@$0A@@internal@Eigen@@SAAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@3@AEAV43@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z DD 021H
	DD	imagerel $LN746
	DD	imagerel $LN746+109
	DD	imagerel $unwind$?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z DD 020521H
	DD	087405H
	DD	imagerel $LN746
	DD	imagerel $LN746+109
	DD	imagerel $unwind$?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z DD 021519H
	DD	030023206H
	DD	imagerel __GSHandlerCheck
	DD	010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@Z DD 021H
	DD	imagerel $LN746
	DD	imagerel $LN746+134
	DD	imagerel $unwind$?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@Z DD 040a21H
	DD	0de40aH
	DD	0c7405H
	DD	imagerel $LN746
	DD	imagerel $LN746+134
	DD	imagerel $unwind$?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@Z DD 061b19H
	DD	0f008320cH
	DD	06004c006H
	DD	030025003H
	DD	imagerel __GSHandlerCheck
	DD	018H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@$0A@$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Z DD 021H
	DD	imagerel $LN254
	DD	imagerel $LN254+35
	DD	imagerel $unwind$?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@$0A@$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@$0A@$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Z DD 060f21H
	DD	05640fH
	DD	04540aH
	DD	033405H
	DD	imagerel $LN254
	DD	imagerel $LN254+35
	DD	imagerel $unwind$?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@$0A@$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@$0A@$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Z DD 040901H
	DD	067409H
	DD	0e007f009H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_set_selector@V?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@IEAAXAEBV?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@1@AEBUfalse_type@internal@1@@Z DD 062501H
	DD	0a7425H
	DD	060043208H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$lazyAssign@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$DenseBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$lazyAssign@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$DenseBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$lazyAssign@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z DD 060d01H
	DD	0a340dH
	DD	0e009320dH
	DD	060067007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$lazyAssign@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@QEAAAEAV01@AEBV?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@1@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?run@?$assign_impl@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@3@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Z DD 021H
	DD	imagerel $LN710
	DD	imagerel $LN710+23
	DD	imagerel $unwind$?run@?$assign_impl@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@3@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?run@?$assign_impl@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@3@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Z DD 021H
	DD	imagerel $LN710+23
	DD	imagerel $LN710+117
	DD	imagerel $chain$0$?run@?$assign_impl@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@3@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?run@?$assign_impl@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@3@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Z DD 020521H
	DD	046405H
	DD	imagerel $LN710+23
	DD	imagerel $LN710+117
	DD	imagerel $chain$0$?run@?$assign_impl@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@3@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?run@?$assign_impl@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@3@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Z DD 020521H
	DD	0a3405H
	DD	imagerel $LN710
	DD	imagerel $LN710+23
	DD	imagerel $unwind$?run@?$assign_impl@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@3@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?run@?$assign_impl@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@3@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Z DD 031719H
	DD	0e0044208H
	DD	07002H
	DD	imagerel __GSHandlerCheck
	DD	010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_resize_to_match@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@IEAAXAEBU?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$lazyAssign@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@?$MatrixBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_resize_to_match@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@IEAAXAEBU?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$lazyAssign@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@?$MatrixBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_resize_to_match@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAAXAEBU?$EigenBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$lazyAssign@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?run@?$assign_impl@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$02$0A@$0A@@internal@Eigen@@SAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$resizeLike@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAXAEBU?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$resizeLike@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAXAEBU?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$evalTo@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEBAXAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@@Z DD 064801H
	DD	0103448H
	DD	0e0059209H
	DD	060027003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$resizeLike@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAXAEBU?$EigenBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$run@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@@?$unaligned_assign_impl@$0A@@internal@Eigen@@SAXAEBV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@_J2@Z DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$scaleAndAddTo@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEBAXAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBN@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$scaleAndAddTo@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@QEBAXAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBN@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$run@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@?$gemv_selector@$01$0A@$00@internal@Eigen@@SAXAEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEBN@Z DD imagerel ??$run@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@?$gemv_selector@$01$0A@$00@internal@Eigen@@SAXAEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEBN@Z
	DD	0ffffffffH
	DD	imagerel ??$run@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@?$gemv_selector@$01$0A@$00@internal@Eigen@@SAXAEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEBN@Z+175
	DD	00H
	DD	imagerel ??$run@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@?$gemv_selector@$01$0A@$00@internal@Eigen@@SAXAEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEBN@Z+440
	DD	01H
	DD	imagerel ??$run@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@?$gemv_selector@$01$0A@$00@internal@Eigen@@SAXAEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEBN@Z+621
	DD	02H
	DD	imagerel ??$run@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@?$gemv_selector@$01$0A@$00@internal@Eigen@@SAXAEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEBN@Z+670
	DD	01H
	DD	imagerel ??$run@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@?$gemv_selector@$01$0A@$00@internal@Eigen@@SAXAEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEBN@Z+684
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$run@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@?$gemv_selector@$01$0A@$00@internal@Eigen@@SAXAEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEBN@Z DD 0ffffffffH
	DD	imagerel ?dtor$2@?0???$run@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@?$gemv_selector@$01$0A@$00@internal@Eigen@@SAXAEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEBN@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$0@?0???$run@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@?$gemv_selector@$01$0A@$00@internal@Eigen@@SAXAEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEBN@Z@4HA
	DD	01H
	DD	imagerel ?dtor$1@?0???$run@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@?$gemv_selector@$01$0A@$00@internal@Eigen@@SAXAEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEBN@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$run@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@?$gemv_selector@$01$0A@$00@internal@Eigen@@SAXAEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEBN@Z DD 019930522H
	DD	03H
	DD	imagerel $stateUnwindMap$??$run@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@?$gemv_selector@$01$0A@$00@internal@Eigen@@SAXAEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEBN@Z
	DD	00H
	DD	00H
	DD	06H
	DD	imagerel $ip2state$??$run@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@?$gemv_selector@$01$0A@$00@internal@Eigen@@SAXAEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEBN@Z
	DD	068H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$run@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@?$gemv_selector@$01$0A@$00@internal@Eigen@@SAXAEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEBN@Z DD 0550e3919H
	DD	0b682bH
	DD	0223427H
	DD	01135318H
	DD	0f00c0018H
	DD	0d008e00aH
	DD	07004c006H
	DD	050026003H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$??$run@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@?$gemv_selector@$01$0A@$00@internal@Eigen@@SAXAEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEBN@Z
	DD	0aaH
; Function compile flags: /Ogtpy
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
;	COMDAT ??0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z
_TEXT	SEGMENT
this$ = 32
this$ = 32
this$GSCopy$ = 48
wavelength_$GSCopy$ = 72
width_$GSCopy$ = 80
__$ArrayPad$ = 88
this$ = 144
size_i_$ = 152
size_j_$ = 160
vlight_$ = 168
lambda0_$ = 176
wavelength_$ = 184
width_$ = 192
??0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z PROC ; Tikhonov2D::Tikhonov2D, COMDAT

; 16   : {

$LN990:
	mov	r11, rsp
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 96					; 00000060H
	mov	QWORD PTR [r11-72], -2
	mov	QWORD PTR [r11+16], rbx
	mov	QWORD PTR [r11+24], rbp
	mov	QWORD PTR [r11+32], rsi
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rsi, rcx
	mov	QWORD PTR [r11-88], rcx
	mov	r14, QWORD PTR wavelength_$[rsp]
	mov	QWORD PTR [r11-64], r14
	mov	r15, QWORD PTR width_$[rsp]
	mov	QWORD PTR [r11-56], r15
	mov	QWORD PTR [rcx], rdx
	mov	QWORD PTR [rcx+8], r8
	movsdx	QWORD PTR [rcx+16], xmm3
	movsdx	xmm0, QWORD PTR lambda0_$[rsp]
	movsdx	QWORD PTR [rcx+24], xmm0
	lea	rbx, QWORD PTR [rcx+32]
	mov	QWORD PTR [r11-104], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 313  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rdi, QWORD PTR [r14+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 420  :   if(size==0)

	mov	r13, 2305843009213693951		; 1fffffffffffffffH
	xor	r12d, r12d
	test	rdi, rdi
	jne	SHORT $LN52@Tikhonov2D

; 421  :     return 0; // short-cut. Also fixes Bug 884

	mov	eax, r12d
	jmp	SHORT $LN53@Tikhonov2D
$LN52@Tikhonov2D:

; 244  :   #elif EIGEN_HAS_POSIX_MEMALIGN
; 245  :     std::free(ptr);
; 246  :   #elif EIGEN_HAS_MM_MALLOC
; 247  :     _mm_free(ptr);
; 248  :   #elif defined(_MSC_VER) && (!defined(_WIN32_WCE))
; 249  :     _aligned_free(ptr);
; 250  :   #else
; 251  :     handmade_aligned_free(ptr);
; 252  :   #endif
; 253  : }
; 254  : 
; 255  : /**
; 256  : * \internal
; 257  : * \brief Reallocates an aligned block of memory.
; 258  : * \throws std::bad_alloc on allocation failure
; 259  : **/
; 260  : inline void* aligned_realloc(void *ptr, size_t new_size, size_t old_size)
; 261  : {
; 262  :   EIGEN_UNUSED_VARIABLE(old_size);
; 263  : 
; 264  :   void *result;
; 265  : #if !EIGEN_ALIGN
; 266  :   result = std::realloc(ptr,new_size);
; 267  : #elif EIGEN_MALLOC_ALREADY_ALIGNED
; 268  :   result = std::realloc(ptr,new_size);
; 269  : #elif EIGEN_HAS_POSIX_MEMALIGN
; 270  :   result = generic_aligned_realloc(ptr,new_size,old_size);
; 271  : #elif EIGEN_HAS_MM_MALLOC
; 272  :   // The defined(_mm_free) is just here to verify that this MSVC version
; 273  :   // implements _mm_malloc/_mm_free based on the corresponding _aligned_
; 274  :   // functions. This may not always be the case and we just try to be safe.
; 275  :   #if defined(_MSC_VER) && (!defined(_WIN32_WCE)) && defined(_mm_free)
; 276  :     result = _aligned_realloc(ptr,new_size,16);
; 277  :   #else
; 278  :     result = generic_aligned_realloc(ptr,new_size,old_size);
; 279  :   #endif
; 280  : #elif defined(_MSC_VER) && (!defined(_WIN32_WCE))
; 281  :   result = _aligned_realloc(ptr,new_size,16);
; 282  : #else
; 283  :   result = handmade_aligned_realloc(ptr,new_size,old_size);
; 284  : #endif
; 285  : 
; 286  :   if (!result && new_size)
; 287  :     throw_std_bad_alloc();
; 288  : 
; 289  :   return result;
; 290  : }
; 291  : 
; 292  : /*****************************************************************************
; 293  : *** Implementation of conditionally aligned functions                      ***
; 294  : *****************************************************************************/
; 295  : 
; 296  : /** \internal Allocates \a size bytes. If Align is true, then the returned ptr is 16-byte-aligned.
; 297  :   * On allocation error, the returned pointer is null, and a std::bad_alloc is thrown.
; 298  :   */
; 299  : template<bool Align> inline void* conditional_aligned_malloc(size_t size)
; 300  : {
; 301  :   return aligned_malloc(size);
; 302  : }
; 303  : 
; 304  : template<> inline void* conditional_aligned_malloc<false>(size_t size)
; 305  : {
; 306  :   check_that_malloc_is_allowed();
; 307  : 
; 308  :   void *result = std::malloc(size);
; 309  :   if(!result && size)
; 310  :     throw_std_bad_alloc();
; 311  :   return result;
; 312  : }
; 313  : 
; 314  : /** \internal Frees memory allocated with conditional_aligned_malloc */
; 315  : template<bool Align> inline void conditional_aligned_free(void *ptr)
; 316  : {
; 317  :   aligned_free(ptr);
; 318  : }
; 319  : 
; 320  : template<> inline void conditional_aligned_free<false>(void *ptr)
; 321  : {
; 322  :   std::free(ptr);
; 323  : }
; 324  : 
; 325  : template<bool Align> inline void* conditional_aligned_realloc(void* ptr, size_t new_size, size_t old_size)
; 326  : {
; 327  :   return aligned_realloc(ptr, new_size, old_size);
; 328  : }
; 329  : 
; 330  : template<> inline void* conditional_aligned_realloc<false>(void* ptr, size_t new_size, size_t)
; 331  : {
; 332  :   return std::realloc(ptr, new_size);
; 333  : }
; 334  : 
; 335  : /*****************************************************************************
; 336  : *** Construction/destruction of array elements                             ***
; 337  : *****************************************************************************/
; 338  : 
; 339  : /** \internal Constructs the elements of an array.
; 340  :   * The \a size parameter tells on how many objects to call the constructor of T.
; 341  :   */
; 342  : template<typename T> inline T* construct_elements_of_array(T *ptr, size_t size)
; 343  : {
; 344  :   for (size_t i=0; i < size; ++i) ::new (ptr + i) T;
; 345  :   return ptr;
; 346  : }
; 347  : 
; 348  : /** \internal Destructs the elements of an array.
; 349  :   * The \a size parameters tells on how many objects to call the destructor of T.
; 350  :   */
; 351  : template<typename T> inline void destruct_elements_of_array(T *ptr, size_t size)
; 352  : {
; 353  :   // always destruct an array starting from the end.
; 354  :   if(ptr)
; 355  :     while(size) ptr[--size].~T();
; 356  : }
; 357  : 
; 358  : /*****************************************************************************
; 359  : *** Implementation of aligned new/delete-like functions                    ***
; 360  : *****************************************************************************/
; 361  : 
; 362  : template<typename T>
; 363  : EIGEN_ALWAYS_INLINE void check_size_for_overflow(size_t size)
; 364  : {
; 365  :   if(size > size_t(-1) / sizeof(T))

	cmp	rdi, r13
	jbe	SHORT $LN55@Tikhonov2D

; 366  :     throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN55@Tikhonov2D:

; 422  :   check_size_for_overflow<T>(size);
; 423  :   T *result = reinterpret_cast<T*>(conditional_aligned_malloc<Align>(sizeof(T)*size));

	lea	rbp, QWORD PTR [rdi*8]

; 220  :     result = std::malloc(size);

	mov	rcx, rbp
	call	QWORD PTR __imp_malloc

; 221  :   #elif EIGEN_HAS_POSIX_MEMALIGN
; 222  :     if(posix_memalign(&result, 16, size)) result = 0;
; 223  :   #elif EIGEN_HAS_MM_MALLOC
; 224  :     result = _mm_malloc(size, 16);
; 225  :   #elif defined(_MSC_VER) && (!defined(_WIN32_WCE))
; 226  :     result = _aligned_malloc(size, 16);
; 227  :   #else
; 228  :     result = handmade_aligned_malloc(size);
; 229  :   #endif
; 230  : 
; 231  :   if(!result && size)

	test	rax, rax
	jne	SHORT $LN53@Tikhonov2D
	test	rbp, rbp
	je	SHORT $LN53@Tikhonov2D

; 232  :     throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN53@Tikhonov2D:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 310  :     { EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN }

	mov	QWORD PTR [rbx], rax
	mov	QWORD PTR [rbx+8], rdi

; 313  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rdi, QWORD PTR [r14+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	mov	rbp, 9223372036854775807		; 7fffffffffffffffH
	test	rdi, rdi
	je	SHORT $LN977@Tikhonov2D
	cmp	rdi, rbp
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN104@Tikhonov2D

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN104@Tikhonov2D:

; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rdi, rdi
$LN977@Tikhonov2D:
	jns	SHORT $LN171@Tikhonov2D
	mov	r8d, 241				; 000000f1H
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	call	QWORD PTR __imp__wassert
$LN171@Tikhonov2D:

; 44   :                : (rows > max_index / cols);

	test	rdi, rdi
	je	SHORT $LN178@Tikhonov2D
	cmp	rdi, rbp
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN178@Tikhonov2D

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN178@Tikhonov2D:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 322  :       if(size != m_rows*_Cols)

	cmp	rdi, QWORD PTR [rbx+8]
	je	SHORT $LN183@Tikhonov2D
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR [rbx]
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 325  :         if (size)

	test	rdi, rdi
	je	SHORT $LN184@Tikhonov2D

; 326  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

	mov	rcx, rdi
	call	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
	mov	QWORD PTR [rbx], rax

; 327  :         else

	jmp	SHORT $LN183@Tikhonov2D
$LN184@Tikhonov2D:

; 328  :           m_data = 0;

	mov	QWORD PTR [rbx], r12
$LN183@Tikhonov2D:

; 329  :         EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN
; 330  :       }
; 331  :       m_rows = nbRows;

	mov	QWORD PTR [rbx+8], rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	cmp	rdi, QWORD PTR [r14+8]
	je	SHORT $LN248@Tikhonov2D
	mov	r8d, 498				; 000001f2H
	lea	rdx, OFFSET FLAT:??_C@_1KO@HDGCFKMN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GC@PBCDNLIH@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ@
	call	QWORD PTR __imp__wassert
$LN248@Tikhonov2D:

; 395  :     const Index size = dst.size();

	mov	r9, QWORD PTR [rbx+8]

; 396  :     typedef packet_traits<typename Derived1::Scalar> PacketTraits;
; 397  :     enum {
; 398  :       packetSize = PacketTraits::size,
; 399  :       dstAlignment = PacketTraits::AlignedOnScalar ? Aligned : int(assign_traits<Derived1,Derived2>::DstIsAligned) ,
; 400  :       srcAlignment = assign_traits<Derived1,Derived2>::JointAlignment
; 401  :     };
; 402  :     const Index alignedStart = assign_traits<Derived1,Derived2>::DstIsAligned ? 0
; 403  :                              : internal::first_aligned(&dst.coeffRef(0), size);
; 404  :     const Index alignedEnd = alignedStart + ((size-alignedStart)/packetSize)*packetSize;

	mov	rax, r9
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r8, rax
	add	r8, r8

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	mov	rcx, r12
	test	r8, r8
	jle	SHORT $LN285@Tikhonov2D
	npad	2
$LL287@Tikhonov2D:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 333  :     inline const T *data() const { return m_data; }

	mov	rax, QWORD PTR [r14]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 220  : template<> EIGEN_STRONG_INLINE Packet2d pload<Packet2d>(const double*  from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_pd(from); }

	movaps	xmm0, XMMWORD PTR [rax+rcx*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 334  :     inline T *data() { return m_data; }

	mov	rax, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [rax+rcx*8], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	add	rcx, 2
	cmp	rcx, r8
	jl	SHORT $LL287@Tikhonov2D
$LN285@Tikhonov2D:

; 409  :     {
; 410  :       dst.template copyPacket<Derived2, dstAlignment, srcAlignment>(index, src);
; 411  :     }
; 412  : 
; 413  :     unaligned_assign_impl<>::run(src,dst,alignedEnd,size);

	mov	rdx, rbx
	mov	rcx, r14
	call	??$run@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V12@@?$unaligned_assign_impl@$0A@@internal@Eigen@@SAXAEBV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEAV32@_J2@Z ; Eigen::internal::unaligned_assign_impl<0>::run<Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Matrix<double,-1,1,0,-1,1> >
	npad	1
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 16   : {

	lea	rbx, QWORD PTR [rsi+48]
	mov	QWORD PTR this$[rsp], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 313  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rdi, QWORD PTR [r15+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 420  :   if(size==0)

	test	rdi, rdi
	jne	SHORT $LN386@Tikhonov2D

; 421  :     return 0; // short-cut. Also fixes Bug 884

	mov	rax, r12
	jmp	SHORT $LN387@Tikhonov2D
$LN386@Tikhonov2D:

; 244  :   #elif EIGEN_HAS_POSIX_MEMALIGN
; 245  :     std::free(ptr);
; 246  :   #elif EIGEN_HAS_MM_MALLOC
; 247  :     _mm_free(ptr);
; 248  :   #elif defined(_MSC_VER) && (!defined(_WIN32_WCE))
; 249  :     _aligned_free(ptr);
; 250  :   #else
; 251  :     handmade_aligned_free(ptr);
; 252  :   #endif
; 253  : }
; 254  : 
; 255  : /**
; 256  : * \internal
; 257  : * \brief Reallocates an aligned block of memory.
; 258  : * \throws std::bad_alloc on allocation failure
; 259  : **/
; 260  : inline void* aligned_realloc(void *ptr, size_t new_size, size_t old_size)
; 261  : {
; 262  :   EIGEN_UNUSED_VARIABLE(old_size);
; 263  : 
; 264  :   void *result;
; 265  : #if !EIGEN_ALIGN
; 266  :   result = std::realloc(ptr,new_size);
; 267  : #elif EIGEN_MALLOC_ALREADY_ALIGNED
; 268  :   result = std::realloc(ptr,new_size);
; 269  : #elif EIGEN_HAS_POSIX_MEMALIGN
; 270  :   result = generic_aligned_realloc(ptr,new_size,old_size);
; 271  : #elif EIGEN_HAS_MM_MALLOC
; 272  :   // The defined(_mm_free) is just here to verify that this MSVC version
; 273  :   // implements _mm_malloc/_mm_free based on the corresponding _aligned_
; 274  :   // functions. This may not always be the case and we just try to be safe.
; 275  :   #if defined(_MSC_VER) && (!defined(_WIN32_WCE)) && defined(_mm_free)
; 276  :     result = _aligned_realloc(ptr,new_size,16);
; 277  :   #else
; 278  :     result = generic_aligned_realloc(ptr,new_size,old_size);
; 279  :   #endif
; 280  : #elif defined(_MSC_VER) && (!defined(_WIN32_WCE))
; 281  :   result = _aligned_realloc(ptr,new_size,16);
; 282  : #else
; 283  :   result = handmade_aligned_realloc(ptr,new_size,old_size);
; 284  : #endif
; 285  : 
; 286  :   if (!result && new_size)
; 287  :     throw_std_bad_alloc();
; 288  : 
; 289  :   return result;
; 290  : }
; 291  : 
; 292  : /*****************************************************************************
; 293  : *** Implementation of conditionally aligned functions                      ***
; 294  : *****************************************************************************/
; 295  : 
; 296  : /** \internal Allocates \a size bytes. If Align is true, then the returned ptr is 16-byte-aligned.
; 297  :   * On allocation error, the returned pointer is null, and a std::bad_alloc is thrown.
; 298  :   */
; 299  : template<bool Align> inline void* conditional_aligned_malloc(size_t size)
; 300  : {
; 301  :   return aligned_malloc(size);
; 302  : }
; 303  : 
; 304  : template<> inline void* conditional_aligned_malloc<false>(size_t size)
; 305  : {
; 306  :   check_that_malloc_is_allowed();
; 307  : 
; 308  :   void *result = std::malloc(size);
; 309  :   if(!result && size)
; 310  :     throw_std_bad_alloc();
; 311  :   return result;
; 312  : }
; 313  : 
; 314  : /** \internal Frees memory allocated with conditional_aligned_malloc */
; 315  : template<bool Align> inline void conditional_aligned_free(void *ptr)
; 316  : {
; 317  :   aligned_free(ptr);
; 318  : }
; 319  : 
; 320  : template<> inline void conditional_aligned_free<false>(void *ptr)
; 321  : {
; 322  :   std::free(ptr);
; 323  : }
; 324  : 
; 325  : template<bool Align> inline void* conditional_aligned_realloc(void* ptr, size_t new_size, size_t old_size)
; 326  : {
; 327  :   return aligned_realloc(ptr, new_size, old_size);
; 328  : }
; 329  : 
; 330  : template<> inline void* conditional_aligned_realloc<false>(void* ptr, size_t new_size, size_t)
; 331  : {
; 332  :   return std::realloc(ptr, new_size);
; 333  : }
; 334  : 
; 335  : /*****************************************************************************
; 336  : *** Construction/destruction of array elements                             ***
; 337  : *****************************************************************************/
; 338  : 
; 339  : /** \internal Constructs the elements of an array.
; 340  :   * The \a size parameter tells on how many objects to call the constructor of T.
; 341  :   */
; 342  : template<typename T> inline T* construct_elements_of_array(T *ptr, size_t size)
; 343  : {
; 344  :   for (size_t i=0; i < size; ++i) ::new (ptr + i) T;
; 345  :   return ptr;
; 346  : }
; 347  : 
; 348  : /** \internal Destructs the elements of an array.
; 349  :   * The \a size parameters tells on how many objects to call the destructor of T.
; 350  :   */
; 351  : template<typename T> inline void destruct_elements_of_array(T *ptr, size_t size)
; 352  : {
; 353  :   // always destruct an array starting from the end.
; 354  :   if(ptr)
; 355  :     while(size) ptr[--size].~T();
; 356  : }
; 357  : 
; 358  : /*****************************************************************************
; 359  : *** Implementation of aligned new/delete-like functions                    ***
; 360  : *****************************************************************************/
; 361  : 
; 362  : template<typename T>
; 363  : EIGEN_ALWAYS_INLINE void check_size_for_overflow(size_t size)
; 364  : {
; 365  :   if(size > size_t(-1) / sizeof(T))

	cmp	rdi, r13
	jbe	SHORT $LN389@Tikhonov2D

; 366  :     throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN389@Tikhonov2D:

; 422  :   check_size_for_overflow<T>(size);
; 423  :   T *result = reinterpret_cast<T*>(conditional_aligned_malloc<Align>(sizeof(T)*size));

	lea	rbp, QWORD PTR [rdi*8]

; 220  :     result = std::malloc(size);

	mov	rcx, rbp
	call	QWORD PTR __imp_malloc

; 221  :   #elif EIGEN_HAS_POSIX_MEMALIGN
; 222  :     if(posix_memalign(&result, 16, size)) result = 0;
; 223  :   #elif EIGEN_HAS_MM_MALLOC
; 224  :     result = _mm_malloc(size, 16);
; 225  :   #elif defined(_MSC_VER) && (!defined(_WIN32_WCE))
; 226  :     result = _aligned_malloc(size, 16);
; 227  :   #else
; 228  :     result = handmade_aligned_malloc(size);
; 229  :   #endif
; 230  : 
; 231  :   if(!result && size)

	test	rax, rax
	jne	SHORT $LN395@Tikhonov2D
	test	rbp, rbp
	je	SHORT $LN395@Tikhonov2D

; 232  :     throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN395@Tikhonov2D:
	mov	rbp, 9223372036854775807		; 7fffffffffffffffH
$LN387@Tikhonov2D:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 310  :     { EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN }

	mov	QWORD PTR [rbx], rax
	mov	QWORD PTR [rbx+8], rdi

; 313  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rdi, QWORD PTR [r15+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	test	rdi, rdi
	je	SHORT $LN979@Tikhonov2D
	cmp	rdi, rbp
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN438@Tikhonov2D

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN438@Tikhonov2D:

; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rdi, rdi
$LN979@Tikhonov2D:
	jns	SHORT $LN505@Tikhonov2D
	mov	r8d, 241				; 000000f1H
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	call	QWORD PTR __imp__wassert
$LN505@Tikhonov2D:

; 44   :                : (rows > max_index / cols);

	test	rdi, rdi
	je	SHORT $LN512@Tikhonov2D
	cmp	rdi, rbp
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN512@Tikhonov2D

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN512@Tikhonov2D:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 322  :       if(size != m_rows*_Cols)

	cmp	rdi, QWORD PTR [rbx+8]
	je	SHORT $LN517@Tikhonov2D
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR [rbx]
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 325  :         if (size)

	test	rdi, rdi
	je	SHORT $LN518@Tikhonov2D

; 326  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

	mov	rcx, rdi
	call	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
	mov	QWORD PTR [rbx], rax

; 327  :         else

	jmp	SHORT $LN517@Tikhonov2D
$LN518@Tikhonov2D:

; 328  :           m_data = 0;

	mov	QWORD PTR [rbx], r12
$LN517@Tikhonov2D:

; 329  :         EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN
; 330  :       }
; 331  :       m_rows = nbRows;

	mov	QWORD PTR [rbx+8], rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	cmp	rdi, QWORD PTR [r15+8]
	je	SHORT $LN582@Tikhonov2D
	mov	r8d, 498				; 000001f2H
	lea	rdx, OFFSET FLAT:??_C@_1KO@HDGCFKMN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GC@PBCDNLIH@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ@
	call	QWORD PTR __imp__wassert
$LN582@Tikhonov2D:

; 395  :     const Index size = dst.size();

	mov	r9, QWORD PTR [rbx+8]

; 396  :     typedef packet_traits<typename Derived1::Scalar> PacketTraits;
; 397  :     enum {
; 398  :       packetSize = PacketTraits::size,
; 399  :       dstAlignment = PacketTraits::AlignedOnScalar ? Aligned : int(assign_traits<Derived1,Derived2>::DstIsAligned) ,
; 400  :       srcAlignment = assign_traits<Derived1,Derived2>::JointAlignment
; 401  :     };
; 402  :     const Index alignedStart = assign_traits<Derived1,Derived2>::DstIsAligned ? 0
; 403  :                              : internal::first_aligned(&dst.coeffRef(0), size);
; 404  :     const Index alignedEnd = alignedStart + ((size-alignedStart)/packetSize)*packetSize;

	mov	rax, r9
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r8, rax
	add	r8, r8

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	mov	rcx, r12
	test	r8, r8
	jle	SHORT $LN619@Tikhonov2D
	npad	7
$LL621@Tikhonov2D:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 333  :     inline const T *data() const { return m_data; }

	mov	rax, QWORD PTR [r15]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 220  : template<> EIGEN_STRONG_INLINE Packet2d pload<Packet2d>(const double*  from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_pd(from); }

	movaps	xmm0, XMMWORD PTR [rax+rcx*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 334  :     inline T *data() { return m_data; }

	mov	rax, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [rax+rcx*8], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	add	rcx, 2
	cmp	rcx, r8
	jl	SHORT $LL621@Tikhonov2D
$LN619@Tikhonov2D:

; 409  :     {
; 410  :       dst.template copyPacket<Derived2, dstAlignment, srcAlignment>(index, src);
; 411  :     }
; 412  : 
; 413  :     unaligned_assign_impl<>::run(src,dst,alignedEnd,size);

	mov	rdx, rbx
	mov	rcx, r15
	call	??$run@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V12@@?$unaligned_assign_impl@$0A@@internal@Eigen@@SAXAEBV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEAV32@_J2@Z ; Eigen::internal::unaligned_assign_impl<0>::run<Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Matrix<double,-1,1,0,-1,1> >
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 307  :     inline DenseStorage() : m_data(0), m_rows(0) {}

	xor	edx, edx
	mov	QWORD PTR [rsi+64], rdx
	mov	QWORD PTR [rsi+72], rdx

; 230  :     inline DenseStorage() : m_data(0), m_rows(0), m_cols(0) {}

	mov	QWORD PTR [rsi+80], rdx
	mov	QWORD PTR [rsi+88], rdx
	mov	QWORD PTR [rsi+96], rdx
	mov	QWORD PTR [rsi+104], rdx
	mov	QWORD PTR [rsi+112], rdx
	mov	QWORD PTR [rsi+120], rdx
	mov	QWORD PTR [rsi+128], rdx
	mov	QWORD PTR [rsi+136], rdx
	mov	QWORD PTR [rsi+144], rdx
	mov	QWORD PTR [rsi+152], rdx
	mov	QWORD PTR [rsi+160], rdx
	mov	QWORD PTR [rsi+168], rdx
	mov	QWORD PTR [rsi+176], rdx
	mov	QWORD PTR [rsi+184], rdx
	mov	QWORD PTR [rsi+192], rdx
	mov	QWORD PTR [rsi+200], rdx
	mov	QWORD PTR [rsi+208], rdx
	mov	QWORD PTR [rsi+216], rdx

; 307  :     inline DenseStorage() : m_data(0), m_rows(0) {}

	mov	QWORD PTR [rsi+224], rdx
	mov	QWORD PTR [rsi+232], rdx
	mov	QWORD PTR [rsi+240], rdx
	mov	QWORD PTR [rsi+248], rdx
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 16   : {

	lea	rcx, QWORD PTR [rsi+256]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 307  :     inline DenseStorage() : m_data(0), m_rows(0) {}

	mov	QWORD PTR [rcx], rdx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rsi+272], rdx
	mov	QWORD PTR [rsi+280], rdx
	mov	QWORD PTR [rsi+288], rdx
	mov	QWORD PTR [rsi+296], rdx

; 230  :     inline DenseStorage() : m_data(0), m_rows(0), m_cols(0) {}

	mov	QWORD PTR [rsi+304], rdx
	mov	QWORD PTR [rsi+312], rdx
	mov	QWORD PTR [rsi+320], rdx
	mov	QWORD PTR [rsi+328], rdx
	mov	QWORD PTR [rsi+336], rdx
	mov	QWORD PTR [rsi+344], rdx
	mov	QWORD PTR [rsi+352], rdx
	mov	QWORD PTR [rsi+360], rdx
	mov	QWORD PTR [rsi+368], rdx
	mov	QWORD PTR [rsi+376], rdx
	mov	QWORD PTR [rsi+384], rdx
	mov	QWORD PTR [rsi+392], rdx

; 307  :     inline DenseStorage() : m_data(0), m_rows(0) {}

	mov	QWORD PTR [rsi+400], rdx
	mov	QWORD PTR [rsi+408], rdx
	mov	QWORD PTR [rsi+416], rdx
	mov	QWORD PTR [rsi+424], rdx
	mov	QWORD PTR [rsi+432], rdx
	mov	QWORD PTR [rsi+440], rdx
	mov	QWORD PTR [rsi+448], rdx
	mov	QWORD PTR [rsi+456], rdx
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 17   : 	J.resize(size_j * 2);	//	first size_j for f and the rest for v

	mov	rdx, QWORD PTR [rsi+8]
	add	rdx, rdx
	call	?resize@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAX_J@Z ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,1,0,-1,1> >::resize

; 18   : 	Jf.resize(size_j);

	mov	rdx, QWORD PTR [rsi+8]
	lea	rcx, QWORD PTR [rsi+272]
	call	?resize@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAX_J@Z ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,1,0,-1,1> >::resize

; 19   : 	Jv.resize(size_j);

	mov	rdx, QWORD PTR [rsi+8]
	lea	rcx, QWORD PTR [rsi+288]
	call	?resize@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAX_J@Z ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,1,0,-1,1> >::resize

; 20   : 	H.resize(size_j * 2, size_j * 2);

	mov	rbx, QWORD PTR [rsi+8]
	add	rbx, rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	js	SHORT $LN856@Tikhonov2D
	test	rbx, rbx
	jns	SHORT $LN981@Tikhonov2D
$LN856@Tikhonov2D:
	mov	r8d, 241				; 000000f1H
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	call	QWORD PTR __imp__wassert

; 44   :                : (rows > max_index / cols);

	test	rbx, rbx
$LN981@Tikhonov2D:
	mov	rdi, 9223372036854775807		; 7fffffffffffffffH
	je	SHORT $LN864@Tikhonov2D
	test	rbx, rbx
	je	SHORT $LN864@Tikhonov2D
	mov	rax, rdi
	cdq
	idiv	rbx
	cmp	rbx, rax
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN858@Tikhonov2D

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN858@Tikhonov2D:

; 44   :                : (rows > max_index / cols);

	test	rbx, rbx
	je	SHORT $LN864@Tikhonov2D
	mov	rax, rdi
	cdq
	idiv	rbx
	cmp	rbx, rax
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN864@Tikhonov2D

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN864@Tikhonov2D:

; 238  :                    && EIGEN_IMPLIES(ColsAtCompileTime!=Dynamic,nbCols==ColsAtCompileTime)
; 239  :                    && EIGEN_IMPLIES(RowsAtCompileTime==Dynamic && MaxRowsAtCompileTime!=Dynamic,nbRows<=MaxRowsAtCompileTime)
; 240  :                    && EIGEN_IMPLIES(ColsAtCompileTime==Dynamic && MaxColsAtCompileTime!=Dynamic,nbCols<=MaxColsAtCompileTime)
; 241  :                    && nbRows>=0 && nbCols>=0 && "Invalid sizes when resizing a matrix or array.");
; 242  :       internal::check_rows_cols_for_overflow<MaxSizeAtCompileTime>::run(nbRows, nbCols);
; 243  :       #ifdef EIGEN_INITIALIZE_COEFFS
; 244  :         Index size = nbRows*nbCols;
; 245  :         bool size_changed = size != this->size();
; 246  :         m_storage.resize(size, nbRows, nbCols);
; 247  :         if(size_changed) EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED
; 248  :       #else
; 249  :         internal::check_rows_cols_for_overflow<MaxSizeAtCompileTime>::run(nbRows, nbCols);
; 250  :         m_storage.resize(nbRows*nbCols, nbRows, nbCols);

	mov	rdx, rbx
	imul	rdx, rbx
	mov	r9, rbx
	mov	r8, rbx
	lea	rcx, QWORD PTR [rsi+304]
	call	?resize@?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAAX_J00@Z ; Eigen::DenseStorage<double,-1,-1,-1,0>::resize
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 21   : 	Hff.resize(size_j, size_j);

	mov	rbx, QWORD PTR [rsi+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rbx, rbx
	jns	SHORT $LN982@Tikhonov2D
	mov	r8d, 241				; 000000f1H
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	call	QWORD PTR __imp__wassert

; 44   :                : (rows > max_index / cols);

	test	rbx, rbx
$LN982@Tikhonov2D:
	je	SHORT $LN879@Tikhonov2D
	test	rbx, rbx
	je	SHORT $LN879@Tikhonov2D
	mov	rax, rdi
	cdq
	idiv	rbx
	cmp	rbx, rax
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN873@Tikhonov2D

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN873@Tikhonov2D:

; 44   :                : (rows > max_index / cols);

	test	rbx, rbx
	je	SHORT $LN879@Tikhonov2D
	mov	rax, rdi
	cdq
	idiv	rbx
	cmp	rbx, rax
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN879@Tikhonov2D

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN879@Tikhonov2D:

; 238  :                    && EIGEN_IMPLIES(ColsAtCompileTime!=Dynamic,nbCols==ColsAtCompileTime)
; 239  :                    && EIGEN_IMPLIES(RowsAtCompileTime==Dynamic && MaxRowsAtCompileTime!=Dynamic,nbRows<=MaxRowsAtCompileTime)
; 240  :                    && EIGEN_IMPLIES(ColsAtCompileTime==Dynamic && MaxColsAtCompileTime!=Dynamic,nbCols<=MaxColsAtCompileTime)
; 241  :                    && nbRows>=0 && nbCols>=0 && "Invalid sizes when resizing a matrix or array.");
; 242  :       internal::check_rows_cols_for_overflow<MaxSizeAtCompileTime>::run(nbRows, nbCols);
; 243  :       #ifdef EIGEN_INITIALIZE_COEFFS
; 244  :         Index size = nbRows*nbCols;
; 245  :         bool size_changed = size != this->size();
; 246  :         m_storage.resize(size, nbRows, nbCols);
; 247  :         if(size_changed) EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED
; 248  :       #else
; 249  :         internal::check_rows_cols_for_overflow<MaxSizeAtCompileTime>::run(nbRows, nbCols);
; 250  :         m_storage.resize(nbRows*nbCols, nbRows, nbCols);

	mov	rdx, rbx
	imul	rdx, rbx
	mov	r9, rbx
	mov	r8, rbx
	lea	rcx, QWORD PTR [rsi+328]
	call	?resize@?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAAX_J00@Z ; Eigen::DenseStorage<double,-1,-1,-1,0>::resize
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 22   : 	Hvf.resize(size_j, size_j);

	mov	rbx, QWORD PTR [rsi+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rbx, rbx
	jns	SHORT $LN984@Tikhonov2D
	mov	r8d, 241				; 000000f1H
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	call	QWORD PTR __imp__wassert

; 44   :                : (rows > max_index / cols);

	test	rbx, rbx
$LN984@Tikhonov2D:
	je	SHORT $LN894@Tikhonov2D
	test	rbx, rbx
	je	SHORT $LN894@Tikhonov2D
	mov	rax, rdi
	cdq
	idiv	rbx
	cmp	rbx, rax
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN888@Tikhonov2D

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN888@Tikhonov2D:

; 44   :                : (rows > max_index / cols);

	test	rbx, rbx
	je	SHORT $LN894@Tikhonov2D
	mov	rax, rdi
	cdq
	idiv	rbx
	cmp	rbx, rax
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN894@Tikhonov2D

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN894@Tikhonov2D:

; 238  :                    && EIGEN_IMPLIES(ColsAtCompileTime!=Dynamic,nbCols==ColsAtCompileTime)
; 239  :                    && EIGEN_IMPLIES(RowsAtCompileTime==Dynamic && MaxRowsAtCompileTime!=Dynamic,nbRows<=MaxRowsAtCompileTime)
; 240  :                    && EIGEN_IMPLIES(ColsAtCompileTime==Dynamic && MaxColsAtCompileTime!=Dynamic,nbCols<=MaxColsAtCompileTime)
; 241  :                    && nbRows>=0 && nbCols>=0 && "Invalid sizes when resizing a matrix or array.");
; 242  :       internal::check_rows_cols_for_overflow<MaxSizeAtCompileTime>::run(nbRows, nbCols);
; 243  :       #ifdef EIGEN_INITIALIZE_COEFFS
; 244  :         Index size = nbRows*nbCols;
; 245  :         bool size_changed = size != this->size();
; 246  :         m_storage.resize(size, nbRows, nbCols);
; 247  :         if(size_changed) EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED
; 248  :       #else
; 249  :         internal::check_rows_cols_for_overflow<MaxSizeAtCompileTime>::run(nbRows, nbCols);
; 250  :         m_storage.resize(nbRows*nbCols, nbRows, nbCols);

	mov	rdx, rbx
	imul	rdx, rbx
	mov	r9, rbx
	mov	r8, rbx
	lea	rcx, QWORD PTR [rsi+376]
	call	?resize@?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAAX_J00@Z ; Eigen::DenseStorage<double,-1,-1,-1,0>::resize
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 23   : 	Hvv.resize(size_j, size_j);

	mov	rbx, QWORD PTR [rsi+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rbx, rbx
	jns	SHORT $LN986@Tikhonov2D
	mov	r8d, 241				; 000000f1H
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	call	QWORD PTR __imp__wassert

; 44   :                : (rows > max_index / cols);

	test	rbx, rbx
$LN986@Tikhonov2D:
	je	SHORT $LN909@Tikhonov2D
	test	rbx, rbx
	je	SHORT $LN909@Tikhonov2D
	mov	rax, rdi
	cdq
	idiv	rbx
	cmp	rbx, rax
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN903@Tikhonov2D

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN903@Tikhonov2D:

; 44   :                : (rows > max_index / cols);

	test	rbx, rbx
	je	SHORT $LN909@Tikhonov2D
	mov	rax, rdi
	cdq
	idiv	rbx
	cmp	rbx, rax
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN909@Tikhonov2D

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN909@Tikhonov2D:

; 238  :                    && EIGEN_IMPLIES(ColsAtCompileTime!=Dynamic,nbCols==ColsAtCompileTime)
; 239  :                    && EIGEN_IMPLIES(RowsAtCompileTime==Dynamic && MaxRowsAtCompileTime!=Dynamic,nbRows<=MaxRowsAtCompileTime)
; 240  :                    && EIGEN_IMPLIES(ColsAtCompileTime==Dynamic && MaxColsAtCompileTime!=Dynamic,nbCols<=MaxColsAtCompileTime)
; 241  :                    && nbRows>=0 && nbCols>=0 && "Invalid sizes when resizing a matrix or array.");
; 242  :       internal::check_rows_cols_for_overflow<MaxSizeAtCompileTime>::run(nbRows, nbCols);
; 243  :       #ifdef EIGEN_INITIALIZE_COEFFS
; 244  :         Index size = nbRows*nbCols;
; 245  :         bool size_changed = size != this->size();
; 246  :         m_storage.resize(size, nbRows, nbCols);
; 247  :         if(size_changed) EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED
; 248  :       #else
; 249  :         internal::check_rows_cols_for_overflow<MaxSizeAtCompileTime>::run(nbRows, nbCols);
; 250  :         m_storage.resize(nbRows*nbCols, nbRows, nbCols);

	mov	rdx, rbx
	imul	rdx, rbx
	mov	r9, rbx
	mov	r8, rbx
	lea	rcx, QWORD PTR [rsi+352]
	call	?resize@?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAAX_J00@Z ; Eigen::DenseStorage<double,-1,-1,-1,0>::resize
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 24   : 	Aij.resize(size_i, size_j);

	mov	rbx, QWORD PTR [rsi+8]
	mov	rdi, QWORD PTR [rsi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rdi, rdi
	js	SHORT $LN916@Tikhonov2D
	test	rbx, rbx
	jns	SHORT $LN917@Tikhonov2D
$LN916@Tikhonov2D:
	mov	r8d, 241				; 000000f1H
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	call	QWORD PTR __imp__wassert
$LN917@Tikhonov2D:

; 44   :                : (rows > max_index / cols);

	test	rdi, rdi
	je	SHORT $LN924@Tikhonov2D
	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	test	rbx, rbx
	je	SHORT $LN924@Tikhonov2D
	mov	rax, rcx
	cdq
	idiv	rbx
	cmp	rdi, rax
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN918@Tikhonov2D

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN918@Tikhonov2D:

; 44   :                : (rows > max_index / cols);

	test	rbx, rbx
	je	SHORT $LN924@Tikhonov2D
	mov	rax, rcx
	cdq
	idiv	rbx
	cmp	rdi, rax
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN924@Tikhonov2D

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN924@Tikhonov2D:

; 238  :                    && EIGEN_IMPLIES(ColsAtCompileTime!=Dynamic,nbCols==ColsAtCompileTime)
; 239  :                    && EIGEN_IMPLIES(RowsAtCompileTime==Dynamic && MaxRowsAtCompileTime!=Dynamic,nbRows<=MaxRowsAtCompileTime)
; 240  :                    && EIGEN_IMPLIES(ColsAtCompileTime==Dynamic && MaxColsAtCompileTime!=Dynamic,nbCols<=MaxColsAtCompileTime)
; 241  :                    && nbRows>=0 && nbCols>=0 && "Invalid sizes when resizing a matrix or array.");
; 242  :       internal::check_rows_cols_for_overflow<MaxSizeAtCompileTime>::run(nbRows, nbCols);
; 243  :       #ifdef EIGEN_INITIALIZE_COEFFS
; 244  :         Index size = nbRows*nbCols;
; 245  :         bool size_changed = size != this->size();
; 246  :         m_storage.resize(size, nbRows, nbCols);
; 247  :         if(size_changed) EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED
; 248  :       #else
; 249  :         internal::check_rows_cols_for_overflow<MaxSizeAtCompileTime>::run(nbRows, nbCols);
; 250  :         m_storage.resize(nbRows*nbCols, nbRows, nbCols);

	mov	rdx, rdi
	imul	rdx, rbx
	mov	r9, rbx
	mov	r8, rdi
	lea	rcx, QWORD PTR [rsi+104]
	call	?resize@?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAAX_J00@Z ; Eigen::DenseStorage<double,-1,-1,-1,0>::resize
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR [r14]
	call	QWORD PTR __imp_free
	npad	1
	mov	rcx, QWORD PTR [r15]
	call	QWORD PTR __imp_free
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 25   : }

	mov	rax, rsi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+96]
	mov	rbx, QWORD PTR [r11+56]
	mov	rbp, QWORD PTR [r11+64]
	mov	rsi, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
$LN976@Tikhonov2D:
??0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z ENDP ; Tikhonov2D::Tikhonov2D
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 32
this$ = 32
this$GSCopy$ = 48
wavelength_$GSCopy$ = 72
width_$GSCopy$ = 80
__$ArrayPad$ = 88
this$ = 144
size_i_$ = 152
size_j_$ = 160
vlight_$ = 168
lambda0_$ = 176
wavelength_$ = 184
width_$ = 192
?dtor$0@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA PROC ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$0
	mov	rcx, QWORD PTR width_$GSCopy$[rdx]
	jmp	??1?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@XZ
?dtor$0@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA ENDP ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 32
this$ = 32
this$GSCopy$ = 48
wavelength_$GSCopy$ = 72
width_$GSCopy$ = 80
__$ArrayPad$ = 88
this$ = 144
size_i_$ = 152
size_j_$ = 160
vlight_$ = 168
lambda0_$ = 176
wavelength_$ = 184
width_$ = 192
?dtor$1@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA PROC ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$1
	mov	rcx, QWORD PTR wavelength_$GSCopy$[rdx]
	jmp	??1?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@XZ
?dtor$1@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA ENDP ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 32
this$ = 32
this$GSCopy$ = 48
wavelength_$GSCopy$ = 72
width_$GSCopy$ = 80
__$ArrayPad$ = 88
this$ = 144
size_i_$ = 152
size_j_$ = 160
vlight_$ = 168
lambda0_$ = 176
wavelength_$ = 184
width_$ = 192
?dtor$24@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA PROC ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$24
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAA@XZ
?dtor$24@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA ENDP ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$24
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 32
this$ = 32
this$GSCopy$ = 48
wavelength_$GSCopy$ = 72
width_$GSCopy$ = 80
__$ArrayPad$ = 88
this$ = 144
size_i_$ = 152
size_j_$ = 160
vlight_$ = 168
lambda0_$ = 176
wavelength_$ = 184
width_$ = 192
?dtor$2@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA PROC ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$2
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 32					; 00000020H
	jmp	??1?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@XZ
?dtor$2@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA ENDP ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 32
this$ = 32
this$GSCopy$ = 48
wavelength_$GSCopy$ = 72
width_$GSCopy$ = 80
__$ArrayPad$ = 88
this$ = 144
size_i_$ = 152
size_j_$ = 160
vlight_$ = 168
lambda0_$ = 176
wavelength_$ = 184
width_$ = 192
?dtor$26@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA PROC ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$26
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAA@XZ
?dtor$26@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA ENDP ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$26
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 32
this$ = 32
this$GSCopy$ = 48
wavelength_$GSCopy$ = 72
width_$GSCopy$ = 80
__$ArrayPad$ = 88
this$ = 144
size_i_$ = 152
size_j_$ = 160
vlight_$ = 168
lambda0_$ = 176
wavelength_$ = 184
width_$ = 192
?dtor$3@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA PROC ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$3
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 48					; 00000030H
	jmp	??1?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@XZ
?dtor$3@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA ENDP ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 32
this$ = 32
this$GSCopy$ = 48
wavelength_$GSCopy$ = 72
width_$GSCopy$ = 80
__$ArrayPad$ = 88
this$ = 144
size_i_$ = 152
size_j_$ = 160
vlight_$ = 168
lambda0_$ = 176
wavelength_$ = 184
width_$ = 192
?dtor$4@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA PROC ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$4
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 64					; 00000040H
	jmp	??1?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@XZ
?dtor$4@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA ENDP ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 32
this$ = 32
this$GSCopy$ = 48
wavelength_$GSCopy$ = 72
width_$GSCopy$ = 80
__$ArrayPad$ = 88
this$ = 144
size_i_$ = 152
size_j_$ = 160
vlight_$ = 168
lambda0_$ = 176
wavelength_$ = 184
width_$ = 192
?dtor$5@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA PROC ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$5
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 80					; 00000050H
	jmp	??1?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@XZ
?dtor$5@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA ENDP ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 32
this$ = 32
this$GSCopy$ = 48
wavelength_$GSCopy$ = 72
width_$GSCopy$ = 80
__$ArrayPad$ = 88
this$ = 144
size_i_$ = 152
size_j_$ = 160
vlight_$ = 168
lambda0_$ = 176
wavelength_$ = 184
width_$ = 192
?dtor$6@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA PROC ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$6
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 104				; 00000068H
	jmp	??1?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@XZ
?dtor$6@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA ENDP ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 32
this$ = 32
this$GSCopy$ = 48
wavelength_$GSCopy$ = 72
width_$GSCopy$ = 80
__$ArrayPad$ = 88
this$ = 144
size_i_$ = 152
size_j_$ = 160
vlight_$ = 168
lambda0_$ = 176
wavelength_$ = 184
width_$ = 192
?dtor$7@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA PROC ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$7
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 128				; 00000080H
	jmp	??1?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@XZ
?dtor$7@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA ENDP ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 32
this$ = 32
this$GSCopy$ = 48
wavelength_$GSCopy$ = 72
width_$GSCopy$ = 80
__$ArrayPad$ = 88
this$ = 144
size_i_$ = 152
size_j_$ = 160
vlight_$ = 168
lambda0_$ = 176
wavelength_$ = 184
width_$ = 192
?dtor$8@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA PROC ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$8
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 152				; 00000098H
	jmp	??1?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@XZ
?dtor$8@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA ENDP ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 32
this$ = 32
this$GSCopy$ = 48
wavelength_$GSCopy$ = 72
width_$GSCopy$ = 80
__$ArrayPad$ = 88
this$ = 144
size_i_$ = 152
size_j_$ = 160
vlight_$ = 168
lambda0_$ = 176
wavelength_$ = 184
width_$ = 192
?dtor$9@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA PROC ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$9
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 176				; 000000b0H
	jmp	??1?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@XZ
?dtor$9@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA ENDP ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 32
this$ = 32
this$GSCopy$ = 48
wavelength_$GSCopy$ = 72
width_$GSCopy$ = 80
__$ArrayPad$ = 88
this$ = 144
size_i_$ = 152
size_j_$ = 160
vlight_$ = 168
lambda0_$ = 176
wavelength_$ = 184
width_$ = 192
?dtor$10@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA PROC ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$10
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 200				; 000000c8H
	jmp	??1?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@XZ
?dtor$10@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA ENDP ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$10
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 32
this$ = 32
this$GSCopy$ = 48
wavelength_$GSCopy$ = 72
width_$GSCopy$ = 80
__$ArrayPad$ = 88
this$ = 144
size_i_$ = 152
size_j_$ = 160
vlight_$ = 168
lambda0_$ = 176
wavelength_$ = 184
width_$ = 192
?dtor$11@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA PROC ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$11
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 224				; 000000e0H
	jmp	??1?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@XZ
?dtor$11@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA ENDP ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 32
this$ = 32
this$GSCopy$ = 48
wavelength_$GSCopy$ = 72
width_$GSCopy$ = 80
__$ArrayPad$ = 88
this$ = 144
size_i_$ = 152
size_j_$ = 160
vlight_$ = 168
lambda0_$ = 176
wavelength_$ = 184
width_$ = 192
?dtor$12@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA PROC ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$12
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 240				; 000000f0H
	jmp	??1?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@XZ
?dtor$12@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA ENDP ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$12
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 32
this$ = 32
this$GSCopy$ = 48
wavelength_$GSCopy$ = 72
width_$GSCopy$ = 80
__$ArrayPad$ = 88
this$ = 144
size_i_$ = 152
size_j_$ = 160
vlight_$ = 168
lambda0_$ = 176
wavelength_$ = 184
width_$ = 192
?dtor$13@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA PROC ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$13
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 256				; 00000100H
	jmp	??1?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@XZ
?dtor$13@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA ENDP ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$13
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 32
this$ = 32
this$GSCopy$ = 48
wavelength_$GSCopy$ = 72
width_$GSCopy$ = 80
__$ArrayPad$ = 88
this$ = 144
size_i_$ = 152
size_j_$ = 160
vlight_$ = 168
lambda0_$ = 176
wavelength_$ = 184
width_$ = 192
?dtor$14@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA PROC ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$14
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 272				; 00000110H
	jmp	??1?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@XZ
?dtor$14@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA ENDP ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$14
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 32
this$ = 32
this$GSCopy$ = 48
wavelength_$GSCopy$ = 72
width_$GSCopy$ = 80
__$ArrayPad$ = 88
this$ = 144
size_i_$ = 152
size_j_$ = 160
vlight_$ = 168
lambda0_$ = 176
wavelength_$ = 184
width_$ = 192
?dtor$15@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA PROC ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$15
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 288				; 00000120H
	jmp	??1?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@XZ
?dtor$15@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA ENDP ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$15
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 32
this$ = 32
this$GSCopy$ = 48
wavelength_$GSCopy$ = 72
width_$GSCopy$ = 80
__$ArrayPad$ = 88
this$ = 144
size_i_$ = 152
size_j_$ = 160
vlight_$ = 168
lambda0_$ = 176
wavelength_$ = 184
width_$ = 192
?dtor$16@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA PROC ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$16
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 304				; 00000130H
	jmp	??1?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@XZ
?dtor$16@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA ENDP ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$16
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 32
this$ = 32
this$GSCopy$ = 48
wavelength_$GSCopy$ = 72
width_$GSCopy$ = 80
__$ArrayPad$ = 88
this$ = 144
size_i_$ = 152
size_j_$ = 160
vlight_$ = 168
lambda0_$ = 176
wavelength_$ = 184
width_$ = 192
?dtor$17@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA PROC ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$17
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 328				; 00000148H
	jmp	??1?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@XZ
?dtor$17@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA ENDP ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$17
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 32
this$ = 32
this$GSCopy$ = 48
wavelength_$GSCopy$ = 72
width_$GSCopy$ = 80
__$ArrayPad$ = 88
this$ = 144
size_i_$ = 152
size_j_$ = 160
vlight_$ = 168
lambda0_$ = 176
wavelength_$ = 184
width_$ = 192
?dtor$18@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA PROC ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$18
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 352				; 00000160H
	jmp	??1?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@XZ
?dtor$18@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA ENDP ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$18
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 32
this$ = 32
this$GSCopy$ = 48
wavelength_$GSCopy$ = 72
width_$GSCopy$ = 80
__$ArrayPad$ = 88
this$ = 144
size_i_$ = 152
size_j_$ = 160
vlight_$ = 168
lambda0_$ = 176
wavelength_$ = 184
width_$ = 192
?dtor$19@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA PROC ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$19
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 376				; 00000178H
	jmp	??1?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@XZ
?dtor$19@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA ENDP ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$19
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 32
this$ = 32
this$GSCopy$ = 48
wavelength_$GSCopy$ = 72
width_$GSCopy$ = 80
__$ArrayPad$ = 88
this$ = 144
size_i_$ = 152
size_j_$ = 160
vlight_$ = 168
lambda0_$ = 176
wavelength_$ = 184
width_$ = 192
?dtor$20@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA PROC ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$20
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 400				; 00000190H
	jmp	??1?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@XZ
?dtor$20@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA ENDP ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$20
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 32
this$ = 32
this$GSCopy$ = 48
wavelength_$GSCopy$ = 72
width_$GSCopy$ = 80
__$ArrayPad$ = 88
this$ = 144
size_i_$ = 152
size_j_$ = 160
vlight_$ = 168
lambda0_$ = 176
wavelength_$ = 184
width_$ = 192
?dtor$21@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA PROC ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$21
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 416				; 000001a0H
	jmp	??1?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@XZ
?dtor$21@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA ENDP ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$21
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 32
this$ = 32
this$GSCopy$ = 48
wavelength_$GSCopy$ = 72
width_$GSCopy$ = 80
__$ArrayPad$ = 88
this$ = 144
size_i_$ = 152
size_j_$ = 160
vlight_$ = 168
lambda0_$ = 176
wavelength_$ = 184
width_$ = 192
?dtor$22@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA PROC ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$22
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 432				; 000001b0H
	jmp	??1?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@XZ
?dtor$22@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA ENDP ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$22
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 32
this$ = 32
this$GSCopy$ = 48
wavelength_$GSCopy$ = 72
width_$GSCopy$ = 80
__$ArrayPad$ = 88
this$ = 144
size_i_$ = 152
size_j_$ = 160
vlight_$ = 168
lambda0_$ = 176
wavelength_$ = 184
width_$ = 192
?dtor$23@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA PROC ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$23
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 448				; 000001c0H
	jmp	??1?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@XZ
?dtor$23@?0???0Tikhonov2D@@QEAA@_K0NNV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@1@Z@4HA ENDP ; `Tikhonov2D::Tikhonov2D'::`1'::dtor$23
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
;	COMDAT ??1Tikhonov2D@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1Tikhonov2D@@QEAA@XZ PROC				; Tikhonov2D::~Tikhonov2D, COMDAT

; 28   : {

$LN400:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR [rcx+448]
	call	QWORD PTR __imp_free
	mov	rcx, QWORD PTR [rbx+432]
	call	QWORD PTR __imp_free
	mov	rcx, QWORD PTR [rbx+416]
	call	QWORD PTR __imp_free
	mov	rcx, QWORD PTR [rbx+400]
	call	QWORD PTR __imp_free
	mov	rcx, QWORD PTR [rbx+376]
	call	QWORD PTR __imp_free
	mov	rcx, QWORD PTR [rbx+352]
	call	QWORD PTR __imp_free
	mov	rcx, QWORD PTR [rbx+328]
	call	QWORD PTR __imp_free
	mov	rcx, QWORD PTR [rbx+304]
	call	QWORD PTR __imp_free
	mov	rcx, QWORD PTR [rbx+288]
	call	QWORD PTR __imp_free
	mov	rcx, QWORD PTR [rbx+272]
	call	QWORD PTR __imp_free
	mov	rcx, QWORD PTR [rbx+256]
	call	QWORD PTR __imp_free
	mov	rcx, QWORD PTR [rbx+240]
	call	QWORD PTR __imp_free
	mov	rcx, QWORD PTR [rbx+224]
	call	QWORD PTR __imp_free
	mov	rcx, QWORD PTR [rbx+200]
	call	QWORD PTR __imp_free
	mov	rcx, QWORD PTR [rbx+176]
	call	QWORD PTR __imp_free
	mov	rcx, QWORD PTR [rbx+152]
	call	QWORD PTR __imp_free
	mov	rcx, QWORD PTR [rbx+128]
	call	QWORD PTR __imp_free
	mov	rcx, QWORD PTR [rbx+104]
	call	QWORD PTR __imp_free
	mov	rcx, QWORD PTR [rbx+80]
	call	QWORD PTR __imp_free
	mov	rcx, QWORD PTR [rbx+64]
	call	QWORD PTR __imp_free
	mov	rcx, QWORD PTR [rbx+48]
	call	QWORD PTR __imp_free
	mov	rcx, QWORD PTR [rbx+32]
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 29   : }

	add	rsp, 32					; 00000020H
	pop	rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	rex_jmp	QWORD PTR __imp_free
??1Tikhonov2D@@QEAA@XZ ENDP				; Tikhonov2D::~Tikhonov2D
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwisenullaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
;	COMDAT ?set_Lf_2ndDeriv@Tikhonov2D@@QEAAXXZ
_TEXT	SEGMENT
$T1 = 32
this$ = 112
?set_Lf_2ndDeriv@Tikhonov2D@@QEAAXXZ PROC		; Tikhonov2D::set_Lf_2ndDeriv, COMDAT

; 278  : void Tikhonov2D::set_Lf_2ndDeriv(){

$LN600:
	push	rbp
	push	rsi
	push	r12
	push	r15
	sub	rsp, 72					; 00000048H

; 279  : 	Lf.resize(size_j - 1, size_j);

	mov	rsi, QWORD PTR [rcx+8]
	mov	r15, rcx
	lea	rbp, QWORD PTR [rsi-1]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rbp, rbp
	js	SHORT $LN8@set_Lf_2nd
	test	rsi, rsi
	jns	SHORT $LN9@set_Lf_2nd
$LN8@set_Lf_2nd:
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	mov	r8d, 241				; 000000f1H
	call	QWORD PTR __imp__wassert
$LN9@set_Lf_2nd:

; 44   :                : (rows > max_index / cols);

	mov	r12, 9223372036854775807		; 7fffffffffffffffH
	test	rbp, rbp
	je	SHORT $LN16@set_Lf_2nd
	test	rsi, rsi
	je	SHORT $LN16@set_Lf_2nd
	mov	rax, r12
	cdq
	idiv	rsi
	cmp	rbp, rax
	setg	al

; 45   :     if (error)

	test	al, al
	jne	$LN594@set_Lf_2nd

; 44   :                : (rows > max_index / cols);

	test	rsi, rsi
	je	SHORT $LN16@set_Lf_2nd
	mov	rax, r12
	cdq
	idiv	rsi
	cmp	rbp, rax
	setg	al

; 45   :     if (error)

	test	al, al
	jne	$LN596@set_Lf_2nd
$LN16@set_Lf_2nd:
	mov	QWORD PTR [rsp+120], rbx

; 250  :         m_storage.resize(nbRows*nbCols, nbRows, nbCols);

	lea	rbx, QWORD PTR [r15+152]
	mov	QWORD PTR [rsp+128], rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 249  :       if(size != m_rows*m_cols)

	mov	rax, QWORD PTR [rbx+16]
	mov	QWORD PTR [rsp+64], r14
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 250  :         m_storage.resize(nbRows*nbCols, nbRows, nbCols);

	mov	r14, rbp
	imul	r14, rsi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 249  :       if(size != m_rows*m_cols)

	xor	edi, edi
	imul	rax, QWORD PTR [rbx+8]
	cmp	r14, rax
	je	SHORT $LN21@set_Lf_2nd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR [rbx]
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 252  :         if (size)

	test	r14, r14
	je	SHORT $LN22@set_Lf_2nd

; 253  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

	mov	rcx, r14
	call	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
	mov	QWORD PTR [rbx], rax

; 254  :         else

	jmp	SHORT $LN21@set_Lf_2nd
$LN22@set_Lf_2nd:

; 255  :           m_data = 0;

	mov	QWORD PTR [rbx], rdi
$LN21@set_Lf_2nd:
	xorps	xmm0, xmm0

; 258  :       m_rows = nbRows;

	mov	QWORD PTR [rbx+8], rbp

; 259  :       m_cols = nbCols;

	mov	QWORD PTR [rbx+16], rsi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h

; 63   :     explicit variable_if_dynamic(T value) : m_value(value) {}

	mov	QWORD PTR $T1[rsp+8], rbp
	mov	QWORD PTR $T1[rsp+16], rsi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h

; 517  :   EIGEN_STRONG_INLINE scalar_constant_op(const scalar_constant_op& other) : m_other(other.m_other) { }

	movsdx	QWORD PTR $T1[rsp+24], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwisenullaryop.h

; 60   :       eigen_assert(nbRows >= 0

	test	rbp, rbp
	js	SHORT $LN69@set_Lf_2nd
	test	rsi, rsi
	jns	SHORT $LN70@set_Lf_2nd
$LN69@set_Lf_2nd:
	lea	rdx, OFFSET FLAT:??_C@_1LO@HNEDKPLG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1BDK@EFDGPJJE@?$AAn?$AAb?$AAR?$AAo?$AAw?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm@
	mov	r8d, 63					; 0000003fH
	call	QWORD PTR __imp__wassert
$LN70@set_Lf_2nd:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	test	rbp, rbp
	je	SHORT $LN592@set_Lf_2nd
	test	rsi, rsi
	je	SHORT $LN133@set_Lf_2nd
	mov	rax, r12
	cdq
	idiv	rsi
	cmp	rbp, rax
	setg	al

; 45   :     if (error)

	test	al, al
	jne	$LN597@set_Lf_2nd
$LN133@set_Lf_2nd:

; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rbp, rbp
$LN592@set_Lf_2nd:
	js	SHORT $LN237@set_Lf_2nd
	test	rsi, rsi
	jns	SHORT $LN238@set_Lf_2nd
$LN237@set_Lf_2nd:
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	mov	r8d, 241				; 000000f1H
	call	QWORD PTR __imp__wassert
$LN238@set_Lf_2nd:

; 44   :                : (rows > max_index / cols);

	test	rbp, rbp
	je	SHORT $LN245@set_Lf_2nd
	test	rsi, rsi
	je	SHORT $LN245@set_Lf_2nd
	mov	rax, r12
	cdq
	idiv	rsi
	cmp	rbp, rax
	setg	al

; 45   :     if (error)

	test	al, al
	jne	$LN598@set_Lf_2nd

; 44   :                : (rows > max_index / cols);

	test	rsi, rsi
	je	SHORT $LN245@set_Lf_2nd
	mov	rax, r12
	cdq
	idiv	rsi
	cmp	rbp, rax
	setg	al

; 45   :     if (error)

	test	al, al
	jne	$LN599@set_Lf_2nd
$LN245@set_Lf_2nd:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 249  :       if(size != m_rows*m_cols)

	mov	rax, QWORD PTR [rbx+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 250  :         m_storage.resize(nbRows*nbCols, nbRows, nbCols);

	mov	r14, rbp
	imul	r14, rsi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 249  :       if(size != m_rows*m_cols)

	imul	rax, QWORD PTR [rbx+8]
	cmp	r14, rax
	je	SHORT $LN250@set_Lf_2nd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR [rbx]
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 252  :         if (size)

	test	r14, r14
	je	SHORT $LN251@set_Lf_2nd

; 253  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

	mov	rcx, r14
	call	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
	mov	QWORD PTR [rbx], rax

; 254  :         else

	jmp	SHORT $LN250@set_Lf_2nd
$LN251@set_Lf_2nd:

; 255  :           m_data = 0;

	mov	QWORD PTR [rbx], rdi
$LN250@set_Lf_2nd:

; 259  :       m_cols = nbCols;

	mov	QWORD PTR [rbx+16], rsi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 49   :   inline Index size() const { return rows() * cols(); }

	imul	rsi, rbp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 258  :       m_rows = nbRows;

	mov	QWORD PTR [rbx+8], rbp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 404  :     const Index alignedEnd = alignedStart + ((size-alignedStart)/packetSize)*packetSize;

	mov	rax, rsi
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r8, rax
	add	r8, r8

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	test	r8, r8
	jle	SHORT $LN319@set_Lf_2nd
	xorps	xmm0, xmm0
	npad	13
$LL321@set_Lf_2nd:
	mov	rax, QWORD PTR [rbx]
	add	rdi, 2
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [rax+rdi*8-16], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	cmp	rdi, r8
	jl	SHORT $LL321@set_Lf_2nd
$LN319@set_Lf_2nd:

; 409  :     {
; 410  :       dst.template copyPacket<Derived2, dstAlignment, srcAlignment>(index, src);
; 411  :     }
; 412  : 
; 413  :     unaligned_assign_impl<>::run(src,dst,alignedEnd,size);

	lea	rcx, QWORD PTR $T1[rsp]
	mov	r9, rsi
	mov	rdx, rbx
	call	??$run@V?$CwiseNullaryOp@U?$scalar_constant_op@N@internal@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@@?$unaligned_assign_impl@$0A@@internal@Eigen@@SAXAEBV?$CwiseNullaryOp@U?$scalar_constant_op@N@internal@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@2@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@_J2@Z ; Eigen::internal::unaligned_assign_impl<0>::run<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>,Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::Matrix<double,-1,-1,0,-1,-1> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 336  :       eigen_assert(row >= 0 && row < rows()

	cmp	QWORD PTR [rbx+8], 0
	jle	SHORT $LN403@set_Lf_2nd
	cmp	QWORD PTR [rbx+16], 0
	jg	SHORT $LN404@set_Lf_2nd
$LN403@set_Lf_2nd:
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GK@FICMDKNL@?$AAr?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw?$AA?5?$AA?$DM?$AA?5?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AA?5@
	mov	r8d, 337				; 00000151H
	call	QWORD PTR __imp__wassert
$LN404@set_Lf_2nd:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 262  :     inline T *data() { return m_data; }

	mov	rax, QWORD PTR [rbx]
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 282  : 	Lf(0, 0) = 2.0;

	mov	rcx, 4611686018427387904		; 4000000000000000H
	mov	QWORD PTR [rax], rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 336  :       eigen_assert(row >= 0 && row < rows()

	cmp	QWORD PTR [rbx+8], 0
	jle	SHORT $LN437@set_Lf_2nd
	cmp	QWORD PTR [rbx+16], 1
	jg	SHORT $LN438@set_Lf_2nd
$LN437@set_Lf_2nd:
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GK@FICMDKNL@?$AAr?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw?$AA?5?$AA?$DM?$AA?5?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AA?5@
	mov	r8d, 337				; 00000151H
	call	QWORD PTR __imp__wassert
$LN438@set_Lf_2nd:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];

	mov	rcx, QWORD PTR [rbx+8]
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 283  : 	Lf(0, 1) = -2.0;

	mov	rax, QWORD PTR [rbx]
	mov	rbp, -4611686018427387904		; c000000000000000H
	mov	QWORD PTR [rax+rcx*8], rbp

; 284  : 	for (size_t j = 0; j < size_j - 2; ++j){

	cmp	QWORD PTR [r15+8], 2
	je	$LN589@set_Lf_2nd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	edi, 1
	mov	rsi, 4607182418800017408		; 3ff0000000000000H
$LL3@set_Lf_2nd:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 336  :       eigen_assert(row >= 0 && row < rows()

	test	rdi, rdi
	js	SHORT $LN471@set_Lf_2nd
	cmp	rdi, QWORD PTR [rbx+8]
	jge	SHORT $LN471@set_Lf_2nd
	lea	rax, QWORD PTR [rdi-1]
	test	rax, rax
	js	SHORT $LN471@set_Lf_2nd
	cmp	rax, QWORD PTR [rbx+16]
	jl	SHORT $LN472@set_Lf_2nd
$LN471@set_Lf_2nd:
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GK@FICMDKNL@?$AAr?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw?$AA?5?$AA?$DM?$AA?5?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AA?5@
	mov	r8d, 337				; 00000151H
	call	QWORD PTR __imp__wassert
$LN472@set_Lf_2nd:
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 285  : 		Lf(j + 1, j) = 1.0;

	mov	rax, QWORD PTR [rbx]
	lea	rcx, QWORD PTR [rdi-1]
	imul	rcx, QWORD PTR [rbx+8]
	add	rcx, rdi
	mov	QWORD PTR [rax+rcx*8], rsi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 336  :       eigen_assert(row >= 0 && row < rows()

	test	rdi, rdi
	js	SHORT $LN505@set_Lf_2nd
	cmp	rdi, QWORD PTR [rbx+8]
	jge	SHORT $LN505@set_Lf_2nd
	cmp	rdi, QWORD PTR [rbx+16]
	jl	SHORT $LN506@set_Lf_2nd
$LN505@set_Lf_2nd:
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GK@FICMDKNL@?$AAr?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw?$AA?5?$AA?$DM?$AA?5?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AA?5@
	mov	r8d, 337				; 00000151H
	call	QWORD PTR __imp__wassert
$LN506@set_Lf_2nd:
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 286  : 		Lf(j + 1, j + 1) = -2.0;

	mov	rcx, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR [rbx]
	inc	rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];

	imul	rcx, rdi
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 286  : 		Lf(j + 1, j + 1) = -2.0;

	mov	QWORD PTR [rax+rcx*8], rbp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 336  :       eigen_assert(row >= 0 && row < rows()

	test	rdi, rdi
	js	SHORT $LN539@set_Lf_2nd
	cmp	rdi, QWORD PTR [rbx+8]
	jge	SHORT $LN539@set_Lf_2nd
	lea	rax, QWORD PTR [rdi+1]
	test	rax, rax
	js	SHORT $LN539@set_Lf_2nd
	cmp	rax, QWORD PTR [rbx+16]
	jl	SHORT $LN540@set_Lf_2nd
$LN539@set_Lf_2nd:
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GK@FICMDKNL@?$AAr?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw?$AA?5?$AA?$DM?$AA?5?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AA?5@
	mov	r8d, 337				; 00000151H
	call	QWORD PTR __imp__wassert
$LN540@set_Lf_2nd:
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 287  : 		Lf(j + 1, j + 2) = 1.0;

	mov	rcx, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR [rbx]
	lea	rdx, QWORD PTR [rdi+1]
	imul	rcx, rdx
	add	rcx, rdi
	mov	rdi, rdx
	mov	QWORD PTR [rax+rcx*8], rsi
	mov	rax, QWORD PTR [r15+8]
	lea	rcx, QWORD PTR [rdx-1]
	sub	rax, 2
	cmp	rcx, rax
	jb	$LL3@set_Lf_2nd
$LN589@set_Lf_2nd:
	mov	rdi, QWORD PTR [rsp+128]
	mov	rbx, QWORD PTR [rsp+120]
	mov	r14, QWORD PTR [rsp+64]

; 289  : }

	add	rsp, 72					; 00000048H
	pop	r15
	pop	r12
	pop	rsi
	pop	rbp
	ret	0
$LN594@set_Lf_2nd:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN596@set_Lf_2nd:
	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN597@set_Lf_2nd:
	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN598@set_Lf_2nd:
	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN599@set_Lf_2nd:
	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN590@set_Lf_2nd:
?set_Lf_2ndDeriv@Tikhonov2D@@QEAAXXZ ENDP		; Tikhonov2D::set_Lf_2ndDeriv
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwisenullaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
;	COMDAT ?set_Lv_2ndDeriv@Tikhonov2D@@QEAAXXZ
_TEXT	SEGMENT
$T1 = 32
this$ = 112
?set_Lv_2ndDeriv@Tikhonov2D@@QEAAXXZ PROC		; Tikhonov2D::set_Lv_2ndDeriv, COMDAT

; 303  : void Tikhonov2D::set_Lv_2ndDeriv(){

$LN600:
	push	rbp
	push	rsi
	push	r12
	push	r15
	sub	rsp, 72					; 00000048H

; 304  : 	Lv.resize(size_j - 1, size_j);

	mov	rsi, QWORD PTR [rcx+8]
	mov	r15, rcx
	lea	rbp, QWORD PTR [rsi-1]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rbp, rbp
	js	SHORT $LN8@set_Lv_2nd
	test	rsi, rsi
	jns	SHORT $LN9@set_Lv_2nd
$LN8@set_Lv_2nd:
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	mov	r8d, 241				; 000000f1H
	call	QWORD PTR __imp__wassert
$LN9@set_Lv_2nd:

; 44   :                : (rows > max_index / cols);

	mov	r12, 9223372036854775807		; 7fffffffffffffffH
	test	rbp, rbp
	je	SHORT $LN16@set_Lv_2nd
	test	rsi, rsi
	je	SHORT $LN16@set_Lv_2nd
	mov	rax, r12
	cdq
	idiv	rsi
	cmp	rbp, rax
	setg	al

; 45   :     if (error)

	test	al, al
	jne	$LN594@set_Lv_2nd

; 44   :                : (rows > max_index / cols);

	test	rsi, rsi
	je	SHORT $LN16@set_Lv_2nd
	mov	rax, r12
	cdq
	idiv	rsi
	cmp	rbp, rax
	setg	al

; 45   :     if (error)

	test	al, al
	jne	$LN596@set_Lv_2nd
$LN16@set_Lv_2nd:
	mov	QWORD PTR [rsp+120], rbx

; 250  :         m_storage.resize(nbRows*nbCols, nbRows, nbCols);

	lea	rbx, QWORD PTR [r15+176]
	mov	QWORD PTR [rsp+128], rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 249  :       if(size != m_rows*m_cols)

	mov	rax, QWORD PTR [rbx+16]
	mov	QWORD PTR [rsp+64], r14
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 250  :         m_storage.resize(nbRows*nbCols, nbRows, nbCols);

	mov	r14, rbp
	imul	r14, rsi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 249  :       if(size != m_rows*m_cols)

	xor	edi, edi
	imul	rax, QWORD PTR [rbx+8]
	cmp	r14, rax
	je	SHORT $LN21@set_Lv_2nd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR [rbx]
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 252  :         if (size)

	test	r14, r14
	je	SHORT $LN22@set_Lv_2nd

; 253  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

	mov	rcx, r14
	call	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
	mov	QWORD PTR [rbx], rax

; 254  :         else

	jmp	SHORT $LN21@set_Lv_2nd
$LN22@set_Lv_2nd:

; 255  :           m_data = 0;

	mov	QWORD PTR [rbx], rdi
$LN21@set_Lv_2nd:
	xorps	xmm0, xmm0

; 258  :       m_rows = nbRows;

	mov	QWORD PTR [rbx+8], rbp

; 259  :       m_cols = nbCols;

	mov	QWORD PTR [rbx+16], rsi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h

; 63   :     explicit variable_if_dynamic(T value) : m_value(value) {}

	mov	QWORD PTR $T1[rsp+8], rbp
	mov	QWORD PTR $T1[rsp+16], rsi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h

; 517  :   EIGEN_STRONG_INLINE scalar_constant_op(const scalar_constant_op& other) : m_other(other.m_other) { }

	movsdx	QWORD PTR $T1[rsp+24], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwisenullaryop.h

; 60   :       eigen_assert(nbRows >= 0

	test	rbp, rbp
	js	SHORT $LN69@set_Lv_2nd
	test	rsi, rsi
	jns	SHORT $LN70@set_Lv_2nd
$LN69@set_Lv_2nd:
	lea	rdx, OFFSET FLAT:??_C@_1LO@HNEDKPLG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1BDK@EFDGPJJE@?$AAn?$AAb?$AAR?$AAo?$AAw?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm@
	mov	r8d, 63					; 0000003fH
	call	QWORD PTR __imp__wassert
$LN70@set_Lv_2nd:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	test	rbp, rbp
	je	SHORT $LN592@set_Lv_2nd
	test	rsi, rsi
	je	SHORT $LN133@set_Lv_2nd
	mov	rax, r12
	cdq
	idiv	rsi
	cmp	rbp, rax
	setg	al

; 45   :     if (error)

	test	al, al
	jne	$LN597@set_Lv_2nd
$LN133@set_Lv_2nd:

; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rbp, rbp
$LN592@set_Lv_2nd:
	js	SHORT $LN237@set_Lv_2nd
	test	rsi, rsi
	jns	SHORT $LN238@set_Lv_2nd
$LN237@set_Lv_2nd:
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	mov	r8d, 241				; 000000f1H
	call	QWORD PTR __imp__wassert
$LN238@set_Lv_2nd:

; 44   :                : (rows > max_index / cols);

	test	rbp, rbp
	je	SHORT $LN245@set_Lv_2nd
	test	rsi, rsi
	je	SHORT $LN245@set_Lv_2nd
	mov	rax, r12
	cdq
	idiv	rsi
	cmp	rbp, rax
	setg	al

; 45   :     if (error)

	test	al, al
	jne	$LN598@set_Lv_2nd

; 44   :                : (rows > max_index / cols);

	test	rsi, rsi
	je	SHORT $LN245@set_Lv_2nd
	mov	rax, r12
	cdq
	idiv	rsi
	cmp	rbp, rax
	setg	al

; 45   :     if (error)

	test	al, al
	jne	$LN599@set_Lv_2nd
$LN245@set_Lv_2nd:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 249  :       if(size != m_rows*m_cols)

	mov	rax, QWORD PTR [rbx+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 250  :         m_storage.resize(nbRows*nbCols, nbRows, nbCols);

	mov	r14, rbp
	imul	r14, rsi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 249  :       if(size != m_rows*m_cols)

	imul	rax, QWORD PTR [rbx+8]
	cmp	r14, rax
	je	SHORT $LN250@set_Lv_2nd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR [rbx]
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 252  :         if (size)

	test	r14, r14
	je	SHORT $LN251@set_Lv_2nd

; 253  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

	mov	rcx, r14
	call	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
	mov	QWORD PTR [rbx], rax

; 254  :         else

	jmp	SHORT $LN250@set_Lv_2nd
$LN251@set_Lv_2nd:

; 255  :           m_data = 0;

	mov	QWORD PTR [rbx], rdi
$LN250@set_Lv_2nd:

; 259  :       m_cols = nbCols;

	mov	QWORD PTR [rbx+16], rsi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 49   :   inline Index size() const { return rows() * cols(); }

	imul	rsi, rbp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 258  :       m_rows = nbRows;

	mov	QWORD PTR [rbx+8], rbp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 404  :     const Index alignedEnd = alignedStart + ((size-alignedStart)/packetSize)*packetSize;

	mov	rax, rsi
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r8, rax
	add	r8, r8

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	test	r8, r8
	jle	SHORT $LN319@set_Lv_2nd
	xorps	xmm0, xmm0
	npad	13
$LL321@set_Lv_2nd:
	mov	rax, QWORD PTR [rbx]
	add	rdi, 2
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [rax+rdi*8-16], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	cmp	rdi, r8
	jl	SHORT $LL321@set_Lv_2nd
$LN319@set_Lv_2nd:

; 409  :     {
; 410  :       dst.template copyPacket<Derived2, dstAlignment, srcAlignment>(index, src);
; 411  :     }
; 412  : 
; 413  :     unaligned_assign_impl<>::run(src,dst,alignedEnd,size);

	lea	rcx, QWORD PTR $T1[rsp]
	mov	r9, rsi
	mov	rdx, rbx
	call	??$run@V?$CwiseNullaryOp@U?$scalar_constant_op@N@internal@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@@?$unaligned_assign_impl@$0A@@internal@Eigen@@SAXAEBV?$CwiseNullaryOp@U?$scalar_constant_op@N@internal@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@2@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@_J2@Z ; Eigen::internal::unaligned_assign_impl<0>::run<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>,Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::Matrix<double,-1,-1,0,-1,-1> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 336  :       eigen_assert(row >= 0 && row < rows()

	cmp	QWORD PTR [rbx+8], 0
	jle	SHORT $LN403@set_Lv_2nd
	cmp	QWORD PTR [rbx+16], 0
	jg	SHORT $LN404@set_Lv_2nd
$LN403@set_Lv_2nd:
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GK@FICMDKNL@?$AAr?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw?$AA?5?$AA?$DM?$AA?5?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AA?5@
	mov	r8d, 337				; 00000151H
	call	QWORD PTR __imp__wassert
$LN404@set_Lv_2nd:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 262  :     inline T *data() { return m_data; }

	mov	rax, QWORD PTR [rbx]
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 307  : 	Lv(0, 0) = 2.0;

	mov	rcx, 4611686018427387904		; 4000000000000000H
	mov	QWORD PTR [rax], rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 336  :       eigen_assert(row >= 0 && row < rows()

	cmp	QWORD PTR [rbx+8], 0
	jle	SHORT $LN437@set_Lv_2nd
	cmp	QWORD PTR [rbx+16], 1
	jg	SHORT $LN438@set_Lv_2nd
$LN437@set_Lv_2nd:
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GK@FICMDKNL@?$AAr?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw?$AA?5?$AA?$DM?$AA?5?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AA?5@
	mov	r8d, 337				; 00000151H
	call	QWORD PTR __imp__wassert
$LN438@set_Lv_2nd:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];

	mov	rcx, QWORD PTR [rbx+8]
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 308  : 	Lv(0, 1) = -2.0;

	mov	rax, QWORD PTR [rbx]
	mov	rbp, -4611686018427387904		; c000000000000000H
	mov	QWORD PTR [rax+rcx*8], rbp

; 309  : 	for (size_t j = 0; j < size_j - 2; ++j){

	cmp	QWORD PTR [r15+8], 2
	je	$LN589@set_Lv_2nd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	edi, 1
	mov	rsi, 4607182418800017408		; 3ff0000000000000H
$LL3@set_Lv_2nd:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 336  :       eigen_assert(row >= 0 && row < rows()

	test	rdi, rdi
	js	SHORT $LN471@set_Lv_2nd
	cmp	rdi, QWORD PTR [rbx+8]
	jge	SHORT $LN471@set_Lv_2nd
	lea	rax, QWORD PTR [rdi-1]
	test	rax, rax
	js	SHORT $LN471@set_Lv_2nd
	cmp	rax, QWORD PTR [rbx+16]
	jl	SHORT $LN472@set_Lv_2nd
$LN471@set_Lv_2nd:
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GK@FICMDKNL@?$AAr?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw?$AA?5?$AA?$DM?$AA?5?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AA?5@
	mov	r8d, 337				; 00000151H
	call	QWORD PTR __imp__wassert
$LN472@set_Lv_2nd:
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 310  : 		Lv(j + 1, j) = 1.0;

	mov	rax, QWORD PTR [rbx]
	lea	rcx, QWORD PTR [rdi-1]
	imul	rcx, QWORD PTR [rbx+8]
	add	rcx, rdi
	mov	QWORD PTR [rax+rcx*8], rsi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 336  :       eigen_assert(row >= 0 && row < rows()

	test	rdi, rdi
	js	SHORT $LN505@set_Lv_2nd
	cmp	rdi, QWORD PTR [rbx+8]
	jge	SHORT $LN505@set_Lv_2nd
	cmp	rdi, QWORD PTR [rbx+16]
	jl	SHORT $LN506@set_Lv_2nd
$LN505@set_Lv_2nd:
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GK@FICMDKNL@?$AAr?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw?$AA?5?$AA?$DM?$AA?5?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AA?5@
	mov	r8d, 337				; 00000151H
	call	QWORD PTR __imp__wassert
$LN506@set_Lv_2nd:
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 311  : 		Lv(j + 1, j + 1) = -2.0;

	mov	rcx, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR [rbx]
	inc	rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];

	imul	rcx, rdi
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 311  : 		Lv(j + 1, j + 1) = -2.0;

	mov	QWORD PTR [rax+rcx*8], rbp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 336  :       eigen_assert(row >= 0 && row < rows()

	test	rdi, rdi
	js	SHORT $LN539@set_Lv_2nd
	cmp	rdi, QWORD PTR [rbx+8]
	jge	SHORT $LN539@set_Lv_2nd
	lea	rax, QWORD PTR [rdi+1]
	test	rax, rax
	js	SHORT $LN539@set_Lv_2nd
	cmp	rax, QWORD PTR [rbx+16]
	jl	SHORT $LN540@set_Lv_2nd
$LN539@set_Lv_2nd:
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GK@FICMDKNL@?$AAr?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw?$AA?5?$AA?$DM?$AA?5?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AA?5@
	mov	r8d, 337				; 00000151H
	call	QWORD PTR __imp__wassert
$LN540@set_Lv_2nd:
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 312  : 		Lv(j + 1, j + 2) = 1.0;

	mov	rcx, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR [rbx]
	lea	rdx, QWORD PTR [rdi+1]
	imul	rcx, rdx
	add	rcx, rdi
	mov	rdi, rdx
	mov	QWORD PTR [rax+rcx*8], rsi
	mov	rax, QWORD PTR [r15+8]
	lea	rcx, QWORD PTR [rdx-1]
	sub	rax, 2
	cmp	rcx, rax
	jb	$LL3@set_Lv_2nd
$LN589@set_Lv_2nd:
	mov	rdi, QWORD PTR [rsp+128]
	mov	rbx, QWORD PTR [rsp+120]
	mov	r14, QWORD PTR [rsp+64]

; 314  : }

	add	rsp, 72					; 00000048H
	pop	r15
	pop	r12
	pop	rsi
	pop	rbp
	ret	0
$LN594@set_Lv_2nd:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN596@set_Lv_2nd:
	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN597@set_Lv_2nd:
	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN598@set_Lv_2nd:
	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN599@set_Lv_2nd:
	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN590@set_Lv_2nd:
?set_Lv_2ndDeriv@Tikhonov2D@@QEAAXXZ ENDP		; Tikhonov2D::set_Lv_2ndDeriv
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
;	COMDAT ?solve@Tikhonov2D@@QEAA_NNNNN@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
$T9 = 56
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 88
$T14 = 88
$T15 = 88
$T16 = 88
$T17 = 88
$T18 = 224
$T19 = 224
$T20 = 224
$T21 = 224
$T22 = 224
$T23 = 224
$T24 = 224
$T25 = 224
this$ = 224
lambda0$ = 232
lambda1$ = 240
relativeError0$ = 248
vError1$ = 256
?solve@Tikhonov2D@@QEAA_NNNNN@Z PROC			; Tikhonov2D::solve, COMDAT

; 34   : {

$LN961:
	mov	rax, rsp
	push	rbp
	push	rdi
	push	r14
	lea	rbp, QWORD PTR [rax-87]
	sub	rsp, 192				; 000000c0H
	mov	QWORD PTR $T1[rbp-129], -2
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+24], rsi
	movaps	XMMWORD PTR [rax-40], xmm6
	movaps	XMMWORD PTR [rax-56], xmm7
	movaps	XMMWORD PTR [rax-72], xmm8
	movaps	XMMWORD PTR [rax-88], xmm9
	movaps	xmm6, xmm3
	movaps	xmm9, xmm2
	movaps	xmm7, xmm1
	mov	rsi, rcx

; 35   : //	solveF(lambda0, relativeError0);
; 36   : 	
; 37   : 	count.resize(3);

	lea	rdi, QWORD PTR [rcx+448]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 322  :       if(size != m_rows*_Cols)

	cmp	QWORD PTR [rdi+8], 3
	je	SHORT $LN54@solve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR [rdi]
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 326  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

	mov	ecx, 3
	call	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
	mov	QWORD PTR [rdi], rax
$LN54@solve:

; 327  :         else
; 328  :           m_data = 0;
; 329  :         EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN
; 330  :       }
; 331  :       m_rows = nbRows;

	mov	QWORD PTR [rdi+8], 3
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 394  :       eigen_assert(index >= 0 && index < size());

	cmp	QWORD PTR [rdi+8], 0
	jg	SHORT $LN74@solve
	mov	r8d, 394				; 0000018aH
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	call	QWORD PTR __imp__wassert
$LN74@solve:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 334  :     inline T *data() { return m_data; }

	mov	rax, QWORD PTR [rdi]
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 38   : 	count(0) = 100;

	mov	rbx, 4636737291354636288		; 4059000000000000H
	mov	QWORD PTR [rax], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 394  :       eigen_assert(index >= 0 && index < size());

	cmp	QWORD PTR [rdi+8], 1
	jg	SHORT $LN102@solve
	mov	r8d, 394				; 0000018aH
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	call	QWORD PTR __imp__wassert
$LN102@solve:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 334  :     inline T *data() { return m_data; }

	mov	rax, QWORD PTR [rdi]
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 39   : 	count(1) = 100;

	mov	QWORD PTR [rax+8], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 394  :       eigen_assert(index >= 0 && index < size());

	cmp	QWORD PTR [rdi+8], 2
	jg	SHORT $LN130@solve
	mov	r8d, 394				; 0000018aH
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	call	QWORD PTR __imp__wassert
$LN130@solve:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 334  :     inline T *data() { return m_data; }

	mov	rax, QWORD PTR [rdi]
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 40   : 	count(2) = 100;

	mov	QWORD PTR [rax+16], rbx

; 41   : 
; 42   : 	for (size_t trial = 0; trial < 20; ++trial){

	xor	r14d, r14d
	mov	ebx, r14d
	npad	12
$LL12@solve:

; 43   : 		if (updateF(lambda0, relativeError0)) { count(0) = trial;  break; }

	movaps	xmm2, xmm6
	movaps	xmm1, xmm7
	mov	rcx, rsi
	call	?updateF@Tikhonov2D@@AEAA_NNN@Z		; Tikhonov2D::updateF
	test	al, al
	jne	SHORT $LN946@solve

; 41   : 
; 42   : 	for (size_t trial = 0; trial < 20; ++trial){

	inc	rbx
	cmp	rbx, 20
	jb	SHORT $LL12@solve

; 58   : 		if (updateFandV(lambda0, lambda1, relativeError0, vError1)){

	jmp	SHORT $LN10@solve
$LN946@solve:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 394  :       eigen_assert(index >= 0 && index < size());

	cmp	QWORD PTR [rdi+8], r14
	jg	SHORT $LN158@solve
	mov	r8d, 394				; 0000018aH
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	call	QWORD PTR __imp__wassert
$LN158@solve:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 334  :     inline T *data() { return m_data; }

	mov	rax, QWORD PTR [rdi]
	xorps	xmm0, xmm0
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 43   : 		if (updateF(lambda0, relativeError0)) { count(0) = trial;  break; }

	cvtsi2sd xmm0, rbx
	test	rbx, rbx
	jns	SHORT $LN960@solve
	addsd	xmm0, QWORD PTR __real@43f0000000000000
$LN960@solve:
	movsdx	QWORD PTR [rax], xmm0
$LN10@solve:

; 45   : 	IGORdata::write_itx(count, "output/prac/count.itx", "count");

	lea	rax, QWORD PTR $T9[rbp-129]
	mov	QWORD PTR $T25[rbp-129], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T9[rbp-105], 15

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T9[rbp-113], r14
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T9[rbp-129], r14b
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 5
	lea	rdx, OFFSET FLAT:??_C@_05IOMEMJEC@count?$AA@
	lea	rcx, QWORD PTR $T9[rbp-129]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T17[rbp-105], 15

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T17[rbp-113], r14
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T17[rbp-129], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 21
	lea	rdx, OFFSET FLAT:??_C@_0BG@DILIGMMN@output?1prac?1count?4itx?$AA@
	lea	rcx, QWORD PTR $T17[rbp-129]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 45   : 	IGORdata::write_itx(count, "output/prac/count.itx", "count");

	lea	r8, QWORD PTR $T9[rbp-129]
	lea	rdx, QWORD PTR $T17[rbp-129]
	mov	rcx, rdi
	call	??$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z ; IGORdata::write_itx<double,-1,1,0,-1,1>

; 46   : 	IGORdata::write_itx(count, "output/debug/count.itx", "count");

	lea	rax, QWORD PTR $T8[rbp-129]
	mov	QWORD PTR $T24[rbp-129], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T8[rbp-105], 15

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T8[rbp-113], r14
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T8[rbp-129], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 5
	lea	rdx, OFFSET FLAT:??_C@_05IOMEMJEC@count?$AA@
	lea	rcx, QWORD PTR $T8[rbp-129]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T16[rbp-105], 15

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T16[rbp-113], r14
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T16[rbp-129], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 22
	lea	rdx, OFFSET FLAT:??_C@_0BH@EAMCBOFL@output?1debug?1count?4itx?$AA@
	lea	rcx, QWORD PTR $T16[rbp-129]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 46   : 	IGORdata::write_itx(count, "output/debug/count.itx", "count");

	lea	r8, QWORD PTR $T8[rbp-129]
	lea	rdx, QWORD PTR $T16[rbp-129]
	mov	rcx, rdi
	call	??$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z ; IGORdata::write_itx<double,-1,1,0,-1,1>

; 47   : 
; 48   : 	for (size_t trial = 0; trial < 20; ++trial){

	mov	rbx, r14
	movsdx	xmm8, QWORD PTR vError1$[rbp-129]
	npad	2
$LL8@solve:

; 49   : 		if (updateV(lambda1, vError1)) { count(1) = trial;  break; }

	movaps	xmm2, xmm8
	movaps	xmm1, xmm9
	mov	rcx, rsi
	call	?updateV@Tikhonov2D@@AEAA_NNN@Z		; Tikhonov2D::updateV
	test	al, al
	jne	SHORT $LN947@solve

; 50   : 		updateF(lambda0, relativeError0);

	movaps	xmm2, xmm6
	movaps	xmm1, xmm7
	mov	rcx, rsi
	call	?updateF@Tikhonov2D@@AEAA_NNN@Z		; Tikhonov2D::updateF

; 47   : 
; 48   : 	for (size_t trial = 0; trial < 20; ++trial){

	inc	rbx
	cmp	rbx, 20
	jb	SHORT $LL8@solve

; 58   : 		if (updateFandV(lambda0, lambda1, relativeError0, vError1)){

	jmp	SHORT $LN6@solve
$LN947@solve:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 394  :       eigen_assert(index >= 0 && index < size());

	cmp	QWORD PTR [rdi+8], 1
	jg	SHORT $LN362@solve
	mov	r8d, 394				; 0000018aH
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	call	QWORD PTR __imp__wassert
$LN362@solve:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 334  :     inline T *data() { return m_data; }

	mov	rax, QWORD PTR [rdi]
	xorps	xmm0, xmm0
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 49   : 		if (updateV(lambda1, vError1)) { count(1) = trial;  break; }

	cvtsi2sd xmm0, rbx
	test	rbx, rbx
	jns	SHORT $LN959@solve
	addsd	xmm0, QWORD PTR __real@43f0000000000000
$LN959@solve:
	movsdx	QWORD PTR [rax+8], xmm0
$LN6@solve:

; 53   : 	IGORdata::write_itx(count, "output/prac/count.itx", "count");

	lea	rax, QWORD PTR $T7[rbp-129]
	mov	QWORD PTR $T23[rbp-129], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T7[rbp-105], 15

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T7[rbp-113], r14
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T7[rbp-129], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 5
	lea	rdx, OFFSET FLAT:??_C@_05IOMEMJEC@count?$AA@
	lea	rcx, QWORD PTR $T7[rbp-129]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T15[rbp-105], 15

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T15[rbp-113], r14
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T15[rbp-129], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 21
	lea	rdx, OFFSET FLAT:??_C@_0BG@DILIGMMN@output?1prac?1count?4itx?$AA@
	lea	rcx, QWORD PTR $T15[rbp-129]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 53   : 	IGORdata::write_itx(count, "output/prac/count.itx", "count");

	lea	r8, QWORD PTR $T7[rbp-129]
	lea	rdx, QWORD PTR $T15[rbp-129]
	mov	rcx, rdi
	call	??$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z ; IGORdata::write_itx<double,-1,1,0,-1,1>

; 54   : 	IGORdata::write_itx(count, "output/debug/count.itx", "count");

	lea	rax, QWORD PTR $T6[rbp-129]
	mov	QWORD PTR $T22[rbp-129], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T6[rbp-105], 15

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T6[rbp-113], r14
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T6[rbp-129], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 5
	lea	rdx, OFFSET FLAT:??_C@_05IOMEMJEC@count?$AA@
	lea	rcx, QWORD PTR $T6[rbp-129]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T14[rbp-105], 15

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T14[rbp-113], r14
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T14[rbp-129], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 22
	lea	rdx, OFFSET FLAT:??_C@_0BH@EAMCBOFL@output?1debug?1count?4itx?$AA@
	lea	rcx, QWORD PTR $T14[rbp-129]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 54   : 	IGORdata::write_itx(count, "output/debug/count.itx", "count");

	lea	r8, QWORD PTR $T6[rbp-129]
	lea	rdx, QWORD PTR $T14[rbp-129]
	mov	rcx, rdi
	call	??$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z ; IGORdata::write_itx<double,-1,1,0,-1,1>

; 55   : 
; 56   : 
; 57   : 	for (size_t trial = 0; trial < 20; ++trial){

	mov	rbx, r14
	npad	6
$LL4@solve:

; 58   : 		if (updateFandV(lambda0, lambda1, relativeError0, vError1)){

	movsdx	QWORD PTR [rsp+32], xmm8
	movaps	xmm3, xmm6
	movaps	xmm2, xmm9
	movaps	xmm1, xmm7
	mov	rcx, rsi
	call	?updateFandV@Tikhonov2D@@AEAA_NNNNN@Z	; Tikhonov2D::updateFandV
	test	al, al
	jne	$LN948@solve

; 55   : 
; 56   : 
; 57   : 	for (size_t trial = 0; trial < 20; ++trial){

	inc	rbx
	cmp	rbx, 20
	jb	SHORT $LL4@solve

; 65   : 	IGORdata::write_itx(count, "output/prac/count.itx", "count");

	lea	rax, QWORD PTR $T3[rbp-129]
	mov	QWORD PTR $T19[rbp-129], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T3[rbp-105], 15

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T3[rbp-113], r14
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T3[rbp-129], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 5
	lea	rdx, OFFSET FLAT:??_C@_05IOMEMJEC@count?$AA@
	lea	rcx, QWORD PTR $T3[rbp-129]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T11[rbp-105], 15

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T11[rbp-113], r14
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T11[rbp-129], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 21
	lea	rdx, OFFSET FLAT:??_C@_0BG@DILIGMMN@output?1prac?1count?4itx?$AA@
	lea	rcx, QWORD PTR $T11[rbp-129]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 65   : 	IGORdata::write_itx(count, "output/prac/count.itx", "count");

	lea	r8, QWORD PTR $T3[rbp-129]
	lea	rdx, QWORD PTR $T11[rbp-129]
	mov	rcx, rdi
	call	??$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z ; IGORdata::write_itx<double,-1,1,0,-1,1>

; 66   : 	IGORdata::write_itx(count, "output/debug/count.itx", "count");

	lea	rax, QWORD PTR $T2[rbp-129]
	mov	QWORD PTR $T18[rbp-129], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T2[rbp-105], 15

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T2[rbp-113], r14
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T2[rbp-129], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 5
	lea	rdx, OFFSET FLAT:??_C@_05IOMEMJEC@count?$AA@
	lea	rcx, QWORD PTR $T2[rbp-129]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T10[rbp-105], 15

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T10[rbp-113], r14
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T10[rbp-129], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 22
	lea	rdx, OFFSET FLAT:??_C@_0BH@EAMCBOFL@output?1debug?1count?4itx?$AA@
	lea	rcx, QWORD PTR $T10[rbp-129]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 66   : 	IGORdata::write_itx(count, "output/debug/count.itx", "count");

	lea	r8, QWORD PTR $T2[rbp-129]
	lea	rdx, QWORD PTR $T10[rbp-129]
	mov	rcx, rdi
	call	??$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z ; IGORdata::write_itx<double,-1,1,0,-1,1>

; 67   : 	return false;

	xor	al, al
	jmp	$LN13@solve
$LN948@solve:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 394  :       eigen_assert(index >= 0 && index < size());

	cmp	QWORD PTR [rdi+8], 2
	jg	SHORT $LN566@solve
	mov	r8d, 394				; 0000018aH
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	call	QWORD PTR __imp__wassert
$LN566@solve:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 334  :     inline T *data() { return m_data; }

	mov	rax, QWORD PTR [rdi]
	xorps	xmm0, xmm0
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 59   : 			count(2) = trial;

	cvtsi2sd xmm0, rbx
	test	rbx, rbx
	jns	SHORT $LN958@solve
	addsd	xmm0, QWORD PTR __real@43f0000000000000
$LN958@solve:
	movsdx	QWORD PTR [rax+16], xmm0

; 60   : 			IGORdata::write_itx(count, "output/prac/count.itx", "count");

	lea	rax, QWORD PTR $T5[rbp-129]
	mov	QWORD PTR $T21[rbp-129], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T5[rbp-105], 15

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T5[rbp-113], r14
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T5[rbp-129], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 5
	lea	rdx, OFFSET FLAT:??_C@_05IOMEMJEC@count?$AA@
	lea	rcx, QWORD PTR $T5[rbp-129]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T13[rbp-105], 15

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T13[rbp-113], r14
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T13[rbp-129], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 21
	lea	rdx, OFFSET FLAT:??_C@_0BG@DILIGMMN@output?1prac?1count?4itx?$AA@
	lea	rcx, QWORD PTR $T13[rbp-129]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 60   : 			IGORdata::write_itx(count, "output/prac/count.itx", "count");

	lea	r8, QWORD PTR $T5[rbp-129]
	lea	rdx, QWORD PTR $T13[rbp-129]
	mov	rcx, rdi
	call	??$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z ; IGORdata::write_itx<double,-1,1,0,-1,1>

; 61   : 			IGORdata::write_itx(count, "output/debug/count.itx", "count");

	lea	rax, QWORD PTR $T4[rbp-129]
	mov	QWORD PTR $T20[rbp-129], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T4[rbp-105], 15

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T4[rbp-113], r14
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T4[rbp-129], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 5
	lea	rdx, OFFSET FLAT:??_C@_05IOMEMJEC@count?$AA@
	lea	rcx, QWORD PTR $T4[rbp-129]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T12[rbp-105], 15

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T12[rbp-113], r14
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T12[rbp-129], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 22
	lea	rdx, OFFSET FLAT:??_C@_0BH@EAMCBOFL@output?1debug?1count?4itx?$AA@
	lea	rcx, QWORD PTR $T12[rbp-129]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 61   : 			IGORdata::write_itx(count, "output/debug/count.itx", "count");

	lea	r8, QWORD PTR $T4[rbp-129]
	lea	rdx, QWORD PTR $T12[rbp-129]
	mov	rcx, rdi
	call	??$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z ; IGORdata::write_itx<double,-1,1,0,-1,1>

; 62   : 			return true;

	mov	al, 1
$LN13@solve:

; 68   : }   

	lea	r11, QWORD PTR [rsp+192]
	mov	rbx, QWORD PTR [r11+40]
	mov	rsi, QWORD PTR [r11+48]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	mov	rsp, r11
	pop	r14
	pop	rdi
	pop	rbp
	ret	0
?solve@Tikhonov2D@@QEAA_NNNNN@Z ENDP			; Tikhonov2D::solve
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
$T9 = 56
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 88
$T14 = 88
$T15 = 88
$T16 = 88
$T17 = 88
$T18 = 224
$T19 = 224
$T20 = 224
$T21 = 224
$T22 = 224
$T23 = 224
$T24 = 224
$T25 = 224
this$ = 224
lambda0$ = 232
lambda1$ = 240
relativeError0$ = 248
vError1$ = 256
?dtor$0@?0??solve@Tikhonov2D@@QEAA_NNNNN@Z@4HA PROC	; `Tikhonov2D::solve'::`1'::dtor$0
	mov	rcx, QWORD PTR $T25[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??solve@Tikhonov2D@@QEAA_NNNNN@Z@4HA ENDP	; `Tikhonov2D::solve'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
$T9 = 56
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 88
$T14 = 88
$T15 = 88
$T16 = 88
$T17 = 88
$T18 = 224
$T19 = 224
$T20 = 224
$T21 = 224
$T22 = 224
$T23 = 224
$T24 = 224
$T25 = 224
this$ = 224
lambda0$ = 232
lambda1$ = 240
relativeError0$ = 248
vError1$ = 256
?dtor$2@?0??solve@Tikhonov2D@@QEAA_NNNNN@Z@4HA PROC	; `Tikhonov2D::solve'::`1'::dtor$2
	mov	rcx, QWORD PTR $T24[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??solve@Tikhonov2D@@QEAA_NNNNN@Z@4HA ENDP	; `Tikhonov2D::solve'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
$T9 = 56
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 88
$T14 = 88
$T15 = 88
$T16 = 88
$T17 = 88
$T18 = 224
$T19 = 224
$T20 = 224
$T21 = 224
$T22 = 224
$T23 = 224
$T24 = 224
$T25 = 224
this$ = 224
lambda0$ = 232
lambda1$ = 240
relativeError0$ = 248
vError1$ = 256
?dtor$4@?0??solve@Tikhonov2D@@QEAA_NNNNN@Z@4HA PROC	; `Tikhonov2D::solve'::`1'::dtor$4
	mov	rcx, QWORD PTR $T23[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0??solve@Tikhonov2D@@QEAA_NNNNN@Z@4HA ENDP	; `Tikhonov2D::solve'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
$T9 = 56
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 88
$T14 = 88
$T15 = 88
$T16 = 88
$T17 = 88
$T18 = 224
$T19 = 224
$T20 = 224
$T21 = 224
$T22 = 224
$T23 = 224
$T24 = 224
$T25 = 224
this$ = 224
lambda0$ = 232
lambda1$ = 240
relativeError0$ = 248
vError1$ = 256
?dtor$6@?0??solve@Tikhonov2D@@QEAA_NNNNN@Z@4HA PROC	; `Tikhonov2D::solve'::`1'::dtor$6
	mov	rcx, QWORD PTR $T22[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$6@?0??solve@Tikhonov2D@@QEAA_NNNNN@Z@4HA ENDP	; `Tikhonov2D::solve'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
$T9 = 56
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 88
$T14 = 88
$T15 = 88
$T16 = 88
$T17 = 88
$T18 = 224
$T19 = 224
$T20 = 224
$T21 = 224
$T22 = 224
$T23 = 224
$T24 = 224
$T25 = 224
this$ = 224
lambda0$ = 232
lambda1$ = 240
relativeError0$ = 248
vError1$ = 256
?dtor$8@?0??solve@Tikhonov2D@@QEAA_NNNNN@Z@4HA PROC	; `Tikhonov2D::solve'::`1'::dtor$8
	mov	rcx, QWORD PTR $T21[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$8@?0??solve@Tikhonov2D@@QEAA_NNNNN@Z@4HA ENDP	; `Tikhonov2D::solve'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
$T9 = 56
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 88
$T14 = 88
$T15 = 88
$T16 = 88
$T17 = 88
$T18 = 224
$T19 = 224
$T20 = 224
$T21 = 224
$T22 = 224
$T23 = 224
$T24 = 224
$T25 = 224
this$ = 224
lambda0$ = 232
lambda1$ = 240
relativeError0$ = 248
vError1$ = 256
?dtor$10@?0??solve@Tikhonov2D@@QEAA_NNNNN@Z@4HA PROC	; `Tikhonov2D::solve'::`1'::dtor$10
	mov	rcx, QWORD PTR $T20[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$10@?0??solve@Tikhonov2D@@QEAA_NNNNN@Z@4HA ENDP	; `Tikhonov2D::solve'::`1'::dtor$10
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
$T9 = 56
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 88
$T14 = 88
$T15 = 88
$T16 = 88
$T17 = 88
$T18 = 224
$T19 = 224
$T20 = 224
$T21 = 224
$T22 = 224
$T23 = 224
$T24 = 224
$T25 = 224
this$ = 224
lambda0$ = 232
lambda1$ = 240
relativeError0$ = 248
vError1$ = 256
?dtor$12@?0??solve@Tikhonov2D@@QEAA_NNNNN@Z@4HA PROC	; `Tikhonov2D::solve'::`1'::dtor$12
	mov	rcx, QWORD PTR $T19[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$12@?0??solve@Tikhonov2D@@QEAA_NNNNN@Z@4HA ENDP	; `Tikhonov2D::solve'::`1'::dtor$12
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
$T9 = 56
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 88
$T14 = 88
$T15 = 88
$T16 = 88
$T17 = 88
$T18 = 224
$T19 = 224
$T20 = 224
$T21 = 224
$T22 = 224
$T23 = 224
$T24 = 224
$T25 = 224
this$ = 224
lambda0$ = 232
lambda1$ = 240
relativeError0$ = 248
vError1$ = 256
?dtor$14@?0??solve@Tikhonov2D@@QEAA_NNNNN@Z@4HA PROC	; `Tikhonov2D::solve'::`1'::dtor$14
	mov	rcx, QWORD PTR $T18[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$14@?0??solve@Tikhonov2D@@QEAA_NNNNN@Z@4HA ENDP	; `Tikhonov2D::solve'::`1'::dtor$14
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arraywrapper.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
;	COMDAT ?getAf@Tikhonov2D@@QEBA?AV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@XZ
_TEXT	SEGMENT
$T1 = 32
__$ReturnUdt$GSCopy$ = 40
$T2 = 48
$T3 = 56
$T4 = 80
$T5 = 80
Af$ = 128
__$ArrayPad$ = 144
this$ = 224
__$ReturnUdt$ = 232
?getAf@Tikhonov2D@@QEBA?AV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@XZ PROC ; Tikhonov2D::getAf, COMDAT

; 260  : Eigen::MatrixXd Tikhonov2D::getAf()const{

$LN739:
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-39]
	sub	rsp, 160				; 000000a0H
	mov	QWORD PTR $T2[rbp-121], -2
	mov	QWORD PTR [rsp+240], rbx
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-121], rax
	mov	rbx, rdx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rbp-121], rdx
	xor	edi, edi
	mov	DWORD PTR $T1[rbp-121], edi
	xor	eax, eax
	mov	QWORD PTR Af$[rbp-121], rax
	mov	QWORD PTR Af$[rbp-113], rax

; 261  : 	Eigen::VectorXd Af = A*f.array().exp().matrix();

	lea	rax, QWORD PTR [rcx+400]
	mov	QWORD PTR $T5[rbp-113], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arraywrapper.h

; 181  :     inline MatrixWrapper(ExpressionType& a_matrix) : m_expression(a_matrix) {}

	movups	xmm0, XMMWORD PTR $T5[rbp-121]
	movups	XMMWORD PTR $T3[rbp-121], xmm0
	movsdx	xmm1, QWORD PTR $T5[rbp-105]
	movsdx	QWORD PTR $T3[rbp-105], xmm1
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 261  : 	Eigen::VectorXd Af = A*f.array().exp().matrix();

	add	rcx, 80					; 00000050H
	lea	r8, QWORD PTR $T3[rbp-121]
	lea	rdx, QWORD PTR $T4[rbp-121]
	call	??$?DV?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@Eigen@@@?$MatrixBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA?BV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@1@AEBV?$MatrixBase@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@Eigen@@@1@@Z ; Eigen::MatrixBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::operator*<Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const > >
	mov	r15, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rax, QWORD PTR [rax]
	mov	r14, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 420  :   if(size==0)

	mov	r13, 2305843009213693951		; 1fffffffffffffffH
	test	r14, r14
	jne	SHORT $LN90@getAf

; 421  :     return 0; // short-cut. Also fixes Bug 884

	mov	ecx, edi
	jmp	SHORT $LN91@getAf
$LN90@getAf:

; 244  :   #elif EIGEN_HAS_POSIX_MEMALIGN
; 245  :     std::free(ptr);
; 246  :   #elif EIGEN_HAS_MM_MALLOC
; 247  :     _mm_free(ptr);
; 248  :   #elif defined(_MSC_VER) && (!defined(_WIN32_WCE))
; 249  :     _aligned_free(ptr);
; 250  :   #else
; 251  :     handmade_aligned_free(ptr);
; 252  :   #endif
; 253  : }
; 254  : 
; 255  : /**
; 256  : * \internal
; 257  : * \brief Reallocates an aligned block of memory.
; 258  : * \throws std::bad_alloc on allocation failure
; 259  : **/
; 260  : inline void* aligned_realloc(void *ptr, size_t new_size, size_t old_size)
; 261  : {
; 262  :   EIGEN_UNUSED_VARIABLE(old_size);
; 263  : 
; 264  :   void *result;
; 265  : #if !EIGEN_ALIGN
; 266  :   result = std::realloc(ptr,new_size);
; 267  : #elif EIGEN_MALLOC_ALREADY_ALIGNED
; 268  :   result = std::realloc(ptr,new_size);
; 269  : #elif EIGEN_HAS_POSIX_MEMALIGN
; 270  :   result = generic_aligned_realloc(ptr,new_size,old_size);
; 271  : #elif EIGEN_HAS_MM_MALLOC
; 272  :   // The defined(_mm_free) is just here to verify that this MSVC version
; 273  :   // implements _mm_malloc/_mm_free based on the corresponding _aligned_
; 274  :   // functions. This may not always be the case and we just try to be safe.
; 275  :   #if defined(_MSC_VER) && (!defined(_WIN32_WCE)) && defined(_mm_free)
; 276  :     result = _aligned_realloc(ptr,new_size,16);
; 277  :   #else
; 278  :     result = generic_aligned_realloc(ptr,new_size,old_size);
; 279  :   #endif
; 280  : #elif defined(_MSC_VER) && (!defined(_WIN32_WCE))
; 281  :   result = _aligned_realloc(ptr,new_size,16);
; 282  : #else
; 283  :   result = handmade_aligned_realloc(ptr,new_size,old_size);
; 284  : #endif
; 285  : 
; 286  :   if (!result && new_size)
; 287  :     throw_std_bad_alloc();
; 288  : 
; 289  :   return result;
; 290  : }
; 291  : 
; 292  : /*****************************************************************************
; 293  : *** Implementation of conditionally aligned functions                      ***
; 294  : *****************************************************************************/
; 295  : 
; 296  : /** \internal Allocates \a size bytes. If Align is true, then the returned ptr is 16-byte-aligned.
; 297  :   * On allocation error, the returned pointer is null, and a std::bad_alloc is thrown.
; 298  :   */
; 299  : template<bool Align> inline void* conditional_aligned_malloc(size_t size)
; 300  : {
; 301  :   return aligned_malloc(size);
; 302  : }
; 303  : 
; 304  : template<> inline void* conditional_aligned_malloc<false>(size_t size)
; 305  : {
; 306  :   check_that_malloc_is_allowed();
; 307  : 
; 308  :   void *result = std::malloc(size);
; 309  :   if(!result && size)
; 310  :     throw_std_bad_alloc();
; 311  :   return result;
; 312  : }
; 313  : 
; 314  : /** \internal Frees memory allocated with conditional_aligned_malloc */
; 315  : template<bool Align> inline void conditional_aligned_free(void *ptr)
; 316  : {
; 317  :   aligned_free(ptr);
; 318  : }
; 319  : 
; 320  : template<> inline void conditional_aligned_free<false>(void *ptr)
; 321  : {
; 322  :   std::free(ptr);
; 323  : }
; 324  : 
; 325  : template<bool Align> inline void* conditional_aligned_realloc(void* ptr, size_t new_size, size_t old_size)
; 326  : {
; 327  :   return aligned_realloc(ptr, new_size, old_size);
; 328  : }
; 329  : 
; 330  : template<> inline void* conditional_aligned_realloc<false>(void* ptr, size_t new_size, size_t)
; 331  : {
; 332  :   return std::realloc(ptr, new_size);
; 333  : }
; 334  : 
; 335  : /*****************************************************************************
; 336  : *** Construction/destruction of array elements                             ***
; 337  : *****************************************************************************/
; 338  : 
; 339  : /** \internal Constructs the elements of an array.
; 340  :   * The \a size parameter tells on how many objects to call the constructor of T.
; 341  :   */
; 342  : template<typename T> inline T* construct_elements_of_array(T *ptr, size_t size)
; 343  : {
; 344  :   for (size_t i=0; i < size; ++i) ::new (ptr + i) T;
; 345  :   return ptr;
; 346  : }
; 347  : 
; 348  : /** \internal Destructs the elements of an array.
; 349  :   * The \a size parameters tells on how many objects to call the destructor of T.
; 350  :   */
; 351  : template<typename T> inline void destruct_elements_of_array(T *ptr, size_t size)
; 352  : {
; 353  :   // always destruct an array starting from the end.
; 354  :   if(ptr)
; 355  :     while(size) ptr[--size].~T();
; 356  : }
; 357  : 
; 358  : /*****************************************************************************
; 359  : *** Implementation of aligned new/delete-like functions                    ***
; 360  : *****************************************************************************/
; 361  : 
; 362  : template<typename T>
; 363  : EIGEN_ALWAYS_INLINE void check_size_for_overflow(size_t size)
; 364  : {
; 365  :   if(size > size_t(-1) / sizeof(T))

	cmp	r14, r13
	jbe	SHORT $LN93@getAf

; 366  :     throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN93@getAf:

; 422  :   check_size_for_overflow<T>(size);
; 423  :   T *result = reinterpret_cast<T*>(conditional_aligned_malloc<Align>(sizeof(T)*size));

	lea	rsi, QWORD PTR [r14*8]

; 220  :     result = std::malloc(size);

	mov	rcx, rsi
	call	QWORD PTR __imp_malloc
	mov	rcx, rax

; 221  :   #elif EIGEN_HAS_POSIX_MEMALIGN
; 222  :     if(posix_memalign(&result, 16, size)) result = 0;
; 223  :   #elif EIGEN_HAS_MM_MALLOC
; 224  :     result = _mm_malloc(size, 16);
; 225  :   #elif defined(_MSC_VER) && (!defined(_WIN32_WCE))
; 226  :     result = _aligned_malloc(size, 16);
; 227  :   #else
; 228  :     result = handmade_aligned_malloc(size);
; 229  :   #endif
; 230  : 
; 231  :   if(!result && size)

	test	rax, rax
	jne	SHORT $LN91@getAf
	test	rsi, rsi
	je	SHORT $LN91@getAf

; 232  :     throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN91@getAf:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 310  :     { EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN }

	mov	QWORD PTR Af$[rbp-121], rcx
	mov	QWORD PTR Af$[rbp-113], r14

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rax, QWORD PTR [r15]
	mov	rsi, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	mov	r12, 9223372036854775807		; 7fffffffffffffffH
	test	rsi, rsi
	je	SHORT $LN735@getAf
	cmp	rsi, r12
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN152@getAf

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN152@getAf:

; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rsi, rsi
$LN735@getAf:
	jns	SHORT $LN249@getAf
	mov	r8d, 241				; 000000f1H
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	call	QWORD PTR __imp__wassert
	mov	r14, QWORD PTR Af$[rbp-113]
	mov	rcx, QWORD PTR Af$[rbp-121]
$LN249@getAf:

; 44   :                : (rows > max_index / cols);

	test	rsi, rsi
	je	SHORT $LN256@getAf
	cmp	rsi, r12
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN256@getAf

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN256@getAf:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 322  :       if(size != m_rows*_Cols)

	cmp	rsi, r14
	je	SHORT $LN261@getAf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 325  :         if (size)

	test	rsi, rsi
	je	SHORT $LN262@getAf

; 326  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

	mov	rcx, rsi
	call	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
	mov	QWORD PTR Af$[rbp-121], rax

; 327  :         else

	jmp	SHORT $LN261@getAf
$LN262@getAf:

; 328  :           m_data = 0;

	mov	QWORD PTR Af$[rbp-121], rdi
$LN261@getAf:

; 329  :         EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN
; 330  :       }
; 331  :       m_rows = nbRows;

	mov	QWORD PTR Af$[rbp-113], rsi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h

; 284  :   other.derived().evalTo(derived());

	lea	rdx, QWORD PTR Af$[rbp-121]
	mov	rcx, r15
	call	??$evalTo@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEBAXAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@@Z ; Eigen::ProductBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const > >::evalTo<Eigen::Matrix<double,-1,1,0,-1,1> >
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR $T4[rbp-89]
	call	QWORD PTR __imp_free

; 420  :   if(size==0)

	mov	rsi, QWORD PTR Af$[rbp-113]
	test	rsi, rsi
	jne	SHORT $LN407@getAf

; 421  :     return 0; // short-cut. Also fixes Bug 884

	mov	rax, rdi
	jmp	SHORT $LN408@getAf
$LN407@getAf:

; 244  :   #elif EIGEN_HAS_POSIX_MEMALIGN
; 245  :     std::free(ptr);
; 246  :   #elif EIGEN_HAS_MM_MALLOC
; 247  :     _mm_free(ptr);
; 248  :   #elif defined(_MSC_VER) && (!defined(_WIN32_WCE))
; 249  :     _aligned_free(ptr);
; 250  :   #else
; 251  :     handmade_aligned_free(ptr);
; 252  :   #endif
; 253  : }
; 254  : 
; 255  : /**
; 256  : * \internal
; 257  : * \brief Reallocates an aligned block of memory.
; 258  : * \throws std::bad_alloc on allocation failure
; 259  : **/
; 260  : inline void* aligned_realloc(void *ptr, size_t new_size, size_t old_size)
; 261  : {
; 262  :   EIGEN_UNUSED_VARIABLE(old_size);
; 263  : 
; 264  :   void *result;
; 265  : #if !EIGEN_ALIGN
; 266  :   result = std::realloc(ptr,new_size);
; 267  : #elif EIGEN_MALLOC_ALREADY_ALIGNED
; 268  :   result = std::realloc(ptr,new_size);
; 269  : #elif EIGEN_HAS_POSIX_MEMALIGN
; 270  :   result = generic_aligned_realloc(ptr,new_size,old_size);
; 271  : #elif EIGEN_HAS_MM_MALLOC
; 272  :   // The defined(_mm_free) is just here to verify that this MSVC version
; 273  :   // implements _mm_malloc/_mm_free based on the corresponding _aligned_
; 274  :   // functions. This may not always be the case and we just try to be safe.
; 275  :   #if defined(_MSC_VER) && (!defined(_WIN32_WCE)) && defined(_mm_free)
; 276  :     result = _aligned_realloc(ptr,new_size,16);
; 277  :   #else
; 278  :     result = generic_aligned_realloc(ptr,new_size,old_size);
; 279  :   #endif
; 280  : #elif defined(_MSC_VER) && (!defined(_WIN32_WCE))
; 281  :   result = _aligned_realloc(ptr,new_size,16);
; 282  : #else
; 283  :   result = handmade_aligned_realloc(ptr,new_size,old_size);
; 284  : #endif
; 285  : 
; 286  :   if (!result && new_size)
; 287  :     throw_std_bad_alloc();
; 288  : 
; 289  :   return result;
; 290  : }
; 291  : 
; 292  : /*****************************************************************************
; 293  : *** Implementation of conditionally aligned functions                      ***
; 294  : *****************************************************************************/
; 295  : 
; 296  : /** \internal Allocates \a size bytes. If Align is true, then the returned ptr is 16-byte-aligned.
; 297  :   * On allocation error, the returned pointer is null, and a std::bad_alloc is thrown.
; 298  :   */
; 299  : template<bool Align> inline void* conditional_aligned_malloc(size_t size)
; 300  : {
; 301  :   return aligned_malloc(size);
; 302  : }
; 303  : 
; 304  : template<> inline void* conditional_aligned_malloc<false>(size_t size)
; 305  : {
; 306  :   check_that_malloc_is_allowed();
; 307  : 
; 308  :   void *result = std::malloc(size);
; 309  :   if(!result && size)
; 310  :     throw_std_bad_alloc();
; 311  :   return result;
; 312  : }
; 313  : 
; 314  : /** \internal Frees memory allocated with conditional_aligned_malloc */
; 315  : template<bool Align> inline void conditional_aligned_free(void *ptr)
; 316  : {
; 317  :   aligned_free(ptr);
; 318  : }
; 319  : 
; 320  : template<> inline void conditional_aligned_free<false>(void *ptr)
; 321  : {
; 322  :   std::free(ptr);
; 323  : }
; 324  : 
; 325  : template<bool Align> inline void* conditional_aligned_realloc(void* ptr, size_t new_size, size_t old_size)
; 326  : {
; 327  :   return aligned_realloc(ptr, new_size, old_size);
; 328  : }
; 329  : 
; 330  : template<> inline void* conditional_aligned_realloc<false>(void* ptr, size_t new_size, size_t)
; 331  : {
; 332  :   return std::realloc(ptr, new_size);
; 333  : }
; 334  : 
; 335  : /*****************************************************************************
; 336  : *** Construction/destruction of array elements                             ***
; 337  : *****************************************************************************/
; 338  : 
; 339  : /** \internal Constructs the elements of an array.
; 340  :   * The \a size parameter tells on how many objects to call the constructor of T.
; 341  :   */
; 342  : template<typename T> inline T* construct_elements_of_array(T *ptr, size_t size)
; 343  : {
; 344  :   for (size_t i=0; i < size; ++i) ::new (ptr + i) T;
; 345  :   return ptr;
; 346  : }
; 347  : 
; 348  : /** \internal Destructs the elements of an array.
; 349  :   * The \a size parameters tells on how many objects to call the destructor of T.
; 350  :   */
; 351  : template<typename T> inline void destruct_elements_of_array(T *ptr, size_t size)
; 352  : {
; 353  :   // always destruct an array starting from the end.
; 354  :   if(ptr)
; 355  :     while(size) ptr[--size].~T();
; 356  : }
; 357  : 
; 358  : /*****************************************************************************
; 359  : *** Implementation of aligned new/delete-like functions                    ***
; 360  : *****************************************************************************/
; 361  : 
; 362  : template<typename T>
; 363  : EIGEN_ALWAYS_INLINE void check_size_for_overflow(size_t size)
; 364  : {
; 365  :   if(size > size_t(-1) / sizeof(T))

	cmp	rsi, r13
	jbe	SHORT $LN410@getAf

; 366  :     throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN410@getAf:

; 422  :   check_size_for_overflow<T>(size);
; 423  :   T *result = reinterpret_cast<T*>(conditional_aligned_malloc<Align>(sizeof(T)*size));

	lea	r14, QWORD PTR [rsi*8]

; 220  :     result = std::malloc(size);

	mov	rcx, r14
	call	QWORD PTR __imp_malloc

; 221  :   #elif EIGEN_HAS_POSIX_MEMALIGN
; 222  :     if(posix_memalign(&result, 16, size)) result = 0;
; 223  :   #elif EIGEN_HAS_MM_MALLOC
; 224  :     result = _mm_malloc(size, 16);
; 225  :   #elif defined(_MSC_VER) && (!defined(_WIN32_WCE))
; 226  :     result = _aligned_malloc(size, 16);
; 227  :   #else
; 228  :     result = handmade_aligned_malloc(size);
; 229  :   #endif
; 230  : 
; 231  :   if(!result && size)

	test	rax, rax
	jne	SHORT $LN408@getAf
	test	r14, r14
	je	SHORT $LN408@getAf

; 232  :     throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN408@getAf:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 235  :     { EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN }

	mov	QWORD PTR [rbx], rax
	mov	QWORD PTR [rbx+8], rsi
	mov	QWORD PTR [rbx+16], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	test	rsi, rsi
	je	SHORT $LN459@getAf
	cmp	rsi, r12
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN459@getAf

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN459@getAf:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 313  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	r14, rsi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rsi, rsi
	jns	SHORT $LN564@getAf
	mov	r8d, 241				; 000000f1H
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	call	QWORD PTR __imp__wassert
	mov	rsi, QWORD PTR Af$[rbp-113]
$LN564@getAf:

; 44   :                : (rows > max_index / cols);

	test	r14, r14
	je	SHORT $LN571@getAf
	cmp	r14, r12
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN571@getAf

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN571@getAf:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 249  :       if(size != m_rows*m_cols)

	mov	rax, QWORD PTR [rbx+16]
	imul	rax, QWORD PTR [rbx+8]
	cmp	r14, rax
	je	SHORT $LN576@getAf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR [rbx]
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 252  :         if (size)

	test	r14, r14
	je	SHORT $LN577@getAf

; 253  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

	mov	rcx, r14
	call	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
	mov	QWORD PTR [rbx], rax

; 254  :         else

	jmp	SHORT $LN738@getAf
$LN577@getAf:

; 255  :           m_data = 0;

	mov	QWORD PTR [rbx], rdi
$LN738@getAf:
	mov	rsi, QWORD PTR Af$[rbp-113]
$LN576@getAf:

; 256  :         EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN
; 257  :       }
; 258  :       m_rows = nbRows;

	mov	QWORD PTR [rbx+8], r14

; 259  :       m_cols = nbCols;

	mov	QWORD PTR [rbx+16], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	cmp	r14, rsi
	je	SHORT $LN600@getAf
	mov	r8d, 498				; 000001f2H
	lea	rdx, OFFSET FLAT:??_C@_1KO@HDGCFKMN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GC@PBCDNLIH@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ@
	call	QWORD PTR __imp__wassert
$LN600@getAf:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 240  :     inline DenseIndex cols(void) const {return m_cols;}

	mov	r9, QWORD PTR [rbx+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 49   :   inline Index size() const { return rows() * cols(); }

	imul	r9, QWORD PTR [rbx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 404  :     const Index alignedEnd = alignedStart + ((size-alignedStart)/packetSize)*packetSize;

	mov	rax, r9
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r8, rax
	add	r8, r8

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	test	r8, r8
	jle	SHORT $LN637@getAf
$LL639@getAf:
	mov	rax, QWORD PTR Af$[rbp-121]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 220  : template<> EIGEN_STRONG_INLINE Packet2d pload<Packet2d>(const double*  from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_pd(from); }

	movaps	xmm0, XMMWORD PTR [rax+rdi*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 262  :     inline T *data() { return m_data; }

	mov	rax, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [rax+rdi*8], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	add	rdi, 2
	cmp	rdi, r8
	jl	SHORT $LL639@getAf
$LN637@getAf:

; 409  :     {
; 410  :       dst.template copyPacket<Derived2, dstAlignment, srcAlignment>(index, src);
; 411  :     }
; 412  : 
; 413  :     unaligned_assign_impl<>::run(src,dst,alignedEnd,size);

	mov	rdx, rbx
	lea	rcx, QWORD PTR Af$[rbp-121]
	call	??$run@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@@?$unaligned_assign_impl@$0A@@internal@Eigen@@SAXAEBV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@_J2@Z ; Eigen::internal::unaligned_assign_impl<0>::run<Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Matrix<double,-1,-1,0,-1,-1> >
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR Af$[rbp-121]
	call	QWORD PTR __imp_free
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 262  : 	return Af;

	mov	rax, rbx

; 263  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-121]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+240]
	add	rsp, 160				; 000000a0H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN734@getAf:
?getAf@Tikhonov2D@@QEBA?AV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@XZ ENDP ; Tikhonov2D::getAf
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
__$ReturnUdt$GSCopy$ = 40
$T2 = 48
$T3 = 56
$T4 = 80
$T5 = 80
Af$ = 128
__$ArrayPad$ = 144
this$ = 224
__$ReturnUdt$ = 232
?dtor$0@?0??getAf@Tikhonov2D@@QEBA?AV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@XZ@4HA PROC ; `Tikhonov2D::getAf'::`1'::dtor$0
	lea	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@QEAA@XZ
?dtor$0@?0??getAf@Tikhonov2D@@QEBA?AV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@XZ@4HA ENDP ; `Tikhonov2D::getAf'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
__$ReturnUdt$GSCopy$ = 40
$T2 = 48
$T3 = 56
$T4 = 80
$T5 = 80
Af$ = 128
__$ArrayPad$ = 144
this$ = 224
__$ReturnUdt$ = 232
?dtor$3@?0??getAf@Tikhonov2D@@QEBA?AV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@XZ@4HA PROC ; `Tikhonov2D::getAf'::`1'::dtor$3
	lea	rcx, QWORD PTR Af$[rdx]
	jmp	??1?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAA@XZ
?dtor$3@?0??getAf@Tikhonov2D@@QEBA?AV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@XZ@4HA ENDP ; `Tikhonov2D::getAf'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
__$ReturnUdt$GSCopy$ = 40
$T2 = 48
$T3 = 56
$T4 = 80
$T5 = 80
Af$ = 128
__$ArrayPad$ = 144
this$ = 224
__$ReturnUdt$ = 232
?dtor$1@?0??getAf@Tikhonov2D@@QEBA?AV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@XZ@4HA PROC ; `Tikhonov2D::getAf'::`1'::dtor$1
	lea	rcx, QWORD PTR Af$[rdx]
	jmp	??1?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@XZ
?dtor$1@?0??getAf@Tikhonov2D@@QEBA?AV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@XZ@4HA ENDP ; `Tikhonov2D::getAf'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
__$ReturnUdt$GSCopy$ = 40
$T2 = 48
$T3 = 56
$T4 = 80
$T5 = 80
Af$ = 128
__$ArrayPad$ = 144
this$ = 224
__$ReturnUdt$ = 232
?dtor$5@?0??getAf@Tikhonov2D@@QEBA?AV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@XZ@4HA PROC ; `Tikhonov2D::getAf'::`1'::dtor$5
	mov	rcx, QWORD PTR __$ReturnUdt$GSCopy$[rdx]
	jmp	??1?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAA@XZ
?dtor$5@?0??getAf@Tikhonov2D@@QEBA?AV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@XZ@4HA ENDP ; `Tikhonov2D::getAf'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\igor\igoritx.hpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\igor\igoritx.hpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\igor\igoritx.hpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\igor\igoritx.hpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\igor\igoritx.hpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\igor\igoritx.hpp
;	COMDAT ?open@IGORdata@@YA_NAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@W4OpenCondition@1@@Z
_TEXT	SEGMENT
$T1 = 40
filename$GSCopy$ = 72
__$ArrayPad$ = 80
ofs$ = 128
filename$ = 136
open_condition$dead$ = 144
?open@IGORdata@@YA_NAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@W4OpenCondition@1@@Z PROC ; IGORdata::open, COMDAT

; 117  : 	{

	mov	r11, rsp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 96					; 00000060H
	mov	QWORD PTR [r11-88], -2
	mov	QWORD PTR [r11+24], rbx
	mov	QWORD PTR [r11+32], rbp
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rsi, rdx
	mov	rbx, rcx
	mov	QWORD PTR [r11-48], rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [rdx+24], 16
	jb	SHORT $LN21@open
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rdx, QWORD PTR [rdx]
$LN21@open:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\fstream

; 1077 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)

	mov	r8d, 2
	add	rcx, 8
	call	?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open

; 1078 : 			_Myios::setstate(ios_base::failbit);

	xor	r8d, r8d

; 1077 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)

	test	rax, rax

; 1078 : 			_Myios::setstate(ios_base::failbit);

	mov	rax, QWORD PTR [rbx]
	movsxd	rcx, DWORD PTR [rax+4]

; 1077 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)

	jne	SHORT $LN25@open

; 1078 : 			_Myios::setstate(ios_base::failbit);

	add	rcx, rbx
	lea	edx, QWORD PTR [r8+2]
	call	QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z

; 1079 : 		else

	jmp	SHORT $LN328@open
$LN25@open:

; 1080 : 			_Myios::clear();	// added with C++11

	add	rcx, rbx
	xor	edx, edx
	call	QWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
$LN328@open:

; 259  : 		return (_Myfile != 0);

	xor	r14d, r14d
	cmp	QWORD PTR [rbx+152], r14
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\igor\igoritx.hpp

; 120  : 			while(!ofs.is_open()){

	jne	$LN5@open
	npad	10
$LL6@open:

; 121  : 				std::cerr << "!!!   file: " + filename << " cannot be opened" << std::endl;

	mov	r8, rsi
	lea	rdx, OFFSET FLAT:??_C@_0N@EFOAPBHM@?$CB?$CB?$CB?5?5?5file?3?5?$AA@
	lea	rcx, QWORD PTR $T1[rsp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PEBDAEBV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rdx, rax
	mov	rcx, QWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??_C@_0BC@JLEGLJEO@?5cannot?5be?5opened?$AA@
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T1[rsp+24], 16
	jb	SHORT $LN52@open
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR $T1[rsp]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN52@open:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\igor\igoritx.hpp

; 122  : 				std::cerr << "!!!   ---  press return for retry ---		 !!!" << std::endl;

	lea	rdx, OFFSET FLAT:??_C@_0CM@OGLPBFKE@?$CB?$CB?$CB?5?5?5?9?9?9?5?5press?5return?5for?5retr@
	mov	rcx, QWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 123  : 				getchar();

	call	QWORD PTR __imp_getchar
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\fstream

; 337  : 		if (_Myfile == 0)

	cmp	QWORD PTR [rbx+152], 0
	jne	SHORT $LN70@open

; 338  : 			_Ans = 0;

	mov	rbp, r14

; 339  : 		else

	jmp	SHORT $LN67@open
$LN70@open:

; 340  : 			{	// put any homing sequence and close file
; 341  : 			if (!_Endwrite())

	lea	rcx, QWORD PTR [rbx+8]
	call	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
	lea	rbp, QWORD PTR [rbx+8]
	test	al, al
	cmove	rbp, r14

; 342  : 				_Ans = 0;
; 343  : 			if (fclose(_Myfile) != 0)

	mov	rcx, QWORD PTR [rbx+152]
	call	QWORD PTR __imp_fclose
	test	eax, eax
	cmovne	rbp, r14
$LN67@open:

; 344  : 				_Ans = 0;
; 345  : 			}
; 346  : 		_Init(0, _Closefl);
; 347  : 		return (_Ans);
; 348  : 		}
; 349  : 
; 350  : 	virtual void __CLR_OR_THIS_CALL _Lock()
; 351  : 		{	// lock file instead of stream buffer
; 352  : 		if (_Myfile)
; 353  : 			_CSTD _lock_file(_Myfile);
; 354  : 		}
; 355  : 
; 356  : 	virtual void __CLR_OR_THIS_CALL _Unlock()
; 357  : 		{	// unlock file instead of stream buffer
; 358  : 		if (_Myfile)
; 359  : 			_CSTD _unlock_file(_Myfile);
; 360  : 		}
; 361  : 
; 362  : protected:
; 363  : 	virtual int_type __CLR_OR_THIS_CALL overflow(int_type _Meta =
; 364  : 		_Traits::eof())
; 365  : 		{	// put an element to stream
; 366  : 		if (_Traits::eq_int_type(_Traits::eof(), _Meta))
; 367  : 			return (_Traits::not_eof(_Meta));	// EOF, return success code
; 368  : 		else if (_Mysb::pptr() != 0
; 369  : 			&& _Mysb::pptr() < _Mysb::epptr())
; 370  : 			{	// room in buffer, store it
; 371  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);
; 372  : 			return (_Meta);
; 373  : 			}
; 374  : 		else if (_Myfile == 0)
; 375  : 			return (_Traits::eof());	// no open C stream, fail
; 376  : 		_Reset_back();	// revert from _Mychar buffer
; 377  : 		if (_Pcvt == 0)
; 378  : 			return (_Fputc(_Traits::to_char_type(_Meta), _Myfile)
; 379  : 				? _Meta : _Traits::eof());	// no codecvt facet, put as is
; 380  : 		else
; 381  : 			{	// put using codecvt facet
; 382  : 			const int _STRING_INC = 8;
; 383  : 			const _Elem _Ch = _Traits::to_char_type(_Meta);
; 384  : 			const _Elem *_Src;
; 385  : 			char *_Dest;
; 386  : 
; 387  : 			string _Str(_STRING_INC, '\0');
; 388  : 			for (; ; )
; 389  : 				switch (_Pcvt->out(_State,
; 390  : 					&_Ch, &_Ch + 1, _Src,
; 391  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))
; 392  : 				{	// test result of converting one element
; 393  : 				case codecvt_base::partial:
; 394  : 				case codecvt_base::ok:
; 395  : 					{	// converted something, try to put it out
; 396  : 					size_t _Count = _Dest - &*_Str.begin();
; 397  : 					if (0 < _Count && _Count !=
; 398  : 						fwrite(&*_Str.begin(), 1, _Count, _Myfile))
; 399  : 						return (_Traits::eof());	// write failed
; 400  : 
; 401  : 					_Wrotesome = true;	// write succeeded
; 402  : 					if (_Src != &_Ch)
; 403  : 						return (_Meta);	// converted whole element
; 404  : 
; 405  : 					if (0 < _Count)
; 406  : 						;
; 407  : 					else if (_Str.size() < 4 * _STRING_INC)
; 408  : 						_Str.append(_STRING_INC, '\0');	// try with more space
; 409  : 					else
; 410  : 						return (_Traits::eof());	// conversion failed
; 411  : 					break;
; 412  : 					}
; 413  : 
; 414  : 				case codecvt_base::noconv:
; 415  : 					return (_Fputc(_Ch, _Myfile) ? _Meta
; 416  : 						: _Traits::eof());	// no conversion, put as is
; 417  : 
; 418  : 				default:
; 419  : 					return (_Traits::eof());	// conversion failed
; 420  : 				}
; 421  : 			}
; 422  : 	}
; 423  : 
; 424  : 	virtual int_type __CLR_OR_THIS_CALL pbackfail(int_type _Meta =
; 425  : 		_Traits::eof())
; 426  : 		{	// put an element back to stream
; 427  : 		if (_Mysb::gptr() != 0
; 428  : 			&& _Mysb::eback() < _Mysb::gptr()
; 429  : 			&& (_Traits::eq_int_type(_Traits::eof(), _Meta)
; 430  : 			|| _Traits::eq_int_type(_Traits::to_int_type(_Mysb::gptr()[-1]),
; 431  : 				_Meta)))
; 432  : 			{	// just back up position
; 433  : 			_Mysb::_Gndec();
; 434  : 			return (_Traits::not_eof(_Meta));
; 435  : 			}
; 436  : 		else if (_Myfile == 0 || _Traits::eq_int_type(_Traits::eof(), _Meta))
; 437  : 			return (_Traits::eof());	// no open C stream or EOF, fail
; 438  : 		else if (_Pcvt == 0 && _Ungetc(_Traits::to_char_type(_Meta), _Myfile))
; 439  : 			return (_Meta);	// no facet and unget succeeded, return
; 440  : 		else if (_Mysb::gptr() != &_Mychar)
; 441  : 			{	// putback to _Mychar
; 442  : 			_Mychar = _Traits::to_char_type(_Meta);
; 443  : 			_Set_back();	// switch to _Mychar buffer
; 444  : 			return (_Meta);
; 445  : 			}
; 446  : 		else
; 447  : 			return (_Traits::eof());	// nowhere to put back
; 448  : 	}
; 449  : 
; 450  : 	virtual int_type __CLR_OR_THIS_CALL underflow()
; 451  : 		{	// get an element from stream, but don't point past it
; 452  : 		int_type _Meta;
; 453  : 		if (_Mysb::gptr() != 0
; 454  : 			&& _Mysb::gptr() < _Mysb::egptr())
; 455  : 			return (_Traits::to_int_type(*_Mysb::gptr()));	// return buffered
; 456  : 		else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))
; 457  : 			return (_Meta);	// uflow failed, return EOF
; 458  : 		else
; 459  : 			{	// get a char, don't point past it
; 460  : 			pbackfail(_Meta);
; 461  : 			return (_Meta);
; 462  : 			}
; 463  : 		}
; 464  : 
; 465  : 	virtual int_type __CLR_OR_THIS_CALL uflow()
; 466  : 		{	// get an element from stream, point past it
; 467  : 		if (_Mysb::gptr() != 0
; 468  : 			&& _Mysb::gptr() < _Mysb::egptr())
; 469  : 			return (_Traits::to_int_type(
; 470  : 				*_Mysb::_Gninc()));	// return buffered
; 471  : 		else if (_Myfile == 0)
; 472  : 			return (_Traits::eof());	// no open C stream, fail
; 473  : 		_Reset_back();	// revert from _Mychar buffer
; 474  : 		if (_Pcvt == 0)
; 475  : 			{	// no codecvt facet, just get it
; 476  : 			_Elem _Ch = 0;
; 477  : 			return (_Fgetc(_Ch, _Myfile) ? _Traits::to_int_type(_Ch)
; 478  : 				: _Traits::eof());
; 479  : 			}
; 480  : 		else
; 481  : 			{	// build string until codecvt succeeds
; 482  : 			string _Str;
; 483  : 
; 484  : 			for (; ; )
; 485  : 				{	// get using codecvt facet
; 486  : 				_Elem _Ch, *_Dest;
; 487  : 				const char *_Src;
; 488  : 				int _Nleft;
; 489  : 				int _Meta = fgetc(_Myfile);
; 490  : 
; 491  : 				if (_Meta == EOF)
; 492  : 					return (_Traits::eof());	// partial char?
; 493  : 
; 494  : 				_Str.append(1, (char)_Meta);	// append byte and convert
; 495  : 				switch (_Pcvt->in(_State,
; 496  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Src,
; 497  : 					&_Ch, &_Ch + 1, _Dest))
; 498  : 					{	// test result of converting one element
; 499  : 				case codecvt_base::partial:
; 500  : 				case codecvt_base::ok:
; 501  : 					if (_Dest != &_Ch)
; 502  : 						{	// got an element, put back excess and deliver it
; 503  : 						_Nleft = (int)(&*_Str.begin() + _Str.size() - _Src);
; 504  : 						for (; 0 < _Nleft; )
; 505  : 							ungetc(_Src[--_Nleft], _Myfile);
; 506  : 						return (_Traits::to_int_type(_Ch));
; 507  : 						}
; 508  : 					else
; 509  : 						_Str.erase((size_t)0,	// partial, discard used input
; 510  : 							(size_t)(_Src - &*_Str.begin()));
; 511  : 					break;
; 512  : 
; 513  : 				case codecvt_base::noconv:
; 514  : 					if (_Str.size() < sizeof (_Elem))
; 515  : 						break;	// no conversion, but need more chars
; 516  : 
; 517  : 					_CRT_SECURE_MEMCPY(&_Ch, sizeof (_Elem), &*_Str.begin(),
; 518  : 						sizeof (_Elem));	// copy raw bytes to element
; 519  : 
; 520  : 					return (_Traits::to_int_type(_Ch));	// return result
; 521  : 
; 522  : 				default:
; 523  : 					return (_Traits::eof());	// conversion failed
; 524  : 					}
; 525  : 				}
; 526  : 			}
; 527  : 		}
; 528  : 
; 529  : 	virtual pos_type __CLR_OR_THIS_CALL seekoff(off_type _Off,
; 530  : 		ios_base::seekdir _Way,
; 531  : 		ios_base::openmode =
; 532  : 			(ios_base::openmode)(ios_base::in | ios_base::out))
; 533  : 		{	// change position by _Off
; 534  : 		fpos_t _Fileposition;
; 535  : 
; 536  : 		if (_Mysb::gptr() == &_Mychar	// something putback
; 537  : 			&& _Way == ios_base::cur	// a relative seek
; 538  : 			&& _Pcvt == 0)	// not converting
; 539  : 			_Off -= (off_type)sizeof (_Elem);	// back up over _Elem bytes
; 540  : 
; 541  : 		if (_Myfile == 0 || !_Endwrite()
; 542  : 			|| ((_Off != 0 || _Way != ios_base::cur)
; 543  : 				&& _FSEEK_OFF(_Myfile, _Off, _Way) != 0)
; 544  : 			|| fgetpos(_Myfile, &_Fileposition) != 0)
; 545  : 			return (pos_type(_BADOFF));	// report failure
; 546  : 
; 547  : 		_Reset_back();	// revert from _Mychar buffer, discarding any putback
; 548  : 		return (_POS_TYPE_FROM_STATE(pos_type, _State,
; 549  : 			_Fileposition));	// return new position
; 550  : 		}
; 551  : 
; 552  : 	virtual pos_type __CLR_OR_THIS_CALL seekpos(pos_type _Pos,
; 553  : 		ios_base::openmode =
; 554  : 			(ios_base::openmode)(ios_base::in | ios_base::out))
; 555  : 		{	// change position to _Pos
; 556  : 		fpos_t _Fileposition = _POS_TYPE_TO_FPOS_T(_Pos);
; 557  : 		off_type _Off = (off_type)_Pos - (off_type)_FPOSOFF(_Fileposition);
; 558  : 
; 559  : 		if (_Myfile == 0 || !_Endwrite()
; 560  : 			|| fsetpos(_Myfile, &_Fileposition) != 0
; 561  : 			|| (_Off != 0 && _FSEEK_OFF(_Myfile, _Off, SEEK_CUR) != 0)
; 562  : 			|| fgetpos(_Myfile, &_Fileposition) != 0)
; 563  : 			return (pos_type(_BADOFF));	// report failure
; 564  : 
; 565  : 		_State = _POS_TYPE_TO_STATE(_Pos);
; 566  : 
; 567  : 		_Reset_back();	// revert from _Mychar buffer, discarding any putback
; 568  : 		return (_POS_TYPE_FROM_STATE(pos_type, _State,
; 569  : 			_Fileposition));	// return new position
; 570  : 		}
; 571  : 
; 572  : 	virtual _Mysb *__CLR_OR_THIS_CALL setbuf(_Elem *_Buffer, streamsize _Count)
; 573  : 		{	// offer _Buffer to C stream
; 574  : 		if (_Myfile == 0 || setvbuf(_Myfile, (char *)_Buffer,
; 575  : 			_Buffer == 0 && _Count == 0 ? _IONBF : _IOFBF,
; 576  : 			(size_t)_Count * sizeof (_Elem)) != 0)
; 577  : 			return (0);	// failed
; 578  : 		else
; 579  : 			{	// new buffer, reinitialize pointers
; 580  : 			_Init(_Myfile, _Openfl);
; 581  : 			return (this);
; 582  : 			}
; 583  : 		}
; 584  : 
; 585  : 	virtual int __CLR_OR_THIS_CALL sync()
; 586  : 		{	// synchronize C stream with external file
; 587  : 		return (_Myfile == 0
; 588  : 			|| _Traits::eq_int_type(_Traits::eof(), overflow())
; 589  : 			|| 0 <= fflush(_Myfile) ? 0 : -1);
; 590  : 		}
; 591  : 
; 592  : 	virtual void __CLR_OR_THIS_CALL imbue(const locale& _Loc)
; 593  : 		{	// set locale to argument (capture nontrivial codecvt facet)
; 594  : 		_Initcvt(&_USE(_Loc, _Cvt));
; 595  : 		}
; 596  : 
; 597  : 	void _Init(_Filet *_File, _Initfl _Which)
; 598  : 		{	// initialize to C stream _File after {new, open, close}
; 599  : 		__PURE_APPDOMAIN_GLOBAL static _Myst _Stinit;	// initial state
; 600  : 
; 601  : 		_Closef = _Which == _Openfl;

	mov	BYTE PTR [rbx+144], 0

; 602  : 		_Wrotesome = false;

	mov	BYTE PTR [rbx+137], 0

; 603  : 
; 604  : 		_Mysb::_Init();	// initialize stream buffer base object

	lea	rcx, QWORD PTR [rbx+8]
	call	QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 605  : 
; 606  :  #ifndef _IORCNT
; 607  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 608  :   #define _IOWCNT _IOCNT
; 609  :  #endif /* _IORCNT */
; 610  : 
; 611  :   #pragma warning(push)
; 612  :   #pragma warning(disable: 6240)	/* prefast noise VSW 489858 */
; 613  : 		if (_File != 0 && sizeof (_Elem) == 1)
; 614  :   #pragma warning(pop)
; 615  : 
; 616  : 			{	// point inside C stream with [first, first + count) buffer
; 617  : 			_Elem **_Pb = (_Elem **)&_File->_IOBASE;
; 618  : 			_Elem **_Pn = (_Elem **)&_File->_IOPTR;
; 619  : 			int *_Nr = (int *)&_File->_IORCNT;
; 620  : 			int *_Nw = (int *)&_File->_IOWCNT;
; 621  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 622  : 			}
; 623  : 
; 624  : 		_Myfile = _File;

	mov	QWORD PTR [rbx+152], r14

; 625  : 		_State = _Stinit;

	mov	eax, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4HA ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
	mov	DWORD PTR [rbx+140], eax

; 626  : 		_Pcvt = 0;	// pointer to codecvt facet

	mov	QWORD PTR [rbx+128], r14

; 1081 : 		}
; 1082 : 
; 1083 : 	void open(const string& _Str,
; 1084 : 		ios_base::openmode _Mode = ios_base::out,
; 1085 : 		int _Prot = (int)ios_base::_Openprot)
; 1086 : 		{	// open a C stream with specified mode
; 1087 : 		open(_Str.c_str(), _Mode, _Prot);
; 1088 : 		}
; 1089 : 
; 1090 : 	void open(const char *_Filename, ios_base::open_mode _Mode)
; 1091 : 		{	// open a C stream with specified mode (old style)
; 1092 : 		open(_Filename, (ios_base::openmode)_Mode);
; 1093 : 		}
; 1094 : 
; 1095 : 	void close()
; 1096 : 		{	// close the C stream
; 1097 : 		if (_Filebuffer.close() == 0)

	test	rbp, rbp
	jne	SHORT $LN64@open

; 1098 : 			_Myios::setstate(ios_base::failbit);

	mov	rax, QWORD PTR [rbx]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rbx
	xor	r8d, r8d
	lea	edx, QWORD PTR [rbp+2]
	call	QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
$LN64@open:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\igor\igoritx.hpp

; 124  : 				ofs.close();ofs.clear();

	mov	rax, QWORD PTR [rbx]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rbx
	xor	r8d, r8d
	xor	edx, edx
	call	QWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z

; 125  : 				ofs.open(filename.c_str());

	mov	rcx, rsi
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\fstream

; 1077 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)

	mov	r8d, 2
	mov	rdx, rax
	lea	rcx, QWORD PTR [rbx+8]
	call	?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open

; 1078 : 			_Myios::setstate(ios_base::failbit);

	xor	r8d, r8d

; 1077 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)

	test	rax, rax

; 1078 : 			_Myios::setstate(ios_base::failbit);

	mov	rax, QWORD PTR [rbx]
	movsxd	rcx, DWORD PTR [rax+4]

; 1077 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)

	jne	SHORT $LN77@open

; 1078 : 			_Myios::setstate(ios_base::failbit);

	add	rcx, rbx
	lea	edx, QWORD PTR [r8+2]
	call	QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z

; 1079 : 		else

	jmp	SHORT $LN76@open
$LN77@open:

; 1080 : 			_Myios::clear();	// added with C++11

	add	rcx, rbx
	xor	edx, edx
	call	QWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
$LN76@open:

; 259  : 		return (_Myfile != 0);

	cmp	QWORD PTR [rbx+152], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\igor\igoritx.hpp

; 120  : 			while(!ofs.is_open()){

	je	$LL6@open
$LN5@open:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR [rsi+24], 16
	jb	SHORT $LN100@open
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR [rsi]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN100@open:
	mov	QWORD PTR [rsi+24], 15
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rsi+16], r14
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rsi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\igor\igoritx.hpp

; 127  : 			return true;

	mov	al, 1

; 128  : 		}
; 129  : 		else if(open_condition == Ignore){
; 130  : 			return true;
; 131  : 		}
; 132  : 		else if(open_condition == TryJapanese){
; 133  : 			std::locale default_locale;
; 134  : 			std::locale::global(std::locale("japanese"));
; 135  : 			ofs.open(filename.c_str());
; 136  : 			std::locale::global(default_locale);
; 137  : 			return ofs.is_open();
; 138  : 		}
; 139  : 		return false;
; 140  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+96]
	mov	rbx, QWORD PTR [r11+48]
	mov	rbp, QWORD PTR [r11+56]
	mov	rsp, r11
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
?open@IGORdata@@YA_NAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@W4OpenCondition@1@@Z ENDP ; IGORdata::open
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
filename$GSCopy$ = 72
__$ArrayPad$ = 80
ofs$ = 128
filename$ = 136
open_condition$dead$ = 144
?dtor$0@?0??open@IGORdata@@YA_NAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@W4OpenCondition@1@@Z@4HA PROC ; `IGORdata::open'::`1'::dtor$0
	mov	rcx, QWORD PTR filename$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??open@IGORdata@@YA_NAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@W4OpenCondition@1@@Z@4HA ENDP ; `IGORdata::open'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
filename$GSCopy$ = 72
__$ArrayPad$ = 80
ofs$ = 128
filename$ = 136
open_condition$dead$ = 144
?dtor$1@?0??open@IGORdata@@YA_NAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@W4OpenCondition@1@@Z@4HA PROC ; `IGORdata::open'::`1'::dtor$1
	lea	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??open@IGORdata@@YA_NAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@W4OpenCondition@1@@Z@4HA ENDP ; `IGORdata::open'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\lu\partialpivlu.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\misc\solve.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\matrix.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwiseunaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arraywrapper.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwiseunaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xfunctional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwiseunaryop.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
;	COMDAT ?updateF@Tikhonov2D@@AEAA_NNN@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 88
tmp$9 = 88
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 88
$T14 = 88
$T15 = 88
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 144
$T21 = 144
$T22 = 144
$T23 = 192
$T24 = 200
df$ = 272
Af$ = 288
__$ArrayPad$ = 304
this$ = 384
lambda$ = 392
relativeError0$ = 400
?updateF@Tikhonov2D@@AEAA_NNN@Z PROC			; Tikhonov2D::updateF, COMDAT

; 71   : (const double lambda, const double relativeError0){

$LN1533:
	mov	rax, rsp
	push	rbp
	push	rdi
	push	r12
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-120]
	sub	rsp, 336				; 00000150H
	mov	QWORD PTR $T23[rbp-256], -2
	mov	QWORD PTR [rax+24], rbx
	mov	QWORD PTR [rax+32], rsi
	movaps	XMMWORD PTR [rax-56], xmm6
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	movaps	xmm6, xmm2
	mov	r14, rcx

; 72   : 	setJandH(lambda*lambda, 0.0);

	mulsd	xmm1, xmm1
	xorps	xmm2, xmm2
	call	?setJandH@Tikhonov2D@@AEAA_NNN@Z	; Tikhonov2D::setJandH
	xor	eax, eax
	mov	QWORD PTR df$[rbp-256], rax
	mov	QWORD PTR df$[rbp-248], rax

; 76   : 	Eigen::VectorXd df = -Hff.lu().solve(Jf);

	lea	rcx, QWORD PTR [r14+328]
	lea	rdx, QWORD PTR $T24[rbp-256]
	call	?lu@?$MatrixBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA?BV?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@XZ ; Eigen::MatrixBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::lu
	mov	rbx, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\lu\partialpivlu.h

; 135  :       eigen_assert(m_isInitialized && "PartialPivLU is not initialized.");

	cmp	BYTE PTR [rax+64], 0
	jne	SHORT $LN26@updateF
	mov	r8d, 135				; 00000087H
	lea	rdx, OFFSET FLAT:??_C@_1LG@KJLFHBNJ@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GM@KOAFCMGF@?$AAm?$AA_?$AAi?$AAs?$AAI?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AAd?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAP?$AAa?$AAr?$AAt?$AAi?$AAa?$AAl?$AAP?$AAi?$AAv?$AAL?$AAU@
	call	QWORD PTR __imp__wassert
$LN26@updateF:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\misc\solve.h

; 42   :   {}

	mov	QWORD PTR $T15[rsp+8], rbx
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 76   : 	Eigen::VectorXd df = -Hff.lu().solve(Jf);

	lea	rax, QWORD PTR [r14+272]
	mov	QWORD PTR $T15[rsp+16], rax
	lea	rdx, QWORD PTR $T22[rbp-256]
	lea	rcx, QWORD PTR $T15[rsp+1]
	call	??G?$MatrixBase@V?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@Eigen@@@Eigen@@QEBA?BV?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@1@XZ ; Eigen::MatrixBase<Eigen::ReturnByValue<Eigen::internal::solve_retval_base<Eigen::PartialPivLU<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::Matrix<double,-1,1,0,-1,1> > > >::operator-
	npad	1
	xor	r15d, r15d
	test	rax, rax
	je	SHORT $LN5@updateF
	lea	rbx, QWORD PTR [rax+1]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	test	rbx, rbx
	je	SHORT $LN52@updateF
	lea	rsi, QWORD PTR [rbx-1]
	jmp	SHORT $LN53@updateF
$LN5@updateF:
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 76   : 	Eigen::VectorXd df = -Hff.lu().solve(Jf);

	mov	rbx, r15
$LN52@updateF:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	mov	rsi, r15
$LN53@updateF:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 313  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rsi, QWORD PTR [rsi+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	test	rbx, rbx
	lea	rax, QWORD PTR [rbx-1]
	jne	SHORT $LN65@updateF
	mov	rax, r15
$LN65@updateF:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\matrix.h

; 274  :     {

	mov	rax, QWORD PTR [rax+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 420  :   if(size==0)

	test	rax, rax
	jne	SHORT $LN90@updateF

; 421  :     return 0; // short-cut. Also fixes Bug 884

	mov	rax, r15
	jmp	SHORT $LN91@updateF
$LN90@updateF:

; 244  :   #elif EIGEN_HAS_POSIX_MEMALIGN
; 245  :     std::free(ptr);
; 246  :   #elif EIGEN_HAS_MM_MALLOC
; 247  :     _mm_free(ptr);
; 248  :   #elif defined(_MSC_VER) && (!defined(_WIN32_WCE))
; 249  :     _aligned_free(ptr);
; 250  :   #else
; 251  :     handmade_aligned_free(ptr);
; 252  :   #endif
; 253  : }
; 254  : 
; 255  : /**
; 256  : * \internal
; 257  : * \brief Reallocates an aligned block of memory.
; 258  : * \throws std::bad_alloc on allocation failure
; 259  : **/
; 260  : inline void* aligned_realloc(void *ptr, size_t new_size, size_t old_size)
; 261  : {
; 262  :   EIGEN_UNUSED_VARIABLE(old_size);
; 263  : 
; 264  :   void *result;
; 265  : #if !EIGEN_ALIGN
; 266  :   result = std::realloc(ptr,new_size);
; 267  : #elif EIGEN_MALLOC_ALREADY_ALIGNED
; 268  :   result = std::realloc(ptr,new_size);
; 269  : #elif EIGEN_HAS_POSIX_MEMALIGN
; 270  :   result = generic_aligned_realloc(ptr,new_size,old_size);
; 271  : #elif EIGEN_HAS_MM_MALLOC
; 272  :   // The defined(_mm_free) is just here to verify that this MSVC version
; 273  :   // implements _mm_malloc/_mm_free based on the corresponding _aligned_
; 274  :   // functions. This may not always be the case and we just try to be safe.
; 275  :   #if defined(_MSC_VER) && (!defined(_WIN32_WCE)) && defined(_mm_free)
; 276  :     result = _aligned_realloc(ptr,new_size,16);
; 277  :   #else
; 278  :     result = generic_aligned_realloc(ptr,new_size,old_size);
; 279  :   #endif
; 280  : #elif defined(_MSC_VER) && (!defined(_WIN32_WCE))
; 281  :   result = _aligned_realloc(ptr,new_size,16);
; 282  : #else
; 283  :   result = handmade_aligned_realloc(ptr,new_size,old_size);
; 284  : #endif
; 285  : 
; 286  :   if (!result && new_size)
; 287  :     throw_std_bad_alloc();
; 288  : 
; 289  :   return result;
; 290  : }
; 291  : 
; 292  : /*****************************************************************************
; 293  : *** Implementation of conditionally aligned functions                      ***
; 294  : *****************************************************************************/
; 295  : 
; 296  : /** \internal Allocates \a size bytes. If Align is true, then the returned ptr is 16-byte-aligned.
; 297  :   * On allocation error, the returned pointer is null, and a std::bad_alloc is thrown.
; 298  :   */
; 299  : template<bool Align> inline void* conditional_aligned_malloc(size_t size)
; 300  : {
; 301  :   return aligned_malloc(size);
; 302  : }
; 303  : 
; 304  : template<> inline void* conditional_aligned_malloc<false>(size_t size)
; 305  : {
; 306  :   check_that_malloc_is_allowed();
; 307  : 
; 308  :   void *result = std::malloc(size);
; 309  :   if(!result && size)
; 310  :     throw_std_bad_alloc();
; 311  :   return result;
; 312  : }
; 313  : 
; 314  : /** \internal Frees memory allocated with conditional_aligned_malloc */
; 315  : template<bool Align> inline void conditional_aligned_free(void *ptr)
; 316  : {
; 317  :   aligned_free(ptr);
; 318  : }
; 319  : 
; 320  : template<> inline void conditional_aligned_free<false>(void *ptr)
; 321  : {
; 322  :   std::free(ptr);
; 323  : }
; 324  : 
; 325  : template<bool Align> inline void* conditional_aligned_realloc(void* ptr, size_t new_size, size_t old_size)
; 326  : {
; 327  :   return aligned_realloc(ptr, new_size, old_size);
; 328  : }
; 329  : 
; 330  : template<> inline void* conditional_aligned_realloc<false>(void* ptr, size_t new_size, size_t)
; 331  : {
; 332  :   return std::realloc(ptr, new_size);
; 333  : }
; 334  : 
; 335  : /*****************************************************************************
; 336  : *** Construction/destruction of array elements                             ***
; 337  : *****************************************************************************/
; 338  : 
; 339  : /** \internal Constructs the elements of an array.
; 340  :   * The \a size parameter tells on how many objects to call the constructor of T.
; 341  :   */
; 342  : template<typename T> inline T* construct_elements_of_array(T *ptr, size_t size)
; 343  : {
; 344  :   for (size_t i=0; i < size; ++i) ::new (ptr + i) T;
; 345  :   return ptr;
; 346  : }
; 347  : 
; 348  : /** \internal Destructs the elements of an array.
; 349  :   * The \a size parameters tells on how many objects to call the destructor of T.
; 350  :   */
; 351  : template<typename T> inline void destruct_elements_of_array(T *ptr, size_t size)
; 352  : {
; 353  :   // always destruct an array starting from the end.
; 354  :   if(ptr)
; 355  :     while(size) ptr[--size].~T();
; 356  : }
; 357  : 
; 358  : /*****************************************************************************
; 359  : *** Implementation of aligned new/delete-like functions                    ***
; 360  : *****************************************************************************/
; 361  : 
; 362  : template<typename T>
; 363  : EIGEN_ALWAYS_INLINE void check_size_for_overflow(size_t size)
; 364  : {
; 365  :   if(size > size_t(-1) / sizeof(T))

	mov	rcx, 2305843009213693951		; 1fffffffffffffffH
	cmp	rax, rcx
	jbe	SHORT $LN93@updateF

; 366  :     throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN93@updateF:

; 422  :   check_size_for_overflow<T>(size);
; 423  :   T *result = reinterpret_cast<T*>(conditional_aligned_malloc<Align>(sizeof(T)*size));

	lea	rdi, QWORD PTR [rax*8]

; 220  :     result = std::malloc(size);

	mov	rcx, rdi
	call	QWORD PTR __imp_malloc

; 221  :   #elif EIGEN_HAS_POSIX_MEMALIGN
; 222  :     if(posix_memalign(&result, 16, size)) result = 0;
; 223  :   #elif EIGEN_HAS_MM_MALLOC
; 224  :     result = _mm_malloc(size, 16);
; 225  :   #elif defined(_MSC_VER) && (!defined(_WIN32_WCE))
; 226  :     result = _aligned_malloc(size, 16);
; 227  :   #else
; 228  :     result = handmade_aligned_malloc(size);
; 229  :   #endif
; 230  : 
; 231  :   if(!result && size)

	test	rax, rax
	jne	SHORT $LN91@updateF
	test	rdi, rdi
	je	SHORT $LN91@updateF

; 232  :     throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN91@updateF:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 310  :     { EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN }

	mov	QWORD PTR df$[rbp-256], rax
	mov	QWORD PTR df$[rbp-248], rsi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	test	rbx, rbx
	je	SHORT $LN114@updateF
	dec	rbx
	jmp	SHORT $LN115@updateF
$LN114@updateF:
	mov	rbx, r15
$LN115@updateF:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 520  :   static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }

	inc	rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	je	SHORT $LN120@updateF
	lea	rdi, QWORD PTR [rbx-1]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 520  :   static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }

	test	rdi, rdi
	je	SHORT $LN120@updateF
	inc	rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	je	SHORT $LN142@updateF
	lea	rbx, QWORD PTR [rdi-1]
	jmp	SHORT $LN143@updateF
$LN120@updateF:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 520  :   static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }

	mov	rdi, r15
$LN142@updateF:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	mov	rbx, r15
$LN143@updateF:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 313  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rbx, QWORD PTR [rbx+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	mov	r12, 9223372036854775807		; 7fffffffffffffffH
	test	rbx, rbx
	je	SHORT $LN1529@updateF
	cmp	rbx, r12
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN156@updateF

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN156@updateF:

; 47   :   }
; 48   : };
; 49   : 
; 50   : template <typename Derived,
; 51   :           typename OtherDerived = Derived,
; 52   :           bool IsVector = bool(Derived::IsVectorAtCompileTime) && bool(OtherDerived::IsVectorAtCompileTime)>
; 53   : struct conservative_resize_like_impl;
; 54   : 
; 55   : template<typename MatrixTypeA, typename MatrixTypeB, bool SwapPointers> struct matrix_swap_impl;
; 56   : 
; 57   : } // end namespace internal
; 58   : 
; 59   : /** \class PlainObjectBase
; 60   :   * \brief %Dense storage base class for matrices and arrays.
; 61   :   *
; 62   :   * This class can be extended with the help of the plugin mechanism described on the page
; 63   :   * \ref TopicCustomizingEigen by defining the preprocessor symbol \c EIGEN_PLAINOBJECTBASE_PLUGIN.
; 64   :   *
; 65   :   * \sa \ref TopicClassHierarchy
; 66   :   */
; 67   : #ifdef EIGEN_PARSED_BY_DOXYGEN
; 68   : namespace internal {
; 69   : 
; 70   : // this is a warkaround to doxygen not being able to understand the inheritence logic
; 71   : // when it is hidden by the dense_xpr_base helper struct.
; 72   : template<typename Derived> struct dense_xpr_base_dispatcher_for_doxygen;// : public MatrixBase<Derived> {};
; 73   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 74   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 75   : struct dense_xpr_base_dispatcher_for_doxygen<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 76   :     : public MatrixBase<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 77   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 78   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 79   : struct dense_xpr_base_dispatcher_for_doxygen<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 80   :     : public ArrayBase<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 81   : 
; 82   : } // namespace internal
; 83   : 
; 84   : template<typename Derived>
; 85   : class PlainObjectBase : public internal::dense_xpr_base_dispatcher_for_doxygen<Derived>
; 86   : #else
; 87   : template<typename Derived>
; 88   : class PlainObjectBase : public internal::dense_xpr_base<Derived>::type
; 89   : #endif
; 90   : {
; 91   :   public:
; 92   :     enum { Options = internal::traits<Derived>::Options };
; 93   :     typedef typename internal::dense_xpr_base<Derived>::type Base;
; 94   : 
; 95   :     typedef typename internal::traits<Derived>::StorageKind StorageKind;
; 96   :     typedef typename internal::traits<Derived>::Index Index;
; 97   :     typedef typename internal::traits<Derived>::Scalar Scalar;
; 98   :     typedef typename internal::packet_traits<Scalar>::type PacketScalar;
; 99   :     typedef typename NumTraits<Scalar>::Real RealScalar;
; 100  :     typedef Derived DenseType;
; 101  : 
; 102  :     using Base::RowsAtCompileTime;
; 103  :     using Base::ColsAtCompileTime;
; 104  :     using Base::SizeAtCompileTime;
; 105  :     using Base::MaxRowsAtCompileTime;
; 106  :     using Base::MaxColsAtCompileTime;
; 107  :     using Base::MaxSizeAtCompileTime;
; 108  :     using Base::IsVectorAtCompileTime;
; 109  :     using Base::Flags;
; 110  : 
; 111  :     template<typename PlainObjectType, int MapOptions, typename StrideType> friend class Eigen::Map;
; 112  :     friend  class Eigen::Map<Derived, Unaligned>;
; 113  :     typedef Eigen::Map<Derived, Unaligned>  MapType;
; 114  :     friend  class Eigen::Map<const Derived, Unaligned>;
; 115  :     typedef const Eigen::Map<const Derived, Unaligned> ConstMapType;
; 116  :     friend  class Eigen::Map<Derived, Aligned>;
; 117  :     typedef Eigen::Map<Derived, Aligned> AlignedMapType;
; 118  :     friend  class Eigen::Map<const Derived, Aligned>;
; 119  :     typedef const Eigen::Map<const Derived, Aligned> ConstAlignedMapType;
; 120  :     template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };
; 121  :     template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };
; 122  :     template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, Aligned, StrideType> type; };
; 123  :     template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, Aligned, StrideType> type; };
; 124  : 
; 125  :   protected:
; 126  :     DenseStorage<Scalar, Base::MaxSizeAtCompileTime, Base::RowsAtCompileTime, Base::ColsAtCompileTime, Options> m_storage;
; 127  : 
; 128  :   public:
; 129  :     enum { NeedsToAlign = SizeAtCompileTime != Dynamic && (internal::traits<Derived>::Flags & AlignedBit) != 0 };
; 130  :     EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(NeedsToAlign)
; 131  : 
; 132  :     Base& base() { return *static_cast<Base*>(this); }
; 133  :     const Base& base() const { return *static_cast<const Base*>(this); }
; 134  : 
; 135  :     EIGEN_STRONG_INLINE Index rows() const { return m_storage.rows(); }
; 136  :     EIGEN_STRONG_INLINE Index cols() const { return m_storage.cols(); }
; 137  : 
; 138  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index rowId, Index colId) const
; 139  :     {
; 140  :       if(Flags & RowMajorBit)
; 141  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 142  :       else // column-major
; 143  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 144  :     }
; 145  : 
; 146  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index index) const
; 147  :     {
; 148  :       return m_storage.data()[index];
; 149  :     }
; 150  : 
; 151  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index rowId, Index colId)
; 152  :     {
; 153  :       if(Flags & RowMajorBit)
; 154  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 155  :       else // column-major
; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 157  :     }
; 158  : 
; 159  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
; 160  :     {
; 161  :       return m_storage.data()[index];
; 162  :     }
; 163  : 
; 164  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
; 165  :     {
; 166  :       if(Flags & RowMajorBit)
; 167  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 168  :       else // column-major
; 169  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 170  :     }
; 171  : 
; 172  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
; 173  :     {
; 174  :       return m_storage.data()[index];
; 175  :     }
; 176  : 
; 177  :     /** \internal */
; 178  :     template<int LoadMode>
; 179  :     EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const
; 180  :     {
; 181  :       return internal::ploadt<PacketScalar, LoadMode>
; 182  :                (m_storage.data() + (Flags & RowMajorBit
; 183  :                                    ? colId + rowId * m_storage.cols()
; 184  :                                    : rowId + colId * m_storage.rows()));
; 185  :     }
; 186  : 
; 187  :     /** \internal */
; 188  :     template<int LoadMode>
; 189  :     EIGEN_STRONG_INLINE PacketScalar packet(Index index) const
; 190  :     {
; 191  :       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);
; 192  :     }
; 193  : 
; 194  :     /** \internal */
; 195  :     template<int StoreMode>
; 196  :     EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)
; 197  :     {
; 198  :       internal::pstoret<Scalar, PacketScalar, StoreMode>
; 199  :               (m_storage.data() + (Flags & RowMajorBit
; 200  :                                    ? colId + rowId * m_storage.cols()
; 201  :                                    : rowId + colId * m_storage.rows()), val);
; 202  :     }
; 203  : 
; 204  :     /** \internal */
; 205  :     template<int StoreMode>
; 206  :     EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
; 207  :     {
; 208  :       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
; 209  :     }
; 210  : 
; 211  :     /** \returns a const pointer to the data array of this matrix */
; 212  :     EIGEN_STRONG_INLINE const Scalar *data() const
; 213  :     { return m_storage.data(); }
; 214  : 
; 215  :     /** \returns a pointer to the data array of this matrix */
; 216  :     EIGEN_STRONG_INLINE Scalar *data()
; 217  :     { return m_storage.data(); }
; 218  : 
; 219  :     /** Resizes \c *this to a \a rows x \a cols matrix.
; 220  :       *
; 221  :       * This method is intended for dynamic-size matrices, although it is legal to call it on any
; 222  :       * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
; 223  :       * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
; 224  :       *
; 225  :       * If the current number of coefficients of \c *this exactly matches the
; 226  :       * product \a rows * \a cols, then no memory allocation is performed and
; 227  :       * the current values are left unchanged. In all other cases, including
; 228  :       * shrinking, the data is reallocated and all previous values are lost.
; 229  :       *
; 230  :       * Example: \include Matrix_resize_int_int.cpp
; 231  :       * Output: \verbinclude Matrix_resize_int_int.out
; 232  :       *
; 233  :       * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
; 234  :       */
; 235  :     EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)
; 236  :     {
; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rbx, rbx
$LN1529@updateF:
	jns	SHORT $LN235@updateF
	mov	r8d, 241				; 000000f1H
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	call	QWORD PTR __imp__wassert
	mov	rsi, QWORD PTR df$[rbp-248]
$LN235@updateF:

; 44   :                : (rows > max_index / cols);

	test	rbx, rbx
	je	SHORT $LN242@updateF
	cmp	rbx, r12
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN242@updateF

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN242@updateF:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 322  :       if(size != m_rows*_Cols)

	cmp	rbx, rsi
	je	SHORT $LN247@updateF
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR df$[rbp-256]
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 325  :         if (size)

	test	rbx, rbx
	je	SHORT $LN248@updateF

; 326  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

	mov	rcx, rbx
	call	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
	mov	QWORD PTR df$[rbp-256], rax

; 327  :         else

	jmp	SHORT $LN247@updateF
$LN248@updateF:

; 328  :           m_data = 0;

	mov	QWORD PTR df$[rbp-256], r15
$LN247@updateF:

; 329  :         EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN
; 330  :       }
; 331  :       m_rows = nbRows;

	mov	QWORD PTR df$[rbp-248], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	test	rdi, rdi
	je	SHORT $LN128@updateF
	dec	rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 414  :       return Base::lazyAssign(other.derived());

	je	SHORT $LN128@updateF
	inc	rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	je	SHORT $LN331@updateF
	lea	rax, QWORD PTR [rdi-1]
	jmp	SHORT $LN332@updateF
$LN128@updateF:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 414  :       return Base::lazyAssign(other.derived());

	mov	rdi, r15
$LN331@updateF:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	mov	rax, r15
$LN332@updateF:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	cmp	rbx, QWORD PTR [rax+16]
	je	SHORT $LN318@updateF
	mov	r8d, 498				; 000001f2H
	lea	rdx, OFFSET FLAT:??_C@_1KO@HDGCFKMN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GC@PBCDNLIH@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ@
	call	QWORD PTR __imp__wassert
	mov	rbx, QWORD PTR df$[rbp-248]
$LN318@updateF:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	test	rdi, rdi
	lea	r10, QWORD PTR [rdi-1]
	jne	SHORT $LN362@updateF
	mov	r10, r15
$LN362@updateF:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 404  :     const Index alignedEnd = alignedStart + ((size-alignedStart)/packetSize)*packetSize;

	mov	rax, rbx
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r8, rax
	add	r8, r8

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	mov	rcx, r15
	test	r8, r8
	jle	SHORT $LN1527@updateF
	movdqa	xmm1, XMMWORD PTR __xmm@80000000000000008000000000000000
	npad	3
$LL367@updateF:

; 409  :     {
; 410  :       dst.template copyPacket<Derived2, dstAlignment, srcAlignment>(index, src);

	test	r10, r10
	je	SHORT $LN410@updateF
	lea	rax, QWORD PTR [r10+1]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	test	rax, rax
	je	SHORT $LN410@updateF
	dec	rax
	jmp	SHORT $LN411@updateF
$LN410@updateF:
	mov	rax, r15
$LN411@updateF:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 538  :         other.derived().template packet<LoadMode>(index));

	inc	rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	je	SHORT $LN416@updateF
	dec	rax
	jmp	SHORT $LN417@updateF
$LN416@updateF:
	mov	rax, r15
$LN417@updateF:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 333  :     inline const T *data() const { return m_data; }

	mov	rax, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 138  :   return _mm_xor_pd(a,mask);

	movaps	xmm0, xmm1
	xorps	xmm0, XMMWORD PTR [rax+rcx*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	mov	rax, QWORD PTR df$[rbp-256]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [rax+rcx*8], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	add	rcx, 2
	cmp	rcx, r8
	jl	SHORT $LL367@updateF
$LN1527@updateF:

; 411  :     }
; 412  : 
; 413  :     unaligned_assign_impl<>::run(src,dst,alignedEnd,size);

	mov	r9, rbx
	lea	rdx, QWORD PTR df$[rbp-256]
	mov	rcx, r10
	call	??$run@V?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@?$unaligned_assign_impl@$0A@@internal@Eigen@@SAXAEBV?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@2@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@_J2@Z ; Eigen::internal::unaligned_assign_impl<0>::run<Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>,Eigen::ReturnByValue<Eigen::internal::solve_retval_base<Eigen::PartialPivLU<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::Matrix<double,-1,1,0,-1,1> > > const >,Eigen::Matrix<double,-1,1,0,-1,1> >
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR $T22[rbp-248]
	call	QWORD PTR __imp_free
	npad	1
	mov	rcx, QWORD PTR $T24[rbp-216]
	call	QWORD PTR __imp_free
	mov	rcx, QWORD PTR $T24[rbp-232]
	call	QWORD PTR __imp_free
	mov	rcx, QWORD PTR $T24[rbp-256]
	call	QWORD PTR __imp_free
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 77   : 	f += df;

	lea	rbx, QWORD PTR [r14+400]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h

; 55   :     inline SelfCwiseBinaryOp(Lhs& xpr, const BinaryOp& func = BinaryOp()) : m_matrix(xpr), m_functor(func) {}

	mov	QWORD PTR tmp$9[rsp], rbx
	lea	rax, QWORD PTR $T1[rsp]
	mov	QWORD PTR tmp$9[rsp+8], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 313  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rax, QWORD PTR [rbx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h

; 136  :       eigen_assert(rows() == rhs.rows() && cols() == rhs.cols());

	cmp	rax, QWORD PTR df$[rbp-248]
	je	SHORT $LN568@updateF
	mov	r8d, 136				; 00000088H
	lea	rdx, OFFSET FLAT:??_C@_1ME@CGCHACLK@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1FK@JAKLMIFJ@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAr?$AAh?$AAs?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN@
	call	QWORD PTR __imp__wassert
$LN568@updateF:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 395  :     const Index size = dst.size();

	mov	r9, QWORD PTR [rbx+8]

; 404  :     const Index alignedEnd = alignedStart + ((size-alignedStart)/packetSize)*packetSize;

	mov	rax, r9
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r8, rax
	add	r8, r8

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	mov	rdx, r15
	test	r8, r8
	jle	SHORT $LN599@updateF
	npad	1
$LL601@updateF:
	mov	rax, QWORD PTR df$[rbp-256]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 333  :     inline const T *data() const { return m_data; }

	mov	rcx, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 220  : template<> EIGEN_STRONG_INLINE Packet2d pload<Packet2d>(const double*  from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_pd(from); }

	movaps	xmm0, XMMWORD PTR [rcx+rdx*8]

; 123  : template<> EIGEN_STRONG_INLINE Packet2d padd<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_add_pd(a,b); }

	addpd	xmm0, XMMWORD PTR [rax+rdx*8]

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [rcx+rdx*8], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	add	rdx, 2
	cmp	rdx, r8
	jl	SHORT $LL601@updateF
$LN599@updateF:

; 411  :     }
; 412  : 
; 413  :     unaligned_assign_impl<>::run(src,dst,alignedEnd,size);

	lea	rdx, QWORD PTR tmp$9[rsp]
	lea	rcx, QWORD PTR df$[rbp-256]
	call	??$run@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V43@@2@@?$unaligned_assign_impl@$0A@@internal@Eigen@@SAXAEBV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V43@@2@_J2@Z ; Eigen::internal::unaligned_assign_impl<0>::run<Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Matrix<double,-1,1,0,-1,1> > >
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 80   : 	IGORdata::write_itx(f, "output/debug/f.itx", "FF");

	lea	rax, QWORD PTR $T7[rsp]
	mov	QWORD PTR $T14[rsp], rax
	mov	QWORD PTR $T7[rsp+24], 15
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T7[rsp+16], r15
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T7[rsp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 2
	lea	rdx, OFFSET FLAT:??_C@_02NCIKDPBM@FF?$AA@
	lea	rcx, QWORD PTR $T7[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
	mov	QWORD PTR $T19[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T19[rbp-240], r15
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T19[rsp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 18
	lea	rdx, OFFSET FLAT:??_C@_0BD@GOPMHKAF@output?1debug?1f?4itx?$AA@
	lea	rcx, QWORD PTR $T19[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 80   : 	IGORdata::write_itx(f, "output/debug/f.itx", "FF");

	lea	r8, QWORD PTR $T7[rsp]
	lea	rdx, QWORD PTR $T19[rsp]
	mov	rcx, rbx
	call	??$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z ; IGORdata::write_itx<double,-1,1,0,-1,1>

; 81   : 	IGORdata::write_itx(df, "output/debug/df.itx", "df");

	lea	rax, QWORD PTR $T6[rsp]
	mov	QWORD PTR $T13[rsp], rax
	mov	QWORD PTR $T6[rsp+24], 15
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T6[rsp+16], r15
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T6[rsp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 2
	lea	rdx, OFFSET FLAT:??_C@_02HMMHIJDA@df?$AA@
	lea	rcx, QWORD PTR $T6[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
	mov	QWORD PTR $T18[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T18[rbp-240], r15
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T18[rsp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 19
	lea	rdx, OFFSET FLAT:??_C@_0BE@KCMMJAFM@output?1debug?1df?4itx?$AA@
	lea	rcx, QWORD PTR $T18[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 81   : 	IGORdata::write_itx(df, "output/debug/df.itx", "df");

	lea	r8, QWORD PTR $T6[rsp]
	lea	rdx, QWORD PTR $T18[rsp]
	lea	rcx, QWORD PTR df$[rbp-256]
	call	??$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z ; IGORdata::write_itx<double,-1,1,0,-1,1>

; 82   : 	IGORdata::write_itx(v, "output/debug/v.itx", "vv");

	lea	rax, QWORD PTR $T5[rsp]
	mov	QWORD PTR $T12[rsp], rax
	mov	QWORD PTR $T5[rsp+24], 15
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T5[rsp+16], r15
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T5[rsp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 2
	lea	rdx, OFFSET FLAT:??_C@_02CJKHOMHP@vv?$AA@
	lea	rcx, QWORD PTR $T5[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
	mov	QWORD PTR $T17[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T17[rbp-240], r15
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T17[rsp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 18
	lea	rdx, OFFSET FLAT:??_C@_0BD@GNCKHIJO@output?1debug?1v?4itx?$AA@
	lea	rcx, QWORD PTR $T17[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 82   : 	IGORdata::write_itx(v, "output/debug/v.itx", "vv");

	lea	rcx, QWORD PTR [r14+416]
	lea	r8, QWORD PTR $T5[rsp]
	lea	rdx, QWORD PTR $T17[rsp]
	call	??$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z ; IGORdata::write_itx<double,-1,1,0,-1,1>
	xor	eax, eax
	mov	QWORD PTR Af$[rbp-256], rax
	mov	QWORD PTR Af$[rbp-248], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwiseunaryop.h

; 68   :       : m_xpr(xpr), m_functor(func) {}

	mov	QWORD PTR $T11[rsp+8], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arraywrapper.h

; 181  :     inline MatrixWrapper(ExpressionType& a_matrix) : m_expression(a_matrix) {}

	movups	xmm0, XMMWORD PTR $T11[rsp]
	movups	XMMWORD PTR $T4[rsp], xmm0
	movsdx	xmm1, QWORD PTR $T11[rsp+16]
	movsdx	QWORD PTR $T4[rsp+16], xmm1
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 83   : 	Eigen::VectorXd Af = A*f.array().exp().matrix();

	lea	rcx, QWORD PTR [r14+80]
	lea	r8, QWORD PTR $T4[rsp]
	lea	rdx, QWORD PTR $T21[rbp-256]
	call	??$?DV?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@Eigen@@@?$MatrixBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA?BV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@1@AEBV?$MatrixBase@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@Eigen@@@1@@Z ; Eigen::MatrixBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::operator*<Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >
	mov	rdi, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rcx, QWORD PTR [rax]
	mov	rdx, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 442  :     {

	mov	r8, rdx
	lea	rcx, QWORD PTR Af$[rbp-256]
	call	??0?$DenseStorage@N$0?0$0?0$00$0A@@Eigen@@QEAA@_J00@Z ; Eigen::DenseStorage<double,-1,-1,1,0>::DenseStorage<double,-1,-1,1,0>
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rcx, QWORD PTR [rdi]
	mov	rbx, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	test	rbx, rbx
	je	SHORT $LN1531@updateF
	cmp	rbx, r12
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN1082@updateF

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN1082@updateF:

; 47   :   }
; 48   : };
; 49   : 
; 50   : template <typename Derived,
; 51   :           typename OtherDerived = Derived,
; 52   :           bool IsVector = bool(Derived::IsVectorAtCompileTime) && bool(OtherDerived::IsVectorAtCompileTime)>
; 53   : struct conservative_resize_like_impl;
; 54   : 
; 55   : template<typename MatrixTypeA, typename MatrixTypeB, bool SwapPointers> struct matrix_swap_impl;
; 56   : 
; 57   : } // end namespace internal
; 58   : 
; 59   : /** \class PlainObjectBase
; 60   :   * \brief %Dense storage base class for matrices and arrays.
; 61   :   *
; 62   :   * This class can be extended with the help of the plugin mechanism described on the page
; 63   :   * \ref TopicCustomizingEigen by defining the preprocessor symbol \c EIGEN_PLAINOBJECTBASE_PLUGIN.
; 64   :   *
; 65   :   * \sa \ref TopicClassHierarchy
; 66   :   */
; 67   : #ifdef EIGEN_PARSED_BY_DOXYGEN
; 68   : namespace internal {
; 69   : 
; 70   : // this is a warkaround to doxygen not being able to understand the inheritence logic
; 71   : // when it is hidden by the dense_xpr_base helper struct.
; 72   : template<typename Derived> struct dense_xpr_base_dispatcher_for_doxygen;// : public MatrixBase<Derived> {};
; 73   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 74   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 75   : struct dense_xpr_base_dispatcher_for_doxygen<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 76   :     : public MatrixBase<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 77   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 78   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 79   : struct dense_xpr_base_dispatcher_for_doxygen<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 80   :     : public ArrayBase<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 81   : 
; 82   : } // namespace internal
; 83   : 
; 84   : template<typename Derived>
; 85   : class PlainObjectBase : public internal::dense_xpr_base_dispatcher_for_doxygen<Derived>
; 86   : #else
; 87   : template<typename Derived>
; 88   : class PlainObjectBase : public internal::dense_xpr_base<Derived>::type
; 89   : #endif
; 90   : {
; 91   :   public:
; 92   :     enum { Options = internal::traits<Derived>::Options };
; 93   :     typedef typename internal::dense_xpr_base<Derived>::type Base;
; 94   : 
; 95   :     typedef typename internal::traits<Derived>::StorageKind StorageKind;
; 96   :     typedef typename internal::traits<Derived>::Index Index;
; 97   :     typedef typename internal::traits<Derived>::Scalar Scalar;
; 98   :     typedef typename internal::packet_traits<Scalar>::type PacketScalar;
; 99   :     typedef typename NumTraits<Scalar>::Real RealScalar;
; 100  :     typedef Derived DenseType;
; 101  : 
; 102  :     using Base::RowsAtCompileTime;
; 103  :     using Base::ColsAtCompileTime;
; 104  :     using Base::SizeAtCompileTime;
; 105  :     using Base::MaxRowsAtCompileTime;
; 106  :     using Base::MaxColsAtCompileTime;
; 107  :     using Base::MaxSizeAtCompileTime;
; 108  :     using Base::IsVectorAtCompileTime;
; 109  :     using Base::Flags;
; 110  : 
; 111  :     template<typename PlainObjectType, int MapOptions, typename StrideType> friend class Eigen::Map;
; 112  :     friend  class Eigen::Map<Derived, Unaligned>;
; 113  :     typedef Eigen::Map<Derived, Unaligned>  MapType;
; 114  :     friend  class Eigen::Map<const Derived, Unaligned>;
; 115  :     typedef const Eigen::Map<const Derived, Unaligned> ConstMapType;
; 116  :     friend  class Eigen::Map<Derived, Aligned>;
; 117  :     typedef Eigen::Map<Derived, Aligned> AlignedMapType;
; 118  :     friend  class Eigen::Map<const Derived, Aligned>;
; 119  :     typedef const Eigen::Map<const Derived, Aligned> ConstAlignedMapType;
; 120  :     template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };
; 121  :     template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };
; 122  :     template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, Aligned, StrideType> type; };
; 123  :     template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, Aligned, StrideType> type; };
; 124  : 
; 125  :   protected:
; 126  :     DenseStorage<Scalar, Base::MaxSizeAtCompileTime, Base::RowsAtCompileTime, Base::ColsAtCompileTime, Options> m_storage;
; 127  : 
; 128  :   public:
; 129  :     enum { NeedsToAlign = SizeAtCompileTime != Dynamic && (internal::traits<Derived>::Flags & AlignedBit) != 0 };
; 130  :     EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(NeedsToAlign)
; 131  : 
; 132  :     Base& base() { return *static_cast<Base*>(this); }
; 133  :     const Base& base() const { return *static_cast<const Base*>(this); }
; 134  : 
; 135  :     EIGEN_STRONG_INLINE Index rows() const { return m_storage.rows(); }
; 136  :     EIGEN_STRONG_INLINE Index cols() const { return m_storage.cols(); }
; 137  : 
; 138  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index rowId, Index colId) const
; 139  :     {
; 140  :       if(Flags & RowMajorBit)
; 141  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 142  :       else // column-major
; 143  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 144  :     }
; 145  : 
; 146  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index index) const
; 147  :     {
; 148  :       return m_storage.data()[index];
; 149  :     }
; 150  : 
; 151  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index rowId, Index colId)
; 152  :     {
; 153  :       if(Flags & RowMajorBit)
; 154  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 155  :       else // column-major
; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 157  :     }
; 158  : 
; 159  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
; 160  :     {
; 161  :       return m_storage.data()[index];
; 162  :     }
; 163  : 
; 164  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
; 165  :     {
; 166  :       if(Flags & RowMajorBit)
; 167  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 168  :       else // column-major
; 169  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 170  :     }
; 171  : 
; 172  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
; 173  :     {
; 174  :       return m_storage.data()[index];
; 175  :     }
; 176  : 
; 177  :     /** \internal */
; 178  :     template<int LoadMode>
; 179  :     EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const
; 180  :     {
; 181  :       return internal::ploadt<PacketScalar, LoadMode>
; 182  :                (m_storage.data() + (Flags & RowMajorBit
; 183  :                                    ? colId + rowId * m_storage.cols()
; 184  :                                    : rowId + colId * m_storage.rows()));
; 185  :     }
; 186  : 
; 187  :     /** \internal */
; 188  :     template<int LoadMode>
; 189  :     EIGEN_STRONG_INLINE PacketScalar packet(Index index) const
; 190  :     {
; 191  :       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);
; 192  :     }
; 193  : 
; 194  :     /** \internal */
; 195  :     template<int StoreMode>
; 196  :     EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)
; 197  :     {
; 198  :       internal::pstoret<Scalar, PacketScalar, StoreMode>
; 199  :               (m_storage.data() + (Flags & RowMajorBit
; 200  :                                    ? colId + rowId * m_storage.cols()
; 201  :                                    : rowId + colId * m_storage.rows()), val);
; 202  :     }
; 203  : 
; 204  :     /** \internal */
; 205  :     template<int StoreMode>
; 206  :     EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
; 207  :     {
; 208  :       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
; 209  :     }
; 210  : 
; 211  :     /** \returns a const pointer to the data array of this matrix */
; 212  :     EIGEN_STRONG_INLINE const Scalar *data() const
; 213  :     { return m_storage.data(); }
; 214  : 
; 215  :     /** \returns a pointer to the data array of this matrix */
; 216  :     EIGEN_STRONG_INLINE Scalar *data()
; 217  :     { return m_storage.data(); }
; 218  : 
; 219  :     /** Resizes \c *this to a \a rows x \a cols matrix.
; 220  :       *
; 221  :       * This method is intended for dynamic-size matrices, although it is legal to call it on any
; 222  :       * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
; 223  :       * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
; 224  :       *
; 225  :       * If the current number of coefficients of \c *this exactly matches the
; 226  :       * product \a rows * \a cols, then no memory allocation is performed and
; 227  :       * the current values are left unchanged. In all other cases, including
; 228  :       * shrinking, the data is reallocated and all previous values are lost.
; 229  :       *
; 230  :       * Example: \include Matrix_resize_int_int.cpp
; 231  :       * Output: \verbinclude Matrix_resize_int_int.out
; 232  :       *
; 233  :       * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
; 234  :       */
; 235  :     EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)
; 236  :     {
; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rbx, rbx
$LN1531@updateF:
	jns	SHORT $LN1179@updateF
	mov	r8d, 241				; 000000f1H
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	call	QWORD PTR __imp__wassert
$LN1179@updateF:

; 44   :                : (rows > max_index / cols);

	test	rbx, rbx
	je	SHORT $LN1186@updateF
	cmp	rbx, r12
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN1186@updateF

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN1186@updateF:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 322  :       if(size != m_rows*_Cols)

	cmp	rbx, QWORD PTR Af$[rbp-248]
	je	SHORT $LN1191@updateF
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR Af$[rbp-256]
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 325  :         if (size)

	test	rbx, rbx
	je	SHORT $LN1192@updateF

; 326  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

	mov	rcx, rbx
	call	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
	mov	QWORD PTR Af$[rbp-256], rax

; 327  :         else

	jmp	SHORT $LN1191@updateF
$LN1192@updateF:

; 328  :           m_data = 0;

	mov	QWORD PTR Af$[rbp-256], r15
$LN1191@updateF:

; 329  :         EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN
; 330  :       }
; 331  :       m_rows = nbRows;

	mov	QWORD PTR Af$[rbp-248], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h

; 284  :   other.derived().evalTo(derived());

	lea	rdx, QWORD PTR Af$[rbp-256]
	mov	rcx, rdi
	call	??$evalTo@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEBAXAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@@Z ; Eigen::ProductBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >::evalTo<Eigen::Matrix<double,-1,1,0,-1,1> >
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR $T21[rbp-224]
	call	QWORD PTR __imp_free
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 84   : 	IGORdata::write_itx(Af, "output/debug/Af.itx", "Af");

	lea	rax, QWORD PTR $T3[rsp]
	mov	QWORD PTR $T10[rsp], rax
	mov	QWORD PTR $T3[rsp+24], 15
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T3[rsp+16], r15
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T3[rsp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 2
	lea	rdx, OFFSET FLAT:??_C@_02ECEBANDL@Af?$AA@
	lea	rcx, QWORD PTR $T3[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
	mov	QWORD PTR $T16[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T16[rbp-240], r15
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T16[rsp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 19
	lea	rdx, OFFSET FLAT:??_C@_0BE@DPEJIGGH@output?1debug?1Af?4itx?$AA@
	lea	rcx, QWORD PTR $T16[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 84   : 	IGORdata::write_itx(Af, "output/debug/Af.itx", "Af");

	lea	r8, QWORD PTR $T3[rsp]
	lea	rdx, QWORD PTR $T16[rsp]
	lea	rcx, QWORD PTR Af$[rbp-256]
	call	??$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z ; IGORdata::write_itx<double,-1,1,0,-1,1>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwiseunaryop.h

; 68   :       : m_xpr(xpr), m_functor(func) {}

	lea	rax, QWORD PTR df$[rbp-256]
	mov	QWORD PTR $T2[rsp+8], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xfunctional

; 498  : 		{	// construct from functor and right operand

	movsdx	QWORD PTR $T8[rsp+8], xmm6
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwiseunaryop.h

; 68   :       : m_xpr(xpr), m_functor(func) {}

	movups	xmm0, XMMWORD PTR $T2[rsp]
	movups	XMMWORD PTR $T20[rbp-248], xmm0
	movsdx	xmm1, QWORD PTR $T2[rsp+16]
	movsdx	QWORD PTR $T20[rbp-232], xmm1
	movups	xmm0, XMMWORD PTR $T8[rsp]
	movups	XMMWORD PTR $T20[rbp-224], xmm0
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 96   : 	if ((df.array().abs() < relativeError0).all())

	lea	rcx, QWORD PTR $T20[rbp-255]
	call	?all@?$DenseBase@V?$CwiseUnaryOp@V?$binder2nd@U?$less@N@std@@@std@@$$CBV?$CwiseUnaryOp@U?$scalar_abs_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@Eigen@@@Eigen@@QEBA_NXZ ; Eigen::DenseBase<Eigen::CwiseUnaryOp<std::binder2nd<std::less<double> >,Eigen::CwiseUnaryOp<Eigen::internal::scalar_abs_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >::all
	test	al, al
	setne	bl
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR Af$[rbp-256]
	call	QWORD PTR __imp_free
	npad	1
	mov	rcx, QWORD PTR df$[rbp-256]
	call	QWORD PTR __imp_free
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 100  : 	else return false;

	movzx	eax, bl

; 101  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+336]
	mov	rbx, QWORD PTR [r11+64]
	mov	rsi, QWORD PTR [r11+72]
	movaps	xmm6, XMMWORD PTR [r11-16]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rbp
	ret	0
$LN1528@updateF:
?updateF@Tikhonov2D@@AEAA_NNN@Z ENDP			; Tikhonov2D::updateF
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 88
tmp$9 = 88
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 88
$T14 = 88
$T15 = 88
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 144
$T21 = 144
$T22 = 144
$T23 = 192
$T24 = 200
df$ = 272
Af$ = 288
__$ArrayPad$ = 304
this$ = 384
lambda$ = 392
relativeError0$ = 400
?dtor$0@?0??updateF@Tikhonov2D@@AEAA_NNN@Z@4HA PROC	; `Tikhonov2D::updateF'::`1'::dtor$0
	lea	rcx, QWORD PTR $T24[rdx]
	jmp	??1?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAA@XZ
?dtor$0@?0??updateF@Tikhonov2D@@AEAA_NNN@Z@4HA ENDP	; `Tikhonov2D::updateF'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 88
tmp$9 = 88
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 88
$T14 = 88
$T15 = 88
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 144
$T21 = 144
$T22 = 144
$T23 = 192
$T24 = 200
df$ = 272
Af$ = 288
__$ArrayPad$ = 304
this$ = 384
lambda$ = 392
relativeError0$ = 400
?dtor$1@?0??updateF@Tikhonov2D@@AEAA_NNN@Z@4HA PROC	; `Tikhonov2D::updateF'::`1'::dtor$1
	lea	rcx, QWORD PTR $T22[rdx]
	jmp	??1?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@QEAA@XZ
?dtor$1@?0??updateF@Tikhonov2D@@AEAA_NNN@Z@4HA ENDP	; `Tikhonov2D::updateF'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 88
tmp$9 = 88
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 88
$T14 = 88
$T15 = 88
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 144
$T21 = 144
$T22 = 144
$T23 = 192
$T24 = 200
df$ = 272
Af$ = 288
__$ArrayPad$ = 304
this$ = 384
lambda$ = 392
relativeError0$ = 400
?dtor$13@?0??updateF@Tikhonov2D@@AEAA_NNN@Z@4HA PROC	; `Tikhonov2D::updateF'::`1'::dtor$13
	lea	rcx, QWORD PTR df$[rdx]
	jmp	??1?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAA@XZ
?dtor$13@?0??updateF@Tikhonov2D@@AEAA_NNN@Z@4HA ENDP	; `Tikhonov2D::updateF'::`1'::dtor$13
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 88
tmp$9 = 88
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 88
$T14 = 88
$T15 = 88
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 144
$T21 = 144
$T22 = 144
$T23 = 192
$T24 = 200
df$ = 272
Af$ = 288
__$ArrayPad$ = 304
this$ = 384
lambda$ = 392
relativeError0$ = 400
?dtor$2@?0??updateF@Tikhonov2D@@AEAA_NNN@Z@4HA PROC	; `Tikhonov2D::updateF'::`1'::dtor$2
	lea	rcx, QWORD PTR df$[rdx]
	jmp	??1?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@XZ
?dtor$2@?0??updateF@Tikhonov2D@@AEAA_NNN@Z@4HA ENDP	; `Tikhonov2D::updateF'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 88
tmp$9 = 88
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 88
$T14 = 88
$T15 = 88
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 144
$T21 = 144
$T22 = 144
$T23 = 192
$T24 = 200
df$ = 272
Af$ = 288
__$ArrayPad$ = 304
this$ = 384
lambda$ = 392
relativeError0$ = 400
?dtor$3@?0??updateF@Tikhonov2D@@AEAA_NNN@Z@4HA PROC	; `Tikhonov2D::updateF'::`1'::dtor$3
	mov	rcx, QWORD PTR $T14[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0??updateF@Tikhonov2D@@AEAA_NNN@Z@4HA ENDP	; `Tikhonov2D::updateF'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 88
tmp$9 = 88
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 88
$T14 = 88
$T15 = 88
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 144
$T21 = 144
$T22 = 144
$T23 = 192
$T24 = 200
df$ = 272
Af$ = 288
__$ArrayPad$ = 304
this$ = 384
lambda$ = 392
relativeError0$ = 400
?dtor$5@?0??updateF@Tikhonov2D@@AEAA_NNN@Z@4HA PROC	; `Tikhonov2D::updateF'::`1'::dtor$5
	mov	rcx, QWORD PTR $T13[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$5@?0??updateF@Tikhonov2D@@AEAA_NNN@Z@4HA ENDP	; `Tikhonov2D::updateF'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 88
tmp$9 = 88
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 88
$T14 = 88
$T15 = 88
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 144
$T21 = 144
$T22 = 144
$T23 = 192
$T24 = 200
df$ = 272
Af$ = 288
__$ArrayPad$ = 304
this$ = 384
lambda$ = 392
relativeError0$ = 400
?dtor$7@?0??updateF@Tikhonov2D@@AEAA_NNN@Z@4HA PROC	; `Tikhonov2D::updateF'::`1'::dtor$7
	mov	rcx, QWORD PTR $T12[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$7@?0??updateF@Tikhonov2D@@AEAA_NNN@Z@4HA ENDP	; `Tikhonov2D::updateF'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 88
tmp$9 = 88
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 88
$T14 = 88
$T15 = 88
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 144
$T21 = 144
$T22 = 144
$T23 = 192
$T24 = 200
df$ = 272
Af$ = 288
__$ArrayPad$ = 304
this$ = 384
lambda$ = 392
relativeError0$ = 400
?dtor$9@?0??updateF@Tikhonov2D@@AEAA_NNN@Z@4HA PROC	; `Tikhonov2D::updateF'::`1'::dtor$9
	lea	rcx, QWORD PTR $T21[rdx]
	jmp	??1?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@QEAA@XZ
?dtor$9@?0??updateF@Tikhonov2D@@AEAA_NNN@Z@4HA ENDP	; `Tikhonov2D::updateF'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 88
tmp$9 = 88
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 88
$T14 = 88
$T15 = 88
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 144
$T21 = 144
$T22 = 144
$T23 = 192
$T24 = 200
df$ = 272
Af$ = 288
__$ArrayPad$ = 304
this$ = 384
lambda$ = 392
relativeError0$ = 400
?dtor$15@?0??updateF@Tikhonov2D@@AEAA_NNN@Z@4HA PROC	; `Tikhonov2D::updateF'::`1'::dtor$15
	lea	rcx, QWORD PTR Af$[rdx]
	jmp	??1?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAA@XZ
?dtor$15@?0??updateF@Tikhonov2D@@AEAA_NNN@Z@4HA ENDP	; `Tikhonov2D::updateF'::`1'::dtor$15
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 88
tmp$9 = 88
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 88
$T14 = 88
$T15 = 88
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 144
$T21 = 144
$T22 = 144
$T23 = 192
$T24 = 200
df$ = 272
Af$ = 288
__$ArrayPad$ = 304
this$ = 384
lambda$ = 392
relativeError0$ = 400
?dtor$10@?0??updateF@Tikhonov2D@@AEAA_NNN@Z@4HA PROC	; `Tikhonov2D::updateF'::`1'::dtor$10
	lea	rcx, QWORD PTR Af$[rdx]
	jmp	??1?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@XZ
?dtor$10@?0??updateF@Tikhonov2D@@AEAA_NNN@Z@4HA ENDP	; `Tikhonov2D::updateF'::`1'::dtor$10
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 88
tmp$9 = 88
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 88
$T14 = 88
$T15 = 88
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 144
$T21 = 144
$T22 = 144
$T23 = 192
$T24 = 200
df$ = 272
Af$ = 288
__$ArrayPad$ = 304
this$ = 384
lambda$ = 392
relativeError0$ = 400
?dtor$11@?0??updateF@Tikhonov2D@@AEAA_NNN@Z@4HA PROC	; `Tikhonov2D::updateF'::`1'::dtor$11
	mov	rcx, QWORD PTR $T10[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$11@?0??updateF@Tikhonov2D@@AEAA_NNN@Z@4HA ENDP	; `Tikhonov2D::updateF'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
;	COMDAT ??1?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@QEAA@XZ PROC ; Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>::~GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>, COMDAT

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR [rcx+32]
	rex_jmp	QWORD PTR __imp_free
??1?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@QEAA@XZ ENDP ; Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>::~GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
;	COMDAT ??1?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEAA@XZ PROC ; Eigen::ProductBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >::~ProductBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >, COMDAT

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR [rcx+32]
	rex_jmp	QWORD PTR __imp_free
??1?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEAA@XZ ENDP ; Eigen::ProductBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >::~ProductBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\lu\partialpivlu.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\misc\solve.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\matrix.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwiseunaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arraywrapper.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwiseunaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xfunctional
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwiseunaryop.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
;	COMDAT ?updateV@Tikhonov2D@@AEAA_NNN@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 88
tmp$9 = 88
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 88
$T14 = 88
$T15 = 88
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 144
$T21 = 144
$T22 = 144
$T23 = 192
$T24 = 200
dv$ = 272
Af$ = 288
__$ArrayPad$ = 304
this$ = 384
lambda1$ = 392
vError1$ = 400
?updateV@Tikhonov2D@@AEAA_NNN@Z PROC			; Tikhonov2D::updateV, COMDAT

; 104  : (const double lambda1, const double vError1){

$LN1533:
	mov	rax, rsp
	push	rbp
	push	rdi
	push	r12
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-120]
	sub	rsp, 336				; 00000150H
	mov	QWORD PTR $T23[rbp-256], -2
	mov	QWORD PTR [rax+24], rbx
	mov	QWORD PTR [rax+32], rsi
	movaps	XMMWORD PTR [rax-56], xmm6
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	movaps	xmm6, xmm2
	mov	r14, rcx

; 105  : 	setJandH(0.0, lambda1*lambda1);

	mulsd	xmm1, xmm1
	movaps	xmm2, xmm1
	xorps	xmm1, xmm1
	call	?setJandH@Tikhonov2D@@AEAA_NNN@Z	; Tikhonov2D::setJandH
	xor	eax, eax
	mov	QWORD PTR dv$[rbp-256], rax
	mov	QWORD PTR dv$[rbp-248], rax

; 109  : 	Eigen::VectorXd dv = -Hvv.lu().solve(Jv);

	lea	rcx, QWORD PTR [r14+352]
	lea	rdx, QWORD PTR $T24[rbp-256]
	call	?lu@?$MatrixBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA?BV?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@XZ ; Eigen::MatrixBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::lu
	mov	rbx, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\lu\partialpivlu.h

; 135  :       eigen_assert(m_isInitialized && "PartialPivLU is not initialized.");

	cmp	BYTE PTR [rax+64], 0
	jne	SHORT $LN26@updateV
	mov	r8d, 135				; 00000087H
	lea	rdx, OFFSET FLAT:??_C@_1LG@KJLFHBNJ@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GM@KOAFCMGF@?$AAm?$AA_?$AAi?$AAs?$AAI?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AAd?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAP?$AAa?$AAr?$AAt?$AAi?$AAa?$AAl?$AAP?$AAi?$AAv?$AAL?$AAU@
	call	QWORD PTR __imp__wassert
$LN26@updateV:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\misc\solve.h

; 42   :   {}

	mov	QWORD PTR $T15[rsp+8], rbx
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 109  : 	Eigen::VectorXd dv = -Hvv.lu().solve(Jv);

	lea	rax, QWORD PTR [r14+288]
	mov	QWORD PTR $T15[rsp+16], rax
	lea	rdx, QWORD PTR $T22[rbp-256]
	lea	rcx, QWORD PTR $T15[rsp+1]
	call	??G?$MatrixBase@V?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@Eigen@@@Eigen@@QEBA?BV?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@1@XZ ; Eigen::MatrixBase<Eigen::ReturnByValue<Eigen::internal::solve_retval_base<Eigen::PartialPivLU<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::Matrix<double,-1,1,0,-1,1> > > >::operator-
	npad	1
	xor	r15d, r15d
	test	rax, rax
	je	SHORT $LN5@updateV
	lea	rbx, QWORD PTR [rax+1]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	test	rbx, rbx
	je	SHORT $LN52@updateV
	lea	rsi, QWORD PTR [rbx-1]
	jmp	SHORT $LN53@updateV
$LN5@updateV:
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 109  : 	Eigen::VectorXd dv = -Hvv.lu().solve(Jv);

	mov	rbx, r15
$LN52@updateV:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	mov	rsi, r15
$LN53@updateV:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 313  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rsi, QWORD PTR [rsi+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	test	rbx, rbx
	lea	rax, QWORD PTR [rbx-1]
	jne	SHORT $LN65@updateV
	mov	rax, r15
$LN65@updateV:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\matrix.h

; 274  :     {

	mov	rax, QWORD PTR [rax+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 420  :   if(size==0)

	test	rax, rax
	jne	SHORT $LN90@updateV

; 421  :     return 0; // short-cut. Also fixes Bug 884

	mov	rax, r15
	jmp	SHORT $LN91@updateV
$LN90@updateV:

; 244  :   #elif EIGEN_HAS_POSIX_MEMALIGN
; 245  :     std::free(ptr);
; 246  :   #elif EIGEN_HAS_MM_MALLOC
; 247  :     _mm_free(ptr);
; 248  :   #elif defined(_MSC_VER) && (!defined(_WIN32_WCE))
; 249  :     _aligned_free(ptr);
; 250  :   #else
; 251  :     handmade_aligned_free(ptr);
; 252  :   #endif
; 253  : }
; 254  : 
; 255  : /**
; 256  : * \internal
; 257  : * \brief Reallocates an aligned block of memory.
; 258  : * \throws std::bad_alloc on allocation failure
; 259  : **/
; 260  : inline void* aligned_realloc(void *ptr, size_t new_size, size_t old_size)
; 261  : {
; 262  :   EIGEN_UNUSED_VARIABLE(old_size);
; 263  : 
; 264  :   void *result;
; 265  : #if !EIGEN_ALIGN
; 266  :   result = std::realloc(ptr,new_size);
; 267  : #elif EIGEN_MALLOC_ALREADY_ALIGNED
; 268  :   result = std::realloc(ptr,new_size);
; 269  : #elif EIGEN_HAS_POSIX_MEMALIGN
; 270  :   result = generic_aligned_realloc(ptr,new_size,old_size);
; 271  : #elif EIGEN_HAS_MM_MALLOC
; 272  :   // The defined(_mm_free) is just here to verify that this MSVC version
; 273  :   // implements _mm_malloc/_mm_free based on the corresponding _aligned_
; 274  :   // functions. This may not always be the case and we just try to be safe.
; 275  :   #if defined(_MSC_VER) && (!defined(_WIN32_WCE)) && defined(_mm_free)
; 276  :     result = _aligned_realloc(ptr,new_size,16);
; 277  :   #else
; 278  :     result = generic_aligned_realloc(ptr,new_size,old_size);
; 279  :   #endif
; 280  : #elif defined(_MSC_VER) && (!defined(_WIN32_WCE))
; 281  :   result = _aligned_realloc(ptr,new_size,16);
; 282  : #else
; 283  :   result = handmade_aligned_realloc(ptr,new_size,old_size);
; 284  : #endif
; 285  : 
; 286  :   if (!result && new_size)
; 287  :     throw_std_bad_alloc();
; 288  : 
; 289  :   return result;
; 290  : }
; 291  : 
; 292  : /*****************************************************************************
; 293  : *** Implementation of conditionally aligned functions                      ***
; 294  : *****************************************************************************/
; 295  : 
; 296  : /** \internal Allocates \a size bytes. If Align is true, then the returned ptr is 16-byte-aligned.
; 297  :   * On allocation error, the returned pointer is null, and a std::bad_alloc is thrown.
; 298  :   */
; 299  : template<bool Align> inline void* conditional_aligned_malloc(size_t size)
; 300  : {
; 301  :   return aligned_malloc(size);
; 302  : }
; 303  : 
; 304  : template<> inline void* conditional_aligned_malloc<false>(size_t size)
; 305  : {
; 306  :   check_that_malloc_is_allowed();
; 307  : 
; 308  :   void *result = std::malloc(size);
; 309  :   if(!result && size)
; 310  :     throw_std_bad_alloc();
; 311  :   return result;
; 312  : }
; 313  : 
; 314  : /** \internal Frees memory allocated with conditional_aligned_malloc */
; 315  : template<bool Align> inline void conditional_aligned_free(void *ptr)
; 316  : {
; 317  :   aligned_free(ptr);
; 318  : }
; 319  : 
; 320  : template<> inline void conditional_aligned_free<false>(void *ptr)
; 321  : {
; 322  :   std::free(ptr);
; 323  : }
; 324  : 
; 325  : template<bool Align> inline void* conditional_aligned_realloc(void* ptr, size_t new_size, size_t old_size)
; 326  : {
; 327  :   return aligned_realloc(ptr, new_size, old_size);
; 328  : }
; 329  : 
; 330  : template<> inline void* conditional_aligned_realloc<false>(void* ptr, size_t new_size, size_t)
; 331  : {
; 332  :   return std::realloc(ptr, new_size);
; 333  : }
; 334  : 
; 335  : /*****************************************************************************
; 336  : *** Construction/destruction of array elements                             ***
; 337  : *****************************************************************************/
; 338  : 
; 339  : /** \internal Constructs the elements of an array.
; 340  :   * The \a size parameter tells on how many objects to call the constructor of T.
; 341  :   */
; 342  : template<typename T> inline T* construct_elements_of_array(T *ptr, size_t size)
; 343  : {
; 344  :   for (size_t i=0; i < size; ++i) ::new (ptr + i) T;
; 345  :   return ptr;
; 346  : }
; 347  : 
; 348  : /** \internal Destructs the elements of an array.
; 349  :   * The \a size parameters tells on how many objects to call the destructor of T.
; 350  :   */
; 351  : template<typename T> inline void destruct_elements_of_array(T *ptr, size_t size)
; 352  : {
; 353  :   // always destruct an array starting from the end.
; 354  :   if(ptr)
; 355  :     while(size) ptr[--size].~T();
; 356  : }
; 357  : 
; 358  : /*****************************************************************************
; 359  : *** Implementation of aligned new/delete-like functions                    ***
; 360  : *****************************************************************************/
; 361  : 
; 362  : template<typename T>
; 363  : EIGEN_ALWAYS_INLINE void check_size_for_overflow(size_t size)
; 364  : {
; 365  :   if(size > size_t(-1) / sizeof(T))

	mov	rcx, 2305843009213693951		; 1fffffffffffffffH
	cmp	rax, rcx
	jbe	SHORT $LN93@updateV

; 366  :     throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN93@updateV:

; 422  :   check_size_for_overflow<T>(size);
; 423  :   T *result = reinterpret_cast<T*>(conditional_aligned_malloc<Align>(sizeof(T)*size));

	lea	rdi, QWORD PTR [rax*8]

; 220  :     result = std::malloc(size);

	mov	rcx, rdi
	call	QWORD PTR __imp_malloc

; 221  :   #elif EIGEN_HAS_POSIX_MEMALIGN
; 222  :     if(posix_memalign(&result, 16, size)) result = 0;
; 223  :   #elif EIGEN_HAS_MM_MALLOC
; 224  :     result = _mm_malloc(size, 16);
; 225  :   #elif defined(_MSC_VER) && (!defined(_WIN32_WCE))
; 226  :     result = _aligned_malloc(size, 16);
; 227  :   #else
; 228  :     result = handmade_aligned_malloc(size);
; 229  :   #endif
; 230  : 
; 231  :   if(!result && size)

	test	rax, rax
	jne	SHORT $LN91@updateV
	test	rdi, rdi
	je	SHORT $LN91@updateV

; 232  :     throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN91@updateV:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 310  :     { EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN }

	mov	QWORD PTR dv$[rbp-256], rax
	mov	QWORD PTR dv$[rbp-248], rsi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	test	rbx, rbx
	je	SHORT $LN114@updateV
	dec	rbx
	jmp	SHORT $LN115@updateV
$LN114@updateV:
	mov	rbx, r15
$LN115@updateV:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 520  :   static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }

	inc	rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	je	SHORT $LN120@updateV
	lea	rdi, QWORD PTR [rbx-1]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 520  :   static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }

	test	rdi, rdi
	je	SHORT $LN120@updateV
	inc	rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	je	SHORT $LN142@updateV
	lea	rbx, QWORD PTR [rdi-1]
	jmp	SHORT $LN143@updateV
$LN120@updateV:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 520  :   static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }

	mov	rdi, r15
$LN142@updateV:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	mov	rbx, r15
$LN143@updateV:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 313  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rbx, QWORD PTR [rbx+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	mov	r12, 9223372036854775807		; 7fffffffffffffffH
	test	rbx, rbx
	je	SHORT $LN1529@updateV
	cmp	rbx, r12
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN156@updateV

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN156@updateV:

; 47   :   }
; 48   : };
; 49   : 
; 50   : template <typename Derived,
; 51   :           typename OtherDerived = Derived,
; 52   :           bool IsVector = bool(Derived::IsVectorAtCompileTime) && bool(OtherDerived::IsVectorAtCompileTime)>
; 53   : struct conservative_resize_like_impl;
; 54   : 
; 55   : template<typename MatrixTypeA, typename MatrixTypeB, bool SwapPointers> struct matrix_swap_impl;
; 56   : 
; 57   : } // end namespace internal
; 58   : 
; 59   : /** \class PlainObjectBase
; 60   :   * \brief %Dense storage base class for matrices and arrays.
; 61   :   *
; 62   :   * This class can be extended with the help of the plugin mechanism described on the page
; 63   :   * \ref TopicCustomizingEigen by defining the preprocessor symbol \c EIGEN_PLAINOBJECTBASE_PLUGIN.
; 64   :   *
; 65   :   * \sa \ref TopicClassHierarchy
; 66   :   */
; 67   : #ifdef EIGEN_PARSED_BY_DOXYGEN
; 68   : namespace internal {
; 69   : 
; 70   : // this is a warkaround to doxygen not being able to understand the inheritence logic
; 71   : // when it is hidden by the dense_xpr_base helper struct.
; 72   : template<typename Derived> struct dense_xpr_base_dispatcher_for_doxygen;// : public MatrixBase<Derived> {};
; 73   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 74   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 75   : struct dense_xpr_base_dispatcher_for_doxygen<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 76   :     : public MatrixBase<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 77   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 78   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 79   : struct dense_xpr_base_dispatcher_for_doxygen<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 80   :     : public ArrayBase<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 81   : 
; 82   : } // namespace internal
; 83   : 
; 84   : template<typename Derived>
; 85   : class PlainObjectBase : public internal::dense_xpr_base_dispatcher_for_doxygen<Derived>
; 86   : #else
; 87   : template<typename Derived>
; 88   : class PlainObjectBase : public internal::dense_xpr_base<Derived>::type
; 89   : #endif
; 90   : {
; 91   :   public:
; 92   :     enum { Options = internal::traits<Derived>::Options };
; 93   :     typedef typename internal::dense_xpr_base<Derived>::type Base;
; 94   : 
; 95   :     typedef typename internal::traits<Derived>::StorageKind StorageKind;
; 96   :     typedef typename internal::traits<Derived>::Index Index;
; 97   :     typedef typename internal::traits<Derived>::Scalar Scalar;
; 98   :     typedef typename internal::packet_traits<Scalar>::type PacketScalar;
; 99   :     typedef typename NumTraits<Scalar>::Real RealScalar;
; 100  :     typedef Derived DenseType;
; 101  : 
; 102  :     using Base::RowsAtCompileTime;
; 103  :     using Base::ColsAtCompileTime;
; 104  :     using Base::SizeAtCompileTime;
; 105  :     using Base::MaxRowsAtCompileTime;
; 106  :     using Base::MaxColsAtCompileTime;
; 107  :     using Base::MaxSizeAtCompileTime;
; 108  :     using Base::IsVectorAtCompileTime;
; 109  :     using Base::Flags;
; 110  : 
; 111  :     template<typename PlainObjectType, int MapOptions, typename StrideType> friend class Eigen::Map;
; 112  :     friend  class Eigen::Map<Derived, Unaligned>;
; 113  :     typedef Eigen::Map<Derived, Unaligned>  MapType;
; 114  :     friend  class Eigen::Map<const Derived, Unaligned>;
; 115  :     typedef const Eigen::Map<const Derived, Unaligned> ConstMapType;
; 116  :     friend  class Eigen::Map<Derived, Aligned>;
; 117  :     typedef Eigen::Map<Derived, Aligned> AlignedMapType;
; 118  :     friend  class Eigen::Map<const Derived, Aligned>;
; 119  :     typedef const Eigen::Map<const Derived, Aligned> ConstAlignedMapType;
; 120  :     template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };
; 121  :     template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };
; 122  :     template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, Aligned, StrideType> type; };
; 123  :     template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, Aligned, StrideType> type; };
; 124  : 
; 125  :   protected:
; 126  :     DenseStorage<Scalar, Base::MaxSizeAtCompileTime, Base::RowsAtCompileTime, Base::ColsAtCompileTime, Options> m_storage;
; 127  : 
; 128  :   public:
; 129  :     enum { NeedsToAlign = SizeAtCompileTime != Dynamic && (internal::traits<Derived>::Flags & AlignedBit) != 0 };
; 130  :     EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(NeedsToAlign)
; 131  : 
; 132  :     Base& base() { return *static_cast<Base*>(this); }
; 133  :     const Base& base() const { return *static_cast<const Base*>(this); }
; 134  : 
; 135  :     EIGEN_STRONG_INLINE Index rows() const { return m_storage.rows(); }
; 136  :     EIGEN_STRONG_INLINE Index cols() const { return m_storage.cols(); }
; 137  : 
; 138  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index rowId, Index colId) const
; 139  :     {
; 140  :       if(Flags & RowMajorBit)
; 141  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 142  :       else // column-major
; 143  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 144  :     }
; 145  : 
; 146  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index index) const
; 147  :     {
; 148  :       return m_storage.data()[index];
; 149  :     }
; 150  : 
; 151  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index rowId, Index colId)
; 152  :     {
; 153  :       if(Flags & RowMajorBit)
; 154  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 155  :       else // column-major
; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 157  :     }
; 158  : 
; 159  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
; 160  :     {
; 161  :       return m_storage.data()[index];
; 162  :     }
; 163  : 
; 164  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
; 165  :     {
; 166  :       if(Flags & RowMajorBit)
; 167  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 168  :       else // column-major
; 169  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 170  :     }
; 171  : 
; 172  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
; 173  :     {
; 174  :       return m_storage.data()[index];
; 175  :     }
; 176  : 
; 177  :     /** \internal */
; 178  :     template<int LoadMode>
; 179  :     EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const
; 180  :     {
; 181  :       return internal::ploadt<PacketScalar, LoadMode>
; 182  :                (m_storage.data() + (Flags & RowMajorBit
; 183  :                                    ? colId + rowId * m_storage.cols()
; 184  :                                    : rowId + colId * m_storage.rows()));
; 185  :     }
; 186  : 
; 187  :     /** \internal */
; 188  :     template<int LoadMode>
; 189  :     EIGEN_STRONG_INLINE PacketScalar packet(Index index) const
; 190  :     {
; 191  :       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);
; 192  :     }
; 193  : 
; 194  :     /** \internal */
; 195  :     template<int StoreMode>
; 196  :     EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)
; 197  :     {
; 198  :       internal::pstoret<Scalar, PacketScalar, StoreMode>
; 199  :               (m_storage.data() + (Flags & RowMajorBit
; 200  :                                    ? colId + rowId * m_storage.cols()
; 201  :                                    : rowId + colId * m_storage.rows()), val);
; 202  :     }
; 203  : 
; 204  :     /** \internal */
; 205  :     template<int StoreMode>
; 206  :     EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
; 207  :     {
; 208  :       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
; 209  :     }
; 210  : 
; 211  :     /** \returns a const pointer to the data array of this matrix */
; 212  :     EIGEN_STRONG_INLINE const Scalar *data() const
; 213  :     { return m_storage.data(); }
; 214  : 
; 215  :     /** \returns a pointer to the data array of this matrix */
; 216  :     EIGEN_STRONG_INLINE Scalar *data()
; 217  :     { return m_storage.data(); }
; 218  : 
; 219  :     /** Resizes \c *this to a \a rows x \a cols matrix.
; 220  :       *
; 221  :       * This method is intended for dynamic-size matrices, although it is legal to call it on any
; 222  :       * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
; 223  :       * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
; 224  :       *
; 225  :       * If the current number of coefficients of \c *this exactly matches the
; 226  :       * product \a rows * \a cols, then no memory allocation is performed and
; 227  :       * the current values are left unchanged. In all other cases, including
; 228  :       * shrinking, the data is reallocated and all previous values are lost.
; 229  :       *
; 230  :       * Example: \include Matrix_resize_int_int.cpp
; 231  :       * Output: \verbinclude Matrix_resize_int_int.out
; 232  :       *
; 233  :       * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
; 234  :       */
; 235  :     EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)
; 236  :     {
; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rbx, rbx
$LN1529@updateV:
	jns	SHORT $LN235@updateV
	mov	r8d, 241				; 000000f1H
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	call	QWORD PTR __imp__wassert
	mov	rsi, QWORD PTR dv$[rbp-248]
$LN235@updateV:

; 44   :                : (rows > max_index / cols);

	test	rbx, rbx
	je	SHORT $LN242@updateV
	cmp	rbx, r12
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN242@updateV

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN242@updateV:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 322  :       if(size != m_rows*_Cols)

	cmp	rbx, rsi
	je	SHORT $LN247@updateV
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR dv$[rbp-256]
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 325  :         if (size)

	test	rbx, rbx
	je	SHORT $LN248@updateV

; 326  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

	mov	rcx, rbx
	call	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
	mov	QWORD PTR dv$[rbp-256], rax

; 327  :         else

	jmp	SHORT $LN247@updateV
$LN248@updateV:

; 328  :           m_data = 0;

	mov	QWORD PTR dv$[rbp-256], r15
$LN247@updateV:

; 329  :         EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN
; 330  :       }
; 331  :       m_rows = nbRows;

	mov	QWORD PTR dv$[rbp-248], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	test	rdi, rdi
	je	SHORT $LN128@updateV
	dec	rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 414  :       return Base::lazyAssign(other.derived());

	je	SHORT $LN128@updateV
	inc	rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	je	SHORT $LN331@updateV
	lea	rax, QWORD PTR [rdi-1]
	jmp	SHORT $LN332@updateV
$LN128@updateV:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 414  :       return Base::lazyAssign(other.derived());

	mov	rdi, r15
$LN331@updateV:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	mov	rax, r15
$LN332@updateV:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	cmp	rbx, QWORD PTR [rax+16]
	je	SHORT $LN318@updateV
	mov	r8d, 498				; 000001f2H
	lea	rdx, OFFSET FLAT:??_C@_1KO@HDGCFKMN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GC@PBCDNLIH@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ@
	call	QWORD PTR __imp__wassert
	mov	rbx, QWORD PTR dv$[rbp-248]
$LN318@updateV:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	test	rdi, rdi
	lea	r10, QWORD PTR [rdi-1]
	jne	SHORT $LN362@updateV
	mov	r10, r15
$LN362@updateV:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 404  :     const Index alignedEnd = alignedStart + ((size-alignedStart)/packetSize)*packetSize;

	mov	rax, rbx
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r8, rax
	add	r8, r8

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	mov	rcx, r15
	test	r8, r8
	jle	SHORT $LN1527@updateV
	movdqa	xmm1, XMMWORD PTR __xmm@80000000000000008000000000000000
$LL367@updateV:

; 409  :     {
; 410  :       dst.template copyPacket<Derived2, dstAlignment, srcAlignment>(index, src);

	test	r10, r10
	je	SHORT $LN410@updateV
	lea	rax, QWORD PTR [r10+1]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	test	rax, rax
	je	SHORT $LN410@updateV
	dec	rax
	jmp	SHORT $LN411@updateV
$LN410@updateV:
	mov	rax, r15
$LN411@updateV:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 538  :         other.derived().template packet<LoadMode>(index));

	inc	rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	je	SHORT $LN416@updateV
	dec	rax
	jmp	SHORT $LN417@updateV
$LN416@updateV:
	mov	rax, r15
$LN417@updateV:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 333  :     inline const T *data() const { return m_data; }

	mov	rax, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 138  :   return _mm_xor_pd(a,mask);

	movaps	xmm0, xmm1
	xorps	xmm0, XMMWORD PTR [rax+rcx*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	mov	rax, QWORD PTR dv$[rbp-256]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [rax+rcx*8], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	add	rcx, 2
	cmp	rcx, r8
	jl	SHORT $LL367@updateV
$LN1527@updateV:

; 411  :     }
; 412  : 
; 413  :     unaligned_assign_impl<>::run(src,dst,alignedEnd,size);

	mov	r9, rbx
	lea	rdx, QWORD PTR dv$[rbp-256]
	mov	rcx, r10
	call	??$run@V?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@?$unaligned_assign_impl@$0A@@internal@Eigen@@SAXAEBV?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@2@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@_J2@Z ; Eigen::internal::unaligned_assign_impl<0>::run<Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>,Eigen::ReturnByValue<Eigen::internal::solve_retval_base<Eigen::PartialPivLU<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::Matrix<double,-1,1,0,-1,1> > > const >,Eigen::Matrix<double,-1,1,0,-1,1> >
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR $T22[rbp-248]
	call	QWORD PTR __imp_free
	npad	1
	mov	rcx, QWORD PTR $T24[rbp-216]
	call	QWORD PTR __imp_free
	mov	rcx, QWORD PTR $T24[rbp-232]
	call	QWORD PTR __imp_free
	mov	rcx, QWORD PTR $T24[rbp-256]
	call	QWORD PTR __imp_free
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 110  : 	v += dv;

	lea	rdi, QWORD PTR [r14+416]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h

; 55   :     inline SelfCwiseBinaryOp(Lhs& xpr, const BinaryOp& func = BinaryOp()) : m_matrix(xpr), m_functor(func) {}

	mov	QWORD PTR tmp$9[rsp], rdi
	lea	rax, QWORD PTR $T1[rsp]
	mov	QWORD PTR tmp$9[rsp+8], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 313  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rax, QWORD PTR [rdi+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h

; 136  :       eigen_assert(rows() == rhs.rows() && cols() == rhs.cols());

	cmp	rax, QWORD PTR dv$[rbp-248]
	je	SHORT $LN568@updateV
	mov	r8d, 136				; 00000088H
	lea	rdx, OFFSET FLAT:??_C@_1ME@CGCHACLK@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1FK@JAKLMIFJ@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAr?$AAh?$AAs?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN@
	call	QWORD PTR __imp__wassert
$LN568@updateV:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 395  :     const Index size = dst.size();

	mov	r9, QWORD PTR [rdi+8]

; 404  :     const Index alignedEnd = alignedStart + ((size-alignedStart)/packetSize)*packetSize;

	mov	rax, r9
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r8, rax
	add	r8, r8

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	mov	rdx, r15
	test	r8, r8
	jle	SHORT $LN599@updateV
	npad	1
$LL601@updateV:
	mov	rax, QWORD PTR dv$[rbp-256]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 333  :     inline const T *data() const { return m_data; }

	mov	rcx, QWORD PTR [rdi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 220  : template<> EIGEN_STRONG_INLINE Packet2d pload<Packet2d>(const double*  from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_pd(from); }

	movaps	xmm0, XMMWORD PTR [rcx+rdx*8]

; 123  : template<> EIGEN_STRONG_INLINE Packet2d padd<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_add_pd(a,b); }

	addpd	xmm0, XMMWORD PTR [rax+rdx*8]

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [rcx+rdx*8], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	add	rdx, 2
	cmp	rdx, r8
	jl	SHORT $LL601@updateV
$LN599@updateV:

; 411  :     }
; 412  : 
; 413  :     unaligned_assign_impl<>::run(src,dst,alignedEnd,size);

	lea	rdx, QWORD PTR tmp$9[rsp]
	lea	rcx, QWORD PTR dv$[rbp-256]
	call	??$run@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V43@@2@@?$unaligned_assign_impl@$0A@@internal@Eigen@@SAXAEBV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V43@@2@_J2@Z ; Eigen::internal::unaligned_assign_impl<0>::run<Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Matrix<double,-1,1,0,-1,1> > >
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 112  : 	IGORdata::write_itx(f, "output/debug/f.itx", "FF");

	lea	rax, QWORD PTR $T7[rsp]
	mov	QWORD PTR $T14[rsp], rax
	mov	QWORD PTR $T7[rsp+24], 15
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T7[rsp+16], r15
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T7[rsp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 2
	lea	rdx, OFFSET FLAT:??_C@_02NCIKDPBM@FF?$AA@
	lea	rcx, QWORD PTR $T7[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
	mov	QWORD PTR $T19[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T19[rbp-240], r15
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T19[rsp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 18
	lea	rdx, OFFSET FLAT:??_C@_0BD@GOPMHKAF@output?1debug?1f?4itx?$AA@
	lea	rcx, QWORD PTR $T19[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 112  : 	IGORdata::write_itx(f, "output/debug/f.itx", "FF");

	lea	rbx, QWORD PTR [r14+400]
	lea	r8, QWORD PTR $T7[rsp]
	lea	rdx, QWORD PTR $T19[rsp]
	mov	rcx, rbx
	call	??$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z ; IGORdata::write_itx<double,-1,1,0,-1,1>

; 113  : 	IGORdata::write_itx(v, "output/debug/v.itx", "vv");

	lea	rax, QWORD PTR $T6[rsp]
	mov	QWORD PTR $T13[rsp], rax
	mov	QWORD PTR $T6[rsp+24], 15
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T6[rsp+16], r15
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T6[rsp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 2
	lea	rdx, OFFSET FLAT:??_C@_02CJKHOMHP@vv?$AA@
	lea	rcx, QWORD PTR $T6[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
	mov	QWORD PTR $T18[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T18[rbp-240], r15
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T18[rsp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 18
	lea	rdx, OFFSET FLAT:??_C@_0BD@GNCKHIJO@output?1debug?1v?4itx?$AA@
	lea	rcx, QWORD PTR $T18[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 113  : 	IGORdata::write_itx(v, "output/debug/v.itx", "vv");

	lea	r8, QWORD PTR $T6[rsp]
	lea	rdx, QWORD PTR $T18[rsp]
	mov	rcx, rdi
	call	??$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z ; IGORdata::write_itx<double,-1,1,0,-1,1>

; 114  : 	IGORdata::write_itx(dv, "output/debug/dv.itx", "dv");

	lea	rax, QWORD PTR $T5[rsp]
	mov	QWORD PTR $T12[rsp], rax
	mov	QWORD PTR $T5[rsp+24], 15
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T5[rsp+16], r15
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T5[rsp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 2
	lea	rdx, OFFSET FLAT:??_C@_02DGAFJLGB@dv?$AA@
	lea	rcx, QWORD PTR $T5[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
	mov	QWORD PTR $T17[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T17[rbp-240], r15
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T17[rsp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 19
	lea	rdx, OFFSET FLAT:??_C@_0BE@KBBKJCMH@output?1debug?1dv?4itx?$AA@
	lea	rcx, QWORD PTR $T17[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 114  : 	IGORdata::write_itx(dv, "output/debug/dv.itx", "dv");

	lea	r8, QWORD PTR $T5[rsp]
	lea	rdx, QWORD PTR $T17[rsp]
	lea	rcx, QWORD PTR dv$[rbp-256]
	call	??$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z ; IGORdata::write_itx<double,-1,1,0,-1,1>
	xor	eax, eax
	mov	QWORD PTR Af$[rbp-256], rax
	mov	QWORD PTR Af$[rbp-248], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwiseunaryop.h

; 68   :       : m_xpr(xpr), m_functor(func) {}

	mov	QWORD PTR $T11[rsp+8], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arraywrapper.h

; 181  :     inline MatrixWrapper(ExpressionType& a_matrix) : m_expression(a_matrix) {}

	movups	xmm0, XMMWORD PTR $T11[rsp]
	movups	XMMWORD PTR $T4[rsp], xmm0
	movsdx	xmm1, QWORD PTR $T11[rsp+16]
	movsdx	QWORD PTR $T4[rsp+16], xmm1
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 115  : 	Eigen::VectorXd Af = A*f.array().exp().matrix();

	lea	rcx, QWORD PTR [r14+80]
	lea	r8, QWORD PTR $T4[rsp]
	lea	rdx, QWORD PTR $T21[rbp-256]
	call	??$?DV?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@Eigen@@@?$MatrixBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA?BV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@1@AEBV?$MatrixBase@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@Eigen@@@1@@Z ; Eigen::MatrixBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::operator*<Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >
	mov	rdi, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rcx, QWORD PTR [rax]
	mov	rdx, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 442  :     {

	mov	r8, rdx
	lea	rcx, QWORD PTR Af$[rbp-256]
	call	??0?$DenseStorage@N$0?0$0?0$00$0A@@Eigen@@QEAA@_J00@Z ; Eigen::DenseStorage<double,-1,-1,1,0>::DenseStorage<double,-1,-1,1,0>
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rcx, QWORD PTR [rdi]
	mov	rbx, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	test	rbx, rbx
	je	SHORT $LN1531@updateV
	cmp	rbx, r12
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN1082@updateV

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN1082@updateV:

; 47   :   }
; 48   : };
; 49   : 
; 50   : template <typename Derived,
; 51   :           typename OtherDerived = Derived,
; 52   :           bool IsVector = bool(Derived::IsVectorAtCompileTime) && bool(OtherDerived::IsVectorAtCompileTime)>
; 53   : struct conservative_resize_like_impl;
; 54   : 
; 55   : template<typename MatrixTypeA, typename MatrixTypeB, bool SwapPointers> struct matrix_swap_impl;
; 56   : 
; 57   : } // end namespace internal
; 58   : 
; 59   : /** \class PlainObjectBase
; 60   :   * \brief %Dense storage base class for matrices and arrays.
; 61   :   *
; 62   :   * This class can be extended with the help of the plugin mechanism described on the page
; 63   :   * \ref TopicCustomizingEigen by defining the preprocessor symbol \c EIGEN_PLAINOBJECTBASE_PLUGIN.
; 64   :   *
; 65   :   * \sa \ref TopicClassHierarchy
; 66   :   */
; 67   : #ifdef EIGEN_PARSED_BY_DOXYGEN
; 68   : namespace internal {
; 69   : 
; 70   : // this is a warkaround to doxygen not being able to understand the inheritence logic
; 71   : // when it is hidden by the dense_xpr_base helper struct.
; 72   : template<typename Derived> struct dense_xpr_base_dispatcher_for_doxygen;// : public MatrixBase<Derived> {};
; 73   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 74   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 75   : struct dense_xpr_base_dispatcher_for_doxygen<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 76   :     : public MatrixBase<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 77   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 78   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 79   : struct dense_xpr_base_dispatcher_for_doxygen<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 80   :     : public ArrayBase<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 81   : 
; 82   : } // namespace internal
; 83   : 
; 84   : template<typename Derived>
; 85   : class PlainObjectBase : public internal::dense_xpr_base_dispatcher_for_doxygen<Derived>
; 86   : #else
; 87   : template<typename Derived>
; 88   : class PlainObjectBase : public internal::dense_xpr_base<Derived>::type
; 89   : #endif
; 90   : {
; 91   :   public:
; 92   :     enum { Options = internal::traits<Derived>::Options };
; 93   :     typedef typename internal::dense_xpr_base<Derived>::type Base;
; 94   : 
; 95   :     typedef typename internal::traits<Derived>::StorageKind StorageKind;
; 96   :     typedef typename internal::traits<Derived>::Index Index;
; 97   :     typedef typename internal::traits<Derived>::Scalar Scalar;
; 98   :     typedef typename internal::packet_traits<Scalar>::type PacketScalar;
; 99   :     typedef typename NumTraits<Scalar>::Real RealScalar;
; 100  :     typedef Derived DenseType;
; 101  : 
; 102  :     using Base::RowsAtCompileTime;
; 103  :     using Base::ColsAtCompileTime;
; 104  :     using Base::SizeAtCompileTime;
; 105  :     using Base::MaxRowsAtCompileTime;
; 106  :     using Base::MaxColsAtCompileTime;
; 107  :     using Base::MaxSizeAtCompileTime;
; 108  :     using Base::IsVectorAtCompileTime;
; 109  :     using Base::Flags;
; 110  : 
; 111  :     template<typename PlainObjectType, int MapOptions, typename StrideType> friend class Eigen::Map;
; 112  :     friend  class Eigen::Map<Derived, Unaligned>;
; 113  :     typedef Eigen::Map<Derived, Unaligned>  MapType;
; 114  :     friend  class Eigen::Map<const Derived, Unaligned>;
; 115  :     typedef const Eigen::Map<const Derived, Unaligned> ConstMapType;
; 116  :     friend  class Eigen::Map<Derived, Aligned>;
; 117  :     typedef Eigen::Map<Derived, Aligned> AlignedMapType;
; 118  :     friend  class Eigen::Map<const Derived, Aligned>;
; 119  :     typedef const Eigen::Map<const Derived, Aligned> ConstAlignedMapType;
; 120  :     template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };
; 121  :     template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };
; 122  :     template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, Aligned, StrideType> type; };
; 123  :     template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, Aligned, StrideType> type; };
; 124  : 
; 125  :   protected:
; 126  :     DenseStorage<Scalar, Base::MaxSizeAtCompileTime, Base::RowsAtCompileTime, Base::ColsAtCompileTime, Options> m_storage;
; 127  : 
; 128  :   public:
; 129  :     enum { NeedsToAlign = SizeAtCompileTime != Dynamic && (internal::traits<Derived>::Flags & AlignedBit) != 0 };
; 130  :     EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(NeedsToAlign)
; 131  : 
; 132  :     Base& base() { return *static_cast<Base*>(this); }
; 133  :     const Base& base() const { return *static_cast<const Base*>(this); }
; 134  : 
; 135  :     EIGEN_STRONG_INLINE Index rows() const { return m_storage.rows(); }
; 136  :     EIGEN_STRONG_INLINE Index cols() const { return m_storage.cols(); }
; 137  : 
; 138  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index rowId, Index colId) const
; 139  :     {
; 140  :       if(Flags & RowMajorBit)
; 141  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 142  :       else // column-major
; 143  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 144  :     }
; 145  : 
; 146  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index index) const
; 147  :     {
; 148  :       return m_storage.data()[index];
; 149  :     }
; 150  : 
; 151  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index rowId, Index colId)
; 152  :     {
; 153  :       if(Flags & RowMajorBit)
; 154  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 155  :       else // column-major
; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 157  :     }
; 158  : 
; 159  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
; 160  :     {
; 161  :       return m_storage.data()[index];
; 162  :     }
; 163  : 
; 164  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
; 165  :     {
; 166  :       if(Flags & RowMajorBit)
; 167  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 168  :       else // column-major
; 169  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 170  :     }
; 171  : 
; 172  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
; 173  :     {
; 174  :       return m_storage.data()[index];
; 175  :     }
; 176  : 
; 177  :     /** \internal */
; 178  :     template<int LoadMode>
; 179  :     EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const
; 180  :     {
; 181  :       return internal::ploadt<PacketScalar, LoadMode>
; 182  :                (m_storage.data() + (Flags & RowMajorBit
; 183  :                                    ? colId + rowId * m_storage.cols()
; 184  :                                    : rowId + colId * m_storage.rows()));
; 185  :     }
; 186  : 
; 187  :     /** \internal */
; 188  :     template<int LoadMode>
; 189  :     EIGEN_STRONG_INLINE PacketScalar packet(Index index) const
; 190  :     {
; 191  :       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);
; 192  :     }
; 193  : 
; 194  :     /** \internal */
; 195  :     template<int StoreMode>
; 196  :     EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)
; 197  :     {
; 198  :       internal::pstoret<Scalar, PacketScalar, StoreMode>
; 199  :               (m_storage.data() + (Flags & RowMajorBit
; 200  :                                    ? colId + rowId * m_storage.cols()
; 201  :                                    : rowId + colId * m_storage.rows()), val);
; 202  :     }
; 203  : 
; 204  :     /** \internal */
; 205  :     template<int StoreMode>
; 206  :     EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
; 207  :     {
; 208  :       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
; 209  :     }
; 210  : 
; 211  :     /** \returns a const pointer to the data array of this matrix */
; 212  :     EIGEN_STRONG_INLINE const Scalar *data() const
; 213  :     { return m_storage.data(); }
; 214  : 
; 215  :     /** \returns a pointer to the data array of this matrix */
; 216  :     EIGEN_STRONG_INLINE Scalar *data()
; 217  :     { return m_storage.data(); }
; 218  : 
; 219  :     /** Resizes \c *this to a \a rows x \a cols matrix.
; 220  :       *
; 221  :       * This method is intended for dynamic-size matrices, although it is legal to call it on any
; 222  :       * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
; 223  :       * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
; 224  :       *
; 225  :       * If the current number of coefficients of \c *this exactly matches the
; 226  :       * product \a rows * \a cols, then no memory allocation is performed and
; 227  :       * the current values are left unchanged. In all other cases, including
; 228  :       * shrinking, the data is reallocated and all previous values are lost.
; 229  :       *
; 230  :       * Example: \include Matrix_resize_int_int.cpp
; 231  :       * Output: \verbinclude Matrix_resize_int_int.out
; 232  :       *
; 233  :       * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
; 234  :       */
; 235  :     EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)
; 236  :     {
; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rbx, rbx
$LN1531@updateV:
	jns	SHORT $LN1179@updateV
	mov	r8d, 241				; 000000f1H
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	call	QWORD PTR __imp__wassert
$LN1179@updateV:

; 44   :                : (rows > max_index / cols);

	test	rbx, rbx
	je	SHORT $LN1186@updateV
	cmp	rbx, r12
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN1186@updateV

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN1186@updateV:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 322  :       if(size != m_rows*_Cols)

	cmp	rbx, QWORD PTR Af$[rbp-248]
	je	SHORT $LN1191@updateV
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR Af$[rbp-256]
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 325  :         if (size)

	test	rbx, rbx
	je	SHORT $LN1192@updateV

; 326  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

	mov	rcx, rbx
	call	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
	mov	QWORD PTR Af$[rbp-256], rax

; 327  :         else

	jmp	SHORT $LN1191@updateV
$LN1192@updateV:

; 328  :           m_data = 0;

	mov	QWORD PTR Af$[rbp-256], r15
$LN1191@updateV:

; 329  :         EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN
; 330  :       }
; 331  :       m_rows = nbRows;

	mov	QWORD PTR Af$[rbp-248], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h

; 284  :   other.derived().evalTo(derived());

	lea	rdx, QWORD PTR Af$[rbp-256]
	mov	rcx, rdi
	call	??$evalTo@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEBAXAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@@Z ; Eigen::ProductBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >::evalTo<Eigen::Matrix<double,-1,1,0,-1,1> >
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR $T21[rbp-224]
	call	QWORD PTR __imp_free
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 116  : 	IGORdata::write_itx(Af, "output/debug/Af.itx", "Af");

	lea	rax, QWORD PTR $T3[rsp]
	mov	QWORD PTR $T10[rsp], rax
	mov	QWORD PTR $T3[rsp+24], 15
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T3[rsp+16], r15
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T3[rsp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 2
	lea	rdx, OFFSET FLAT:??_C@_02ECEBANDL@Af?$AA@
	lea	rcx, QWORD PTR $T3[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
	mov	QWORD PTR $T16[rbp-232], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T16[rbp-240], r15
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T16[rsp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 19
	lea	rdx, OFFSET FLAT:??_C@_0BE@DPEJIGGH@output?1debug?1Af?4itx?$AA@
	lea	rcx, QWORD PTR $T16[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 116  : 	IGORdata::write_itx(Af, "output/debug/Af.itx", "Af");

	lea	r8, QWORD PTR $T3[rsp]
	lea	rdx, QWORD PTR $T16[rsp]
	lea	rcx, QWORD PTR Af$[rbp-256]
	call	??$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z ; IGORdata::write_itx<double,-1,1,0,-1,1>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwiseunaryop.h

; 68   :       : m_xpr(xpr), m_functor(func) {}

	lea	rax, QWORD PTR dv$[rbp-256]
	mov	QWORD PTR $T2[rsp+8], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xfunctional

; 498  : 		{	// construct from functor and right operand

	movsdx	QWORD PTR $T8[rsp+8], xmm6
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwiseunaryop.h

; 68   :       : m_xpr(xpr), m_functor(func) {}

	movups	xmm0, XMMWORD PTR $T2[rsp]
	movups	XMMWORD PTR $T20[rbp-248], xmm0
	movsdx	xmm1, QWORD PTR $T2[rsp+16]
	movsdx	QWORD PTR $T20[rbp-232], xmm1
	movups	xmm0, XMMWORD PTR $T8[rsp]
	movups	XMMWORD PTR $T20[rbp-224], xmm0
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 130  : 	if ((dv.array().abs() < vError1).all())

	lea	rcx, QWORD PTR $T20[rbp-255]
	call	?all@?$DenseBase@V?$CwiseUnaryOp@V?$binder2nd@U?$less@N@std@@@std@@$$CBV?$CwiseUnaryOp@U?$scalar_abs_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@Eigen@@@Eigen@@QEBA_NXZ ; Eigen::DenseBase<Eigen::CwiseUnaryOp<std::binder2nd<std::less<double> >,Eigen::CwiseUnaryOp<Eigen::internal::scalar_abs_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >::all
	test	al, al
	setne	bl
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR Af$[rbp-256]
	call	QWORD PTR __imp_free
	npad	1
	mov	rcx, QWORD PTR dv$[rbp-256]
	call	QWORD PTR __imp_free
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 133  : 	else return false;

	movzx	eax, bl

; 134  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+336]
	mov	rbx, QWORD PTR [r11+64]
	mov	rsi, QWORD PTR [r11+72]
	movaps	xmm6, XMMWORD PTR [r11-16]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rbp
	ret	0
$LN1528@updateV:
?updateV@Tikhonov2D@@AEAA_NNN@Z ENDP			; Tikhonov2D::updateV
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 88
tmp$9 = 88
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 88
$T14 = 88
$T15 = 88
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 144
$T21 = 144
$T22 = 144
$T23 = 192
$T24 = 200
dv$ = 272
Af$ = 288
__$ArrayPad$ = 304
this$ = 384
lambda1$ = 392
vError1$ = 400
?dtor$0@?0??updateV@Tikhonov2D@@AEAA_NNN@Z@4HA PROC	; `Tikhonov2D::updateV'::`1'::dtor$0
	lea	rcx, QWORD PTR $T24[rdx]
	jmp	??1?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAA@XZ
?dtor$0@?0??updateV@Tikhonov2D@@AEAA_NNN@Z@4HA ENDP	; `Tikhonov2D::updateV'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 88
tmp$9 = 88
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 88
$T14 = 88
$T15 = 88
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 144
$T21 = 144
$T22 = 144
$T23 = 192
$T24 = 200
dv$ = 272
Af$ = 288
__$ArrayPad$ = 304
this$ = 384
lambda1$ = 392
vError1$ = 400
?dtor$1@?0??updateV@Tikhonov2D@@AEAA_NNN@Z@4HA PROC	; `Tikhonov2D::updateV'::`1'::dtor$1
	lea	rcx, QWORD PTR $T22[rdx]
	jmp	??1?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@QEAA@XZ
?dtor$1@?0??updateV@Tikhonov2D@@AEAA_NNN@Z@4HA ENDP	; `Tikhonov2D::updateV'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 88
tmp$9 = 88
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 88
$T14 = 88
$T15 = 88
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 144
$T21 = 144
$T22 = 144
$T23 = 192
$T24 = 200
dv$ = 272
Af$ = 288
__$ArrayPad$ = 304
this$ = 384
lambda1$ = 392
vError1$ = 400
?dtor$13@?0??updateV@Tikhonov2D@@AEAA_NNN@Z@4HA PROC	; `Tikhonov2D::updateV'::`1'::dtor$13
	lea	rcx, QWORD PTR dv$[rdx]
	jmp	??1?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAA@XZ
?dtor$13@?0??updateV@Tikhonov2D@@AEAA_NNN@Z@4HA ENDP	; `Tikhonov2D::updateV'::`1'::dtor$13
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 88
tmp$9 = 88
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 88
$T14 = 88
$T15 = 88
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 144
$T21 = 144
$T22 = 144
$T23 = 192
$T24 = 200
dv$ = 272
Af$ = 288
__$ArrayPad$ = 304
this$ = 384
lambda1$ = 392
vError1$ = 400
?dtor$2@?0??updateV@Tikhonov2D@@AEAA_NNN@Z@4HA PROC	; `Tikhonov2D::updateV'::`1'::dtor$2
	lea	rcx, QWORD PTR dv$[rdx]
	jmp	??1?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@XZ
?dtor$2@?0??updateV@Tikhonov2D@@AEAA_NNN@Z@4HA ENDP	; `Tikhonov2D::updateV'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 88
tmp$9 = 88
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 88
$T14 = 88
$T15 = 88
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 144
$T21 = 144
$T22 = 144
$T23 = 192
$T24 = 200
dv$ = 272
Af$ = 288
__$ArrayPad$ = 304
this$ = 384
lambda1$ = 392
vError1$ = 400
?dtor$3@?0??updateV@Tikhonov2D@@AEAA_NNN@Z@4HA PROC	; `Tikhonov2D::updateV'::`1'::dtor$3
	mov	rcx, QWORD PTR $T14[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0??updateV@Tikhonov2D@@AEAA_NNN@Z@4HA ENDP	; `Tikhonov2D::updateV'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 88
tmp$9 = 88
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 88
$T14 = 88
$T15 = 88
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 144
$T21 = 144
$T22 = 144
$T23 = 192
$T24 = 200
dv$ = 272
Af$ = 288
__$ArrayPad$ = 304
this$ = 384
lambda1$ = 392
vError1$ = 400
?dtor$5@?0??updateV@Tikhonov2D@@AEAA_NNN@Z@4HA PROC	; `Tikhonov2D::updateV'::`1'::dtor$5
	mov	rcx, QWORD PTR $T13[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$5@?0??updateV@Tikhonov2D@@AEAA_NNN@Z@4HA ENDP	; `Tikhonov2D::updateV'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 88
tmp$9 = 88
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 88
$T14 = 88
$T15 = 88
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 144
$T21 = 144
$T22 = 144
$T23 = 192
$T24 = 200
dv$ = 272
Af$ = 288
__$ArrayPad$ = 304
this$ = 384
lambda1$ = 392
vError1$ = 400
?dtor$7@?0??updateV@Tikhonov2D@@AEAA_NNN@Z@4HA PROC	; `Tikhonov2D::updateV'::`1'::dtor$7
	mov	rcx, QWORD PTR $T12[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$7@?0??updateV@Tikhonov2D@@AEAA_NNN@Z@4HA ENDP	; `Tikhonov2D::updateV'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 88
tmp$9 = 88
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 88
$T14 = 88
$T15 = 88
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 144
$T21 = 144
$T22 = 144
$T23 = 192
$T24 = 200
dv$ = 272
Af$ = 288
__$ArrayPad$ = 304
this$ = 384
lambda1$ = 392
vError1$ = 400
?dtor$9@?0??updateV@Tikhonov2D@@AEAA_NNN@Z@4HA PROC	; `Tikhonov2D::updateV'::`1'::dtor$9
	lea	rcx, QWORD PTR $T21[rdx]
	jmp	??1?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@QEAA@XZ
?dtor$9@?0??updateV@Tikhonov2D@@AEAA_NNN@Z@4HA ENDP	; `Tikhonov2D::updateV'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 88
tmp$9 = 88
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 88
$T14 = 88
$T15 = 88
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 144
$T21 = 144
$T22 = 144
$T23 = 192
$T24 = 200
dv$ = 272
Af$ = 288
__$ArrayPad$ = 304
this$ = 384
lambda1$ = 392
vError1$ = 400
?dtor$15@?0??updateV@Tikhonov2D@@AEAA_NNN@Z@4HA PROC	; `Tikhonov2D::updateV'::`1'::dtor$15
	lea	rcx, QWORD PTR Af$[rdx]
	jmp	??1?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAA@XZ
?dtor$15@?0??updateV@Tikhonov2D@@AEAA_NNN@Z@4HA ENDP	; `Tikhonov2D::updateV'::`1'::dtor$15
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 88
tmp$9 = 88
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 88
$T14 = 88
$T15 = 88
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 144
$T21 = 144
$T22 = 144
$T23 = 192
$T24 = 200
dv$ = 272
Af$ = 288
__$ArrayPad$ = 304
this$ = 384
lambda1$ = 392
vError1$ = 400
?dtor$10@?0??updateV@Tikhonov2D@@AEAA_NNN@Z@4HA PROC	; `Tikhonov2D::updateV'::`1'::dtor$10
	lea	rcx, QWORD PTR Af$[rdx]
	jmp	??1?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@XZ
?dtor$10@?0??updateV@Tikhonov2D@@AEAA_NNN@Z@4HA ENDP	; `Tikhonov2D::updateV'::`1'::dtor$10
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 88
tmp$9 = 88
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 88
$T14 = 88
$T15 = 88
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 144
$T21 = 144
$T22 = 144
$T23 = 192
$T24 = 200
dv$ = 272
Af$ = 288
__$ArrayPad$ = 304
this$ = 384
lambda1$ = 392
vError1$ = 400
?dtor$11@?0??updateV@Tikhonov2D@@AEAA_NNN@Z@4HA PROC	; `Tikhonov2D::updateV'::`1'::dtor$11
	mov	rcx, QWORD PTR $T10[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$11@?0??updateV@Tikhonov2D@@AEAA_NNN@Z@4HA ENDP	; `Tikhonov2D::updateV'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\lu\partialpivlu.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\misc\solve.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densebase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densebase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
;	COMDAT ?updateFandV@Tikhonov2D@@AEAA_NNNNN@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 48
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
tmp$9 = 96
tmp$10 = 96
$T11 = 96
$T12 = 96
$T13 = 96
$T14 = 96
$T15 = 120
rhs$16 = 128
rhs$17 = 128
$T18 = 128
$T19 = 128
$T20 = 128
$T21 = 128
__$ArrayPad$ = 200
this$ = 304
lambda0$ = 312
lambda1$ = 320
relativeError0$ = 328
vError1$ = 336
?updateFandV@Tikhonov2D@@AEAA_NNNNN@Z PROC		; Tikhonov2D::updateFandV, COMDAT

; 139  :  const double relativeError0, const double vError1){

$LN1132:
	mov	rax, rsp
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-87]
	sub	rsp, 240				; 000000f0H
	mov	QWORD PTR $T15[rbp-209], -2
	movaps	XMMWORD PTR [rax-72], xmm6
	movaps	XMMWORD PTR [rax-88], xmm7
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-209], rax
	movaps	xmm7, xmm3
	mov	r14, rcx

; 140  : 
; 141  : 	setJandH(lambda0*lambda0, lambda1*lambda1);

	mulsd	xmm2, xmm2
	mulsd	xmm1, xmm1
	call	?setJandH@Tikhonov2D@@AEAA_NNN@Z	; Tikhonov2D::setJandH

; 144  : 	dff = -H.lu().solve(J);

	lea	rcx, QWORD PTR [r14+304]
	lea	rdx, QWORD PTR $T21[rbp-209]
	call	?lu@?$MatrixBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA?BV?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@XZ ; Eigen::MatrixBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::lu
	mov	rbx, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\lu\partialpivlu.h

; 135  :       eigen_assert(m_isInitialized && "PartialPivLU is not initialized.");

	cmp	BYTE PTR [rax+64], 0
	jne	SHORT $LN24@updateFand
	mov	r8d, 135				; 00000087H
	lea	rdx, OFFSET FLAT:??_C@_1LG@KJLFHBNJ@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GM@KOAFCMGF@?$AAm?$AA_?$AAi?$AAs?$AAI?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AAd?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAP?$AAa?$AAr?$AAt?$AAi?$AAa?$AAl?$AAP?$AAi?$AAv?$AAL?$AAU@
	call	QWORD PTR __imp__wassert
$LN24@updateFand:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\misc\solve.h

; 42   :   {}

	mov	QWORD PTR $T14[rbp-201], rbx
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 144  : 	dff = -H.lu().solve(J);

	lea	rax, QWORD PTR [r14+256]
	mov	QWORD PTR $T14[rbp-193], rax
	lea	rdx, QWORD PTR $T8[rsp]
	lea	rcx, QWORD PTR $T14[rbp-208]
	call	??G?$MatrixBase@V?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@Eigen@@@Eigen@@QEBA?BV?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@1@XZ ; Eigen::MatrixBase<Eigen::ReturnByValue<Eigen::internal::solve_retval_base<Eigen::PartialPivLU<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::Matrix<double,-1,1,0,-1,1> > > >::operator-
	npad	1
	xor	ebx, ebx
	test	rax, rax
	je	SHORT $LN11@updateFand
	inc	rax
	jmp	SHORT $LN12@updateFand
$LN11@updateFand:
	mov	rax, rbx
$LN12@updateFand:
	lea	rdi, QWORD PTR [r14+432]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	test	rax, rax
	je	SHORT $LN47@updateFand
	dec	rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 606  :     EIGEN_STRONG_INLINE void _set_selector(const OtherDerived& other, const internal::false_type&) { _set_noalias(other); }

	je	SHORT $LN47@updateFand
	inc	rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	je	SHORT $LN47@updateFand
	dec	rax
	jmp	SHORT $LN48@updateFand
$LN47@updateFand:
	mov	rax, rbx
$LN48@updateFand:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 520  :   static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }

	inc	rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	je	SHORT $LN53@updateFand
	lea	r15, QWORD PTR [rax-1]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 520  :   static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }

	test	r15, r15
	je	SHORT $LN53@updateFand
	inc	r15
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	je	SHORT $LN75@updateFand
	lea	rsi, QWORD PTR [r15-1]
	jmp	SHORT $LN76@updateFand
$LN53@updateFand:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 520  :   static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }

	mov	r15, rbx
$LN75@updateFand:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	mov	rsi, rbx
$LN76@updateFand:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 313  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rsi, QWORD PTR [rsi+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	mov	r12, 9223372036854775807		; 7fffffffffffffffH
	test	rsi, rsi
	je	SHORT $LN1130@updateFand
	cmp	rsi, r12
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN89@updateFand

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN89@updateFand:

; 157  :     }
; 158  : 
; 159  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
; 160  :     {
; 161  :       return m_storage.data()[index];
; 162  :     }
; 163  : 
; 164  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
; 165  :     {
; 166  :       if(Flags & RowMajorBit)
; 167  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 168  :       else // column-major
; 169  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 170  :     }
; 171  : 
; 172  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
; 173  :     {
; 174  :       return m_storage.data()[index];
; 175  :     }
; 176  : 
; 177  :     /** \internal */
; 178  :     template<int LoadMode>
; 179  :     EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const
; 180  :     {
; 181  :       return internal::ploadt<PacketScalar, LoadMode>
; 182  :                (m_storage.data() + (Flags & RowMajorBit
; 183  :                                    ? colId + rowId * m_storage.cols()
; 184  :                                    : rowId + colId * m_storage.rows()));
; 185  :     }
; 186  : 
; 187  :     /** \internal */
; 188  :     template<int LoadMode>
; 189  :     EIGEN_STRONG_INLINE PacketScalar packet(Index index) const
; 190  :     {
; 191  :       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);
; 192  :     }
; 193  : 
; 194  :     /** \internal */
; 195  :     template<int StoreMode>
; 196  :     EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)
; 197  :     {
; 198  :       internal::pstoret<Scalar, PacketScalar, StoreMode>
; 199  :               (m_storage.data() + (Flags & RowMajorBit
; 200  :                                    ? colId + rowId * m_storage.cols()
; 201  :                                    : rowId + colId * m_storage.rows()), val);
; 202  :     }
; 203  : 
; 204  :     /** \internal */
; 205  :     template<int StoreMode>
; 206  :     EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
; 207  :     {
; 208  :       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
; 209  :     }
; 210  : 
; 211  :     /** \returns a const pointer to the data array of this matrix */
; 212  :     EIGEN_STRONG_INLINE const Scalar *data() const
; 213  :     { return m_storage.data(); }
; 214  : 
; 215  :     /** \returns a pointer to the data array of this matrix */
; 216  :     EIGEN_STRONG_INLINE Scalar *data()
; 217  :     { return m_storage.data(); }
; 218  : 
; 219  :     /** Resizes \c *this to a \a rows x \a cols matrix.
; 220  :       *
; 221  :       * This method is intended for dynamic-size matrices, although it is legal to call it on any
; 222  :       * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
; 223  :       * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
; 224  :       *
; 225  :       * If the current number of coefficients of \c *this exactly matches the
; 226  :       * product \a rows * \a cols, then no memory allocation is performed and
; 227  :       * the current values are left unchanged. In all other cases, including
; 228  :       * shrinking, the data is reallocated and all previous values are lost.
; 229  :       *
; 230  :       * Example: \include Matrix_resize_int_int.cpp
; 231  :       * Output: \verbinclude Matrix_resize_int_int.out
; 232  :       *
; 233  :       * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
; 234  :       */
; 235  :     EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)
; 236  :     {
; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rsi, rsi
$LN1130@updateFand:
	jns	SHORT $LN168@updateFand
	mov	r8d, 241				; 000000f1H
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	call	QWORD PTR __imp__wassert
$LN168@updateFand:

; 44   :                : (rows > max_index / cols);

	test	rsi, rsi
	je	SHORT $LN175@updateFand
	cmp	rsi, r12
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN175@updateFand

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN175@updateFand:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 322  :       if(size != m_rows*_Cols)

	cmp	rsi, QWORD PTR [rdi+8]
	je	SHORT $LN180@updateFand
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR [rdi]
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 325  :         if (size)

	test	rsi, rsi
	je	SHORT $LN181@updateFand

; 326  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

	mov	rcx, rsi
	call	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
	mov	QWORD PTR [rdi], rax

; 327  :         else

	jmp	SHORT $LN180@updateFand
$LN181@updateFand:

; 328  :           m_data = 0;

	mov	QWORD PTR [rdi], rbx
$LN180@updateFand:

; 329  :         EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN
; 330  :       }
; 331  :       m_rows = nbRows;

	mov	QWORD PTR [rdi+8], rsi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	test	r15, r15
	je	SHORT $LN61@updateFand
	dec	r15
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 414  :       return Base::lazyAssign(other.derived());

	je	SHORT $LN61@updateFand
	inc	r15
	jmp	SHORT $LN62@updateFand
$LN61@updateFand:
	mov	r15, rbx
$LN62@updateFand:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	test	r15, r15
	lea	rax, QWORD PTR [r15-1]
	jne	SHORT $LN265@updateFand
	mov	rax, rbx
$LN265@updateFand:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	cmp	rsi, QWORD PTR [rax+16]
	je	SHORT $LN251@updateFand
	mov	r8d, 498				; 000001f2H
	lea	rdx, OFFSET FLAT:??_C@_1KO@HDGCFKMN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GC@PBCDNLIH@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ@
	call	QWORD PTR __imp__wassert
$LN251@updateFand:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	test	r15, r15
	lea	r10, QWORD PTR [r15-1]
	jne	SHORT $LN295@updateFand
	mov	r10, rbx
$LN295@updateFand:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 395  :     const Index size = dst.size();

	mov	r9, QWORD PTR [rdi+8]

; 396  :     typedef packet_traits<typename Derived1::Scalar> PacketTraits;
; 397  :     enum {
; 398  :       packetSize = PacketTraits::size,
; 399  :       dstAlignment = PacketTraits::AlignedOnScalar ? Aligned : int(assign_traits<Derived1,Derived2>::DstIsAligned) ,
; 400  :       srcAlignment = assign_traits<Derived1,Derived2>::JointAlignment
; 401  :     };
; 402  :     const Index alignedStart = assign_traits<Derived1,Derived2>::DstIsAligned ? 0
; 403  :                              : internal::first_aligned(&dst.coeffRef(0), size);
; 404  :     const Index alignedEnd = alignedStart + ((size-alignedStart)/packetSize)*packetSize;

	mov	rax, r9
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r8, rax
	add	r8, r8

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	mov	rcx, rbx
	test	r8, r8
	jle	SHORT $LN298@updateFand
	movdqa	xmm1, XMMWORD PTR __xmm@80000000000000008000000000000000
$LL300@updateFand:

; 409  :     {
; 410  :       dst.template copyPacket<Derived2, dstAlignment, srcAlignment>(index, src);

	test	r10, r10
	je	SHORT $LN343@updateFand
	lea	rax, QWORD PTR [r10+1]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	test	rax, rax
	je	SHORT $LN343@updateFand
	dec	rax
	jmp	SHORT $LN344@updateFand
$LN343@updateFand:
	mov	rax, rbx
$LN344@updateFand:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 538  :         other.derived().template packet<LoadMode>(index));

	inc	rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	je	SHORT $LN349@updateFand
	dec	rax
	jmp	SHORT $LN350@updateFand
$LN349@updateFand:
	mov	rax, rbx
$LN350@updateFand:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 333  :     inline const T *data() const { return m_data; }

	mov	rax, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 138  :   return _mm_xor_pd(a,mask);

	movaps	xmm0, xmm1
	xorps	xmm0, XMMWORD PTR [rax+rcx*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 334  :     inline T *data() { return m_data; }

	mov	rax, QWORD PTR [rdi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [rax+rcx*8], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	add	rcx, 2
	cmp	rcx, r8
	jl	SHORT $LL300@updateFand
$LN298@updateFand:

; 411  :     }
; 412  : 
; 413  :     unaligned_assign_impl<>::run(src,dst,alignedEnd,size);

	mov	rdx, rdi
	mov	rcx, r10
	call	??$run@V?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@?$unaligned_assign_impl@$0A@@internal@Eigen@@SAXAEBV?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@2@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@_J2@Z ; Eigen::internal::unaligned_assign_impl<0>::run<Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>,Eigen::ReturnByValue<Eigen::internal::solve_retval_base<Eigen::PartialPivLU<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::Matrix<double,-1,1,0,-1,1> > > const >,Eigen::Matrix<double,-1,1,0,-1,1> >
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR $T8[rsp+8]
	call	QWORD PTR __imp_free
	npad	1
	mov	rcx, QWORD PTR $T21[rbp-169]
	call	QWORD PTR __imp_free
	mov	rcx, QWORD PTR $T21[rbp-185]
	call	QWORD PTR __imp_free
	mov	rcx, QWORD PTR $T21[rbp-209]
	call	QWORD PTR __imp_free
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 145  : 	f += dff.block(0, 0, size_j, 1);

	mov	rsi, QWORD PTR [r14+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];

	mov	rax, QWORD PTR [rdi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 145  :     {

	mov	QWORD PTR $T7[rsp], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h

; 63   :     explicit variable_if_dynamic(T value) : m_value(value) {}

	mov	QWORD PTR $T7[rsp+8], rsi
	mov	QWORD PTR $T7[rsp+16], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 146  :       eigen_assert( (dataPtr == 0)

	test	rax, rax
	je	SHORT $LN514@updateFand
	test	rsi, rsi
	jns	SHORT $LN514@updateFand
	mov	r8d, 148				; 00000094H
	lea	rdx, OFFSET FLAT:??_C@_1LA@MIDGNIKC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1BGE@MDFDAGNB@?$AA?$CI?$AAd?$AAa?$AAt?$AAa?$AAP?$AAt?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$CJ?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AA?$CI?$AA?5?$AAn?$AAb?$AAR?$AAo?$AAw?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5@
	call	QWORD PTR __imp__wassert
$LN514@updateFand:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h

; 351  :     {

	mov	QWORD PTR $T7[rsp+24], rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densebase.h

; 210  :            : int(IsRowMajor) ? this->cols() : this->rows();

	mov	rax, QWORD PTR [rdi+8]
	mov	QWORD PTR $T7[rbp-177], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h

; 140  :       eigen_assert(a_startRow >= 0 && blockRows >= 0 && a_startRow  <= xpr.rows() - blockRows

	test	rsi, rsi
	js	SHORT $LN489@updateFand
	cmp	rax, rsi
	jns	SHORT $LN490@updateFand
$LN489@updateFand:
	mov	r8d, 141				; 0000008dH
	lea	rdx, OFFSET FLAT:??_C@_1KM@LCMGCMD@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1BCO@NFJGBHKC@?$AAa?$AA_?$AAs?$AAt?$AAa?$AAr?$AAt?$AAR?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAb?$AAl?$AAo?$AAc?$AAk?$AAR?$AAo?$AAw?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5@
	call	QWORD PTR __imp__wassert
$LN490@updateFand:
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 145  : 	f += dff.block(0, 0, size_j, 1);

	lea	r12, QWORD PTR [r14+400]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h

; 55   :     inline SelfCwiseBinaryOp(Lhs& xpr, const BinaryOp& func = BinaryOp()) : m_matrix(xpr), m_functor(func) {}

	mov	QWORD PTR tmp$10[rbp-209], r12
	lea	rax, QWORD PTR $T2[rsp]
	mov	QWORD PTR tmp$10[rbp-201], rax

; 138  :     #ifndef EIGEN_NO_DEBUG
; 139  :       this->checkTransposeAliasing(rhs.derived());
; 140  :     #endif
; 141  :       return *this;
; 142  :     }
; 143  :     
; 144  :     // overloaded to honor evaluation of special matrices
; 145  :     // maybe another solution would be to not use SelfCwiseBinaryOp
; 146  :     // at first...
; 147  :     SelfCwiseBinaryOp& operator=(const Rhs& _rhs)
; 148  :     {
; 149  :       typename internal::nested<Rhs>::type rhs(_rhs);

	movups	xmm0, XMMWORD PTR $T7[rsp]
	movups	XMMWORD PTR rhs$17[rbp-209], xmm0
	movups	xmm1, XMMWORD PTR $T7[rsp+16]
	movups	XMMWORD PTR rhs$17[rbp-193], xmm1
	movsdx	xmm0, QWORD PTR $T7[rbp-177]
	movsdx	QWORD PTR rhs$17[rbp-177], xmm0

; 56   : 
; 57   :     inline Index rows() const { return m_matrix.rows(); }
; 58   :     inline Index cols() const { return m_matrix.cols(); }
; 59   :     inline Index outerStride() const { return m_matrix.outerStride(); }
; 60   :     inline Index innerStride() const { return m_matrix.innerStride(); }
; 61   :     inline const Scalar* data() const { return m_matrix.data(); }
; 62   : 
; 63   :     // note that this function is needed by assign to correctly align loads/stores
; 64   :     // TODO make Assign use .data()
; 65   :     inline Scalar& coeffRef(Index row, Index col)
; 66   :     {
; 67   :       EIGEN_STATIC_ASSERT_LVALUE(Lhs)
; 68   :       return m_matrix.const_cast_derived().coeffRef(row, col);
; 69   :     }
; 70   :     inline const Scalar& coeffRef(Index row, Index col) const
; 71   :     {
; 72   :       return m_matrix.coeffRef(row, col);
; 73   :     }
; 74   : 
; 75   :     // note that this function is needed by assign to correctly align loads/stores
; 76   :     // TODO make Assign use .data()
; 77   :     inline Scalar& coeffRef(Index index)
; 78   :     {
; 79   :       EIGEN_STATIC_ASSERT_LVALUE(Lhs)
; 80   :       return m_matrix.const_cast_derived().coeffRef(index);
; 81   :     }
; 82   :     inline const Scalar& coeffRef(Index index) const
; 83   :     {
; 84   :       return m_matrix.const_cast_derived().coeffRef(index);
; 85   :     }
; 86   : 
; 87   :     template<typename OtherDerived>
; 88   :     void copyCoeff(Index row, Index col, const DenseBase<OtherDerived>& other)
; 89   :     {
; 90   :       OtherDerived& _other = other.const_cast_derived();
; 91   :       eigen_internal_assert(row >= 0 && row < rows()
; 92   :                          && col >= 0 && col < cols());
; 93   :       Scalar& tmp = m_matrix.coeffRef(row,col);
; 94   :       tmp = m_functor(tmp, _other.coeff(row,col));
; 95   :     }
; 96   : 
; 97   :     template<typename OtherDerived>
; 98   :     void copyCoeff(Index index, const DenseBase<OtherDerived>& other)
; 99   :     {
; 100  :       OtherDerived& _other = other.const_cast_derived();
; 101  :       eigen_internal_assert(index >= 0 && index < m_matrix.size());
; 102  :       Scalar& tmp = m_matrix.coeffRef(index);
; 103  :       tmp = m_functor(tmp, _other.coeff(index));
; 104  :     }
; 105  : 
; 106  :     template<typename OtherDerived, int StoreMode, int LoadMode>
; 107  :     void copyPacket(Index row, Index col, const DenseBase<OtherDerived>& other)
; 108  :     {
; 109  :       OtherDerived& _other = other.const_cast_derived();
; 110  :       eigen_internal_assert(row >= 0 && row < rows()
; 111  :                         && col >= 0 && col < cols());
; 112  :       m_matrix.template writePacket<StoreMode>(row, col,
; 113  :         m_functor.packetOp(m_matrix.template packet<StoreMode>(row, col),_other.template packet<LoadMode>(row, col)) );
; 114  :     }
; 115  : 
; 116  :     template<typename OtherDerived, int StoreMode, int LoadMode>
; 117  :     void copyPacket(Index index, const DenseBase<OtherDerived>& other)
; 118  :     {
; 119  :       OtherDerived& _other = other.const_cast_derived();
; 120  :       eigen_internal_assert(index >= 0 && index < m_matrix.size());
; 121  :       m_matrix.template writePacket<StoreMode>(index,
; 122  :         m_functor.packetOp(m_matrix.template packet<StoreMode>(index),_other.template packet<LoadMode>(index)) );
; 123  :     }
; 124  : 
; 125  :     // reimplement lazyAssign to handle complex *= real
; 126  :     // see CwiseBinaryOp ctor for details
; 127  :     template<typename RhsDerived>
; 128  :     EIGEN_STRONG_INLINE SelfCwiseBinaryOp& lazyAssign(const DenseBase<RhsDerived>& rhs)
; 129  :     {
; 130  :       EIGEN_STATIC_ASSERT_SAME_MATRIX_SIZE(Lhs,RhsDerived)
; 131  :       EIGEN_CHECK_BINARY_COMPATIBILIY(BinaryOp,typename Lhs::Scalar,typename RhsDerived::Scalar);
; 132  :       
; 133  :     #ifdef EIGEN_DEBUG_ASSIGN
; 134  :       internal::assign_traits<SelfCwiseBinaryOp, RhsDerived>::debug();
; 135  :     #endif
; 136  :       eigen_assert(rows() == rhs.rows() && cols() == rhs.cols());

	cmp	QWORD PTR [r12+8], rsi
	je	SHORT $LN604@updateFand
	mov	r8d, 136				; 00000088H
	lea	rdx, OFFSET FLAT:??_C@_1ME@CGCHACLK@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1FK@JAKLMIFJ@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAr?$AAh?$AAs?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN@
	call	QWORD PTR __imp__wassert
$LN604@updateFand:

; 137  :       internal::assign_impl<SelfCwiseBinaryOp, RhsDerived>::run(*this,rhs.derived());

	lea	rdx, QWORD PTR rhs$17[rbp-209]
	lea	rcx, QWORD PTR tmp$10[rbp-209]
	call	?run@?$assign_impl@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@3@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Z ; Eigen::internal::assign_impl<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,4,0,0>::run
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 146  : 	v += dff.block(size_j, 0, size_j, 1);

	mov	rsi, QWORD PTR [r14+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 334  :     inline T *data() { return m_data; }

	mov	rax, QWORD PTR [rdi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];

	lea	r9, QWORD PTR [rax+rsi*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 145  :     {

	mov	QWORD PTR $T6[rsp], r9
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h

; 63   :     explicit variable_if_dynamic(T value) : m_value(value) {}

	mov	QWORD PTR $T6[rsp+8], rsi
	mov	QWORD PTR $T6[rsp+16], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 146  :       eigen_assert( (dataPtr == 0)

	test	r9, r9
	je	SHORT $LN670@updateFand
	test	rsi, rsi
	jns	SHORT $LN670@updateFand
	mov	r8d, 148				; 00000094H
	lea	rdx, OFFSET FLAT:??_C@_1LA@MIDGNIKC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1BGE@MDFDAGNB@?$AA?$CI?$AAd?$AAa?$AAt?$AAa?$AAP?$AAt?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$CJ?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AA?$CI?$AA?5?$AAn?$AAb?$AAR?$AAo?$AAw?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5@
	call	QWORD PTR __imp__wassert
$LN670@updateFand:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h

; 351  :     {

	mov	QWORD PTR $T6[rsp+24], rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densebase.h

; 210  :            : int(IsRowMajor) ? this->cols() : this->rows();

	mov	rax, QWORD PTR [rdi+8]
	mov	QWORD PTR $T6[rbp-177], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h

; 140  :       eigen_assert(a_startRow >= 0 && blockRows >= 0 && a_startRow  <= xpr.rows() - blockRows

	test	rsi, rsi
	js	SHORT $LN645@updateFand
	sub	rax, rsi
	cmp	rsi, rax
	jle	SHORT $LN646@updateFand
$LN645@updateFand:
	mov	r8d, 141				; 0000008dH
	lea	rdx, OFFSET FLAT:??_C@_1KM@LCMGCMD@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1BCO@NFJGBHKC@?$AAa?$AA_?$AAs?$AAt?$AAa?$AAr?$AAt?$AAR?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAb?$AAl?$AAo?$AAc?$AAk?$AAR?$AAo?$AAw?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5@
	call	QWORD PTR __imp__wassert
$LN646@updateFand:
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 146  : 	v += dff.block(size_j, 0, size_j, 1);

	lea	r15, QWORD PTR [r14+416]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h

; 55   :     inline SelfCwiseBinaryOp(Lhs& xpr, const BinaryOp& func = BinaryOp()) : m_matrix(xpr), m_functor(func) {}

	mov	QWORD PTR tmp$9[rbp-209], r15
	lea	rax, QWORD PTR $T1[rsp]
	mov	QWORD PTR tmp$9[rbp-201], rax

; 138  :     #ifndef EIGEN_NO_DEBUG
; 139  :       this->checkTransposeAliasing(rhs.derived());
; 140  :     #endif
; 141  :       return *this;
; 142  :     }
; 143  :     
; 144  :     // overloaded to honor evaluation of special matrices
; 145  :     // maybe another solution would be to not use SelfCwiseBinaryOp
; 146  :     // at first...
; 147  :     SelfCwiseBinaryOp& operator=(const Rhs& _rhs)
; 148  :     {
; 149  :       typename internal::nested<Rhs>::type rhs(_rhs);

	movups	xmm0, XMMWORD PTR $T6[rsp]
	movups	XMMWORD PTR rhs$16[rbp-209], xmm0
	movups	xmm1, XMMWORD PTR $T6[rsp+16]
	movups	XMMWORD PTR rhs$16[rbp-193], xmm1
	movsdx	xmm0, QWORD PTR $T6[rbp-177]
	movsdx	QWORD PTR rhs$16[rbp-177], xmm0

; 56   : 
; 57   :     inline Index rows() const { return m_matrix.rows(); }
; 58   :     inline Index cols() const { return m_matrix.cols(); }
; 59   :     inline Index outerStride() const { return m_matrix.outerStride(); }
; 60   :     inline Index innerStride() const { return m_matrix.innerStride(); }
; 61   :     inline const Scalar* data() const { return m_matrix.data(); }
; 62   : 
; 63   :     // note that this function is needed by assign to correctly align loads/stores
; 64   :     // TODO make Assign use .data()
; 65   :     inline Scalar& coeffRef(Index row, Index col)
; 66   :     {
; 67   :       EIGEN_STATIC_ASSERT_LVALUE(Lhs)
; 68   :       return m_matrix.const_cast_derived().coeffRef(row, col);
; 69   :     }
; 70   :     inline const Scalar& coeffRef(Index row, Index col) const
; 71   :     {
; 72   :       return m_matrix.coeffRef(row, col);
; 73   :     }
; 74   : 
; 75   :     // note that this function is needed by assign to correctly align loads/stores
; 76   :     // TODO make Assign use .data()
; 77   :     inline Scalar& coeffRef(Index index)
; 78   :     {
; 79   :       EIGEN_STATIC_ASSERT_LVALUE(Lhs)
; 80   :       return m_matrix.const_cast_derived().coeffRef(index);
; 81   :     }
; 82   :     inline const Scalar& coeffRef(Index index) const
; 83   :     {
; 84   :       return m_matrix.const_cast_derived().coeffRef(index);
; 85   :     }
; 86   : 
; 87   :     template<typename OtherDerived>
; 88   :     void copyCoeff(Index row, Index col, const DenseBase<OtherDerived>& other)
; 89   :     {
; 90   :       OtherDerived& _other = other.const_cast_derived();
; 91   :       eigen_internal_assert(row >= 0 && row < rows()
; 92   :                          && col >= 0 && col < cols());
; 93   :       Scalar& tmp = m_matrix.coeffRef(row,col);
; 94   :       tmp = m_functor(tmp, _other.coeff(row,col));
; 95   :     }
; 96   : 
; 97   :     template<typename OtherDerived>
; 98   :     void copyCoeff(Index index, const DenseBase<OtherDerived>& other)
; 99   :     {
; 100  :       OtherDerived& _other = other.const_cast_derived();
; 101  :       eigen_internal_assert(index >= 0 && index < m_matrix.size());
; 102  :       Scalar& tmp = m_matrix.coeffRef(index);
; 103  :       tmp = m_functor(tmp, _other.coeff(index));
; 104  :     }
; 105  : 
; 106  :     template<typename OtherDerived, int StoreMode, int LoadMode>
; 107  :     void copyPacket(Index row, Index col, const DenseBase<OtherDerived>& other)
; 108  :     {
; 109  :       OtherDerived& _other = other.const_cast_derived();
; 110  :       eigen_internal_assert(row >= 0 && row < rows()
; 111  :                         && col >= 0 && col < cols());
; 112  :       m_matrix.template writePacket<StoreMode>(row, col,
; 113  :         m_functor.packetOp(m_matrix.template packet<StoreMode>(row, col),_other.template packet<LoadMode>(row, col)) );
; 114  :     }
; 115  : 
; 116  :     template<typename OtherDerived, int StoreMode, int LoadMode>
; 117  :     void copyPacket(Index index, const DenseBase<OtherDerived>& other)
; 118  :     {
; 119  :       OtherDerived& _other = other.const_cast_derived();
; 120  :       eigen_internal_assert(index >= 0 && index < m_matrix.size());
; 121  :       m_matrix.template writePacket<StoreMode>(index,
; 122  :         m_functor.packetOp(m_matrix.template packet<StoreMode>(index),_other.template packet<LoadMode>(index)) );
; 123  :     }
; 124  : 
; 125  :     // reimplement lazyAssign to handle complex *= real
; 126  :     // see CwiseBinaryOp ctor for details
; 127  :     template<typename RhsDerived>
; 128  :     EIGEN_STRONG_INLINE SelfCwiseBinaryOp& lazyAssign(const DenseBase<RhsDerived>& rhs)
; 129  :     {
; 130  :       EIGEN_STATIC_ASSERT_SAME_MATRIX_SIZE(Lhs,RhsDerived)
; 131  :       EIGEN_CHECK_BINARY_COMPATIBILIY(BinaryOp,typename Lhs::Scalar,typename RhsDerived::Scalar);
; 132  :       
; 133  :     #ifdef EIGEN_DEBUG_ASSIGN
; 134  :       internal::assign_traits<SelfCwiseBinaryOp, RhsDerived>::debug();
; 135  :     #endif
; 136  :       eigen_assert(rows() == rhs.rows() && cols() == rhs.cols());

	cmp	QWORD PTR [r15+8], rsi
	je	SHORT $LN760@updateFand
	mov	r8d, 136				; 00000088H
	lea	rdx, OFFSET FLAT:??_C@_1ME@CGCHACLK@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1FK@JAKLMIFJ@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAr?$AAh?$AAs?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN@
	call	QWORD PTR __imp__wassert
$LN760@updateFand:

; 137  :       internal::assign_impl<SelfCwiseBinaryOp, RhsDerived>::run(*this,rhs.derived());

	lea	rdx, QWORD PTR rhs$16[rbp-209]
	lea	rcx, QWORD PTR tmp$9[rbp-209]
	call	?run@?$assign_impl@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@3@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Z ; Eigen::internal::assign_impl<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,4,0,0>::run
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 148  : 	IGORdata::write_itx(f, "output/debug/f.itx", "FF");

	lea	rax, QWORD PTR $T20[rbp-209]
	mov	QWORD PTR $T13[rbp-209], rax
	mov	QWORD PTR $T20[rbp-185], 15
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T20[rbp-193], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T20[rbp-209], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 2
	lea	rdx, OFFSET FLAT:??_C@_02NCIKDPBM@FF?$AA@
	lea	rcx, QWORD PTR $T20[rbp-209]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
	mov	QWORD PTR $T5[rsp+24], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T5[rsp+16], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T5[rsp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 18
	lea	rdx, OFFSET FLAT:??_C@_0BD@GOPMHKAF@output?1debug?1f?4itx?$AA@
	lea	rcx, QWORD PTR $T5[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 148  : 	IGORdata::write_itx(f, "output/debug/f.itx", "FF");

	lea	r8, QWORD PTR $T20[rbp-209]
	lea	rdx, QWORD PTR $T5[rsp]
	mov	rcx, r12
	call	??$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z ; IGORdata::write_itx<double,-1,1,0,-1,1>

; 149  : 	IGORdata::write_itx(v, "output/debug/v.itx", "vv");

	lea	rax, QWORD PTR $T19[rbp-209]
	mov	QWORD PTR $T12[rbp-209], rax
	mov	QWORD PTR $T19[rbp-185], 15
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T19[rbp-193], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T19[rbp-209], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 2
	lea	rdx, OFFSET FLAT:??_C@_02CJKHOMHP@vv?$AA@
	lea	rcx, QWORD PTR $T19[rbp-209]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
	mov	QWORD PTR $T4[rsp+24], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T4[rsp+16], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T4[rsp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 18
	lea	rdx, OFFSET FLAT:??_C@_0BD@GNCKHIJO@output?1debug?1v?4itx?$AA@
	lea	rcx, QWORD PTR $T4[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 149  : 	IGORdata::write_itx(v, "output/debug/v.itx", "vv");

	lea	r8, QWORD PTR $T19[rbp-209]
	lea	rdx, QWORD PTR $T4[rsp]
	mov	rcx, r15
	call	??$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z ; IGORdata::write_itx<double,-1,1,0,-1,1>

; 150  : 	IGORdata::write_itx(dff, "output/debug/dff.itx", "dff");

	lea	rax, QWORD PTR $T18[rbp-209]
	mov	QWORD PTR $T11[rbp-209], rax
	mov	QWORD PTR $T18[rbp-185], 15
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T18[rbp-193], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T18[rbp-209], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 3
	lea	rdx, OFFSET FLAT:??_C@_03BFACDLAE@dff?$AA@
	lea	rcx, QWORD PTR $T18[rbp-209]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
	mov	QWORD PTR $T3[rsp+24], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T3[rsp+16], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T3[rsp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 20
	lea	rdx, OFFSET FLAT:??_C@_0BF@CHCIFIMP@output?1debug?1dff?4itx?$AA@
	lea	rcx, QWORD PTR $T3[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 150  : 	IGORdata::write_itx(dff, "output/debug/dff.itx", "dff");

	lea	r8, QWORD PTR $T18[rbp-209]
	lea	rdx, QWORD PTR $T3[rsp]
	mov	rcx, rdi
	call	??$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z ; IGORdata::write_itx<double,-1,1,0,-1,1>

; 151  : /*
; 152  : 	IGORdata::write_itx(J, "output/debug/J.itx", "JJ");
; 153  : 	IGORdata::write_itx(H, "output/debug/H.itx", "HH");
; 154  : 	IGORdata::write_itx(Jv, "output/debug/Jv.itx", "Jv");
; 155  : 	IGORdata::write_itx(Hvv, "output/debug/Hvv.itx", "Hvv");
; 156  : 	IGORdata::write_itx(Hvf, "output/debug/Hvf.itx", "Hvf");
; 157  : 	IGORdata::write_itx(Aij, "output/debug/Aij.itx", "Aij");
; 158  : 	Eigen::VectorXd Af = A*f.array().exp().matrix();
; 159  : 	IGORdata::write_itx(Af, "output/debug/Af.itx", "Af");
; 160  : 	*/
; 161  : 
; 162  : 	//	if |df|j / |f|j < relativeError is satisfied for all the elements, finish itaration
; 163  : 	for (size_t j = 0; j < size_j; ++j){

	mov	rsi, rbx
	movsdx	xmm6, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cmp	QWORD PTR [r14+8], rbx
	jbe	SHORT $LN6@updateFand
	npad	6
$LL8@updateFand:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 378  :       eigen_assert(index >= 0 && index < size());

	test	rsi, rsi
	js	SHORT $LN1061@updateFand
	cmp	rsi, QWORD PTR [rdi+8]
	jl	SHORT $LN1062@updateFand
$LN1061@updateFand:
	mov	r8d, 378				; 0000017aH
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	call	QWORD PTR __imp__wassert
$LN1062@updateFand:
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 164  : 		if (fabs(dff[j]) > relativeError0) { return false; }

	mov	rax, QWORD PTR [rdi]
	movsdx	xmm0, QWORD PTR [rax+rsi*8]
	andps	xmm0, xmm6
	comisd	xmm0, xmm7
	ja	SHORT $LN1118@updateFand

; 151  : /*
; 152  : 	IGORdata::write_itx(J, "output/debug/J.itx", "JJ");
; 153  : 	IGORdata::write_itx(H, "output/debug/H.itx", "HH");
; 154  : 	IGORdata::write_itx(Jv, "output/debug/Jv.itx", "Jv");
; 155  : 	IGORdata::write_itx(Hvv, "output/debug/Hvv.itx", "Hvv");
; 156  : 	IGORdata::write_itx(Hvf, "output/debug/Hvf.itx", "Hvf");
; 157  : 	IGORdata::write_itx(Aij, "output/debug/Aij.itx", "Aij");
; 158  : 	Eigen::VectorXd Af = A*f.array().exp().matrix();
; 159  : 	IGORdata::write_itx(Af, "output/debug/Af.itx", "Af");
; 160  : 	*/
; 161  : 
; 162  : 	//	if |df|j / |f|j < relativeError is satisfied for all the elements, finish itaration
; 163  : 	for (size_t j = 0; j < size_j; ++j){

	inc	rsi
	cmp	rsi, QWORD PTR [r14+8]
	jb	SHORT $LL8@updateFand

; 167  : 		if (fabs(dff[j + size_j]) > vError1){ return false; }

	jmp	SHORT $LN6@updateFand
$LN1118@updateFand:

; 164  : 		if (fabs(dff[j]) > relativeError0) { return false; }

	xor	al, al
	jmp	SHORT $LN9@updateFand
$LN6@updateFand:

; 165  : 	}
; 166  : 	for (size_t j = 0; j < size_j; ++j){

	mov	rax, QWORD PTR [r14+8]
	test	rax, rax
	je	SHORT $LN2@updateFand

; 167  : 		if (fabs(dff[j + size_j]) > vError1){ return false; }

	movsdx	xmm7, QWORD PTR vError1$[rbp-209]
$LL4@updateFand:
	lea	rsi, QWORD PTR [rax+rbx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 378  :       eigen_assert(index >= 0 && index < size());

	test	rsi, rsi
	js	SHORT $LN1089@updateFand
	cmp	rsi, QWORD PTR [rdi+8]
	jl	SHORT $LN1090@updateFand
$LN1089@updateFand:
	mov	r8d, 378				; 0000017aH
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	call	QWORD PTR __imp__wassert
$LN1090@updateFand:
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 167  : 		if (fabs(dff[j + size_j]) > vError1){ return false; }

	mov	rax, QWORD PTR [rdi]
	movsdx	xmm0, QWORD PTR [rax+rsi*8]
	andps	xmm0, xmm6
	comisd	xmm0, xmm7
	ja	SHORT $LN1118@updateFand

; 165  : 	}
; 166  : 	for (size_t j = 0; j < size_j; ++j){

	inc	rbx
	mov	rax, QWORD PTR [r14+8]
	cmp	rbx, rax
	jb	SHORT $LL4@updateFand
$LN2@updateFand:

; 168  : 	}
; 169  : 	//	otherwise
; 170  : 	return true;

	mov	al, 1
$LN9@updateFand:

; 171  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-209]
	xor	rcx, rsp
	call	__security_check_cookie
	movaps	xmm6, XMMWORD PTR [rsp+224]
	movaps	xmm7, XMMWORD PTR [rsp+208]
	add	rsp, 240				; 000000f0H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
$LN1129@updateFand:
?updateFandV@Tikhonov2D@@AEAA_NNNNN@Z ENDP		; Tikhonov2D::updateFandV
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 48
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
tmp$9 = 96
tmp$10 = 96
$T11 = 96
$T12 = 96
$T13 = 96
$T14 = 96
$T15 = 120
rhs$16 = 128
rhs$17 = 128
$T18 = 128
$T19 = 128
$T20 = 128
$T21 = 128
__$ArrayPad$ = 200
this$ = 304
lambda0$ = 312
lambda1$ = 320
relativeError0$ = 328
vError1$ = 336
?dtor$0@?0??updateFandV@Tikhonov2D@@AEAA_NNNNN@Z@4HA PROC ; `Tikhonov2D::updateFandV'::`1'::dtor$0
	lea	rcx, QWORD PTR $T21[rdx]
	jmp	??1?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAA@XZ
?dtor$0@?0??updateFandV@Tikhonov2D@@AEAA_NNNNN@Z@4HA ENDP ; `Tikhonov2D::updateFandV'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 48
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
tmp$9 = 96
tmp$10 = 96
$T11 = 96
$T12 = 96
$T13 = 96
$T14 = 96
$T15 = 120
rhs$16 = 128
rhs$17 = 128
$T18 = 128
$T19 = 128
$T20 = 128
$T21 = 128
__$ArrayPad$ = 200
this$ = 304
lambda0$ = 312
lambda1$ = 320
relativeError0$ = 328
vError1$ = 336
?dtor$1@?0??updateFandV@Tikhonov2D@@AEAA_NNNNN@Z@4HA PROC ; `Tikhonov2D::updateFandV'::`1'::dtor$1
	lea	rcx, QWORD PTR $T8[rdx]
	jmp	??1?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@QEAA@XZ
?dtor$1@?0??updateFandV@Tikhonov2D@@AEAA_NNNNN@Z@4HA ENDP ; `Tikhonov2D::updateFandV'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 48
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
tmp$9 = 96
tmp$10 = 96
$T11 = 96
$T12 = 96
$T13 = 96
$T14 = 96
$T15 = 120
rhs$16 = 128
rhs$17 = 128
$T18 = 128
$T19 = 128
$T20 = 128
$T21 = 128
__$ArrayPad$ = 200
this$ = 304
lambda0$ = 312
lambda1$ = 320
relativeError0$ = 328
vError1$ = 336
?dtor$2@?0??updateFandV@Tikhonov2D@@AEAA_NNNNN@Z@4HA PROC ; `Tikhonov2D::updateFandV'::`1'::dtor$2
	mov	rcx, QWORD PTR $T13[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??updateFandV@Tikhonov2D@@AEAA_NNNNN@Z@4HA ENDP ; `Tikhonov2D::updateFandV'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 48
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
tmp$9 = 96
tmp$10 = 96
$T11 = 96
$T12 = 96
$T13 = 96
$T14 = 96
$T15 = 120
rhs$16 = 128
rhs$17 = 128
$T18 = 128
$T19 = 128
$T20 = 128
$T21 = 128
__$ArrayPad$ = 200
this$ = 304
lambda0$ = 312
lambda1$ = 320
relativeError0$ = 328
vError1$ = 336
?dtor$4@?0??updateFandV@Tikhonov2D@@AEAA_NNNNN@Z@4HA PROC ; `Tikhonov2D::updateFandV'::`1'::dtor$4
	mov	rcx, QWORD PTR $T12[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0??updateFandV@Tikhonov2D@@AEAA_NNNNN@Z@4HA ENDP ; `Tikhonov2D::updateFandV'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 48
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
tmp$9 = 96
tmp$10 = 96
$T11 = 96
$T12 = 96
$T13 = 96
$T14 = 96
$T15 = 120
rhs$16 = 128
rhs$17 = 128
$T18 = 128
$T19 = 128
$T20 = 128
$T21 = 128
__$ArrayPad$ = 200
this$ = 304
lambda0$ = 312
lambda1$ = 320
relativeError0$ = 328
vError1$ = 336
?dtor$6@?0??updateFandV@Tikhonov2D@@AEAA_NNNNN@Z@4HA PROC ; `Tikhonov2D::updateFandV'::`1'::dtor$6
	mov	rcx, QWORD PTR $T11[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$6@?0??updateFandV@Tikhonov2D@@AEAA_NNNNN@Z@4HA ENDP ; `Tikhonov2D::updateFandV'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwisenullaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwisenullaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwisenullaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwisenullaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwisenullaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwisenullaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwisenullaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwiseunaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwiseunaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwiseunaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwiseunaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwiseunaryop.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwisenullaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\plugins\blockmethods.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\plugins\blockmethods.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
;	COMDAT ?setJandH@Tikhonov2D@@AEAA_NNN@Z
_TEXT	SEGMENT
this$GSCopy$1$ = 48
$T1 = 56
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
$T9 = 56
$T10 = 56
$T11 = 56
$T12 = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
othersize$1$ = 96
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
$T22 = 112
$T23 = 112
$T24 = 112
other$1$ = 144
$T25 = 144
$T26 = 152
other$1$ = 160
$T27 = 168
$T28 = 168
$T29 = 168
$T30 = 168
$T31 = 224
$T32 = 232
$T33 = 256
$T34 = 256
z$ = 256
__$ArrayPad$ = 272
this$ = 432
lambdaSquared0$ = 440
lambdaSquared1$ = 448
?setJandH@Tikhonov2D@@AEAA_NNN@Z PROC			; Tikhonov2D::setJandH, COMDAT

; 188  : bool Tikhonov2D::setJandH(const double lambdaSquared0, const double lambdaSquared1){

$LN5953:
	mov	rax, rsp
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-128]
	sub	rsp, 384				; 00000180H
	mov	QWORD PTR $T31[rbp-256], -2
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	movaps	XMMWORD PTR [rax-56], xmm6
	movaps	XMMWORD PTR [rax-72], xmm7
	movaps	XMMWORD PTR [rax-88], xmm8
	movaps	XMMWORD PTR [rax-104], xmm9
	movaps	XMMWORD PTR [rax-120], xmm10
	movaps	XMMWORD PTR [rax-136], xmm11
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	movaps	xmm8, xmm2
	movaps	xmm6, xmm1
	mov	r13, rcx
	mov	QWORD PTR this$GSCopy$1$[rsp], rcx

; 189  : 	Jf.setZero();

	lea	rsi, QWORD PTR [rcx+272]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 313  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rbx, QWORD PTR [rsi+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h

; 63   :     explicit variable_if_dynamic(T value) : m_value(value) {}

	mov	QWORD PTR $T8[rsp+8], rbx
	xorps	xmm7, xmm7
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h

; 517  :   EIGEN_STRONG_INLINE scalar_constant_op(const scalar_constant_op& other) : m_other(other.m_other) { }

	movsdx	QWORD PTR $T8[rsp+24], xmm7
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwisenullaryop.h

; 60   :       eigen_assert(nbRows >= 0

	test	rbx, rbx
	jns	SHORT $LN53@setJandH
	mov	r8d, 63					; 0000003fH
	lea	rdx, OFFSET FLAT:??_C@_1LO@HNEDKPLG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1BDK@EFDGPJJE@?$AAn?$AAb?$AAR?$AAo?$AAw?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm@
	call	QWORD PTR __imp__wassert
$LN53@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	mov	r12, 9223372036854775807		; 7fffffffffffffffH
	test	rbx, rbx
	je	SHORT $LN191@setJandH
	cmp	rbx, r12
	setg	dil

; 45   :     if (error)

	test	dil, dil
	je	SHORT $LN117@setJandH

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN117@setJandH:

; 157  :     }
; 158  : 
; 159  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
; 160  :     {
; 161  :       return m_storage.data()[index];
; 162  :     }
; 163  : 
; 164  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
; 165  :     {
; 166  :       if(Flags & RowMajorBit)
; 167  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 168  :       else // column-major
; 169  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 170  :     }
; 171  : 
; 172  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
; 173  :     {
; 174  :       return m_storage.data()[index];
; 175  :     }
; 176  : 
; 177  :     /** \internal */
; 178  :     template<int LoadMode>
; 179  :     EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const
; 180  :     {
; 181  :       return internal::ploadt<PacketScalar, LoadMode>
; 182  :                (m_storage.data() + (Flags & RowMajorBit
; 183  :                                    ? colId + rowId * m_storage.cols()
; 184  :                                    : rowId + colId * m_storage.rows()));
; 185  :     }
; 186  : 
; 187  :     /** \internal */
; 188  :     template<int LoadMode>
; 189  :     EIGEN_STRONG_INLINE PacketScalar packet(Index index) const
; 190  :     {
; 191  :       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);
; 192  :     }
; 193  : 
; 194  :     /** \internal */
; 195  :     template<int StoreMode>
; 196  :     EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)
; 197  :     {
; 198  :       internal::pstoret<Scalar, PacketScalar, StoreMode>
; 199  :               (m_storage.data() + (Flags & RowMajorBit
; 200  :                                    ? colId + rowId * m_storage.cols()
; 201  :                                    : rowId + colId * m_storage.rows()), val);
; 202  :     }
; 203  : 
; 204  :     /** \internal */
; 205  :     template<int StoreMode>
; 206  :     EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
; 207  :     {
; 208  :       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
; 209  :     }
; 210  : 
; 211  :     /** \returns a const pointer to the data array of this matrix */
; 212  :     EIGEN_STRONG_INLINE const Scalar *data() const
; 213  :     { return m_storage.data(); }
; 214  : 
; 215  :     /** \returns a pointer to the data array of this matrix */
; 216  :     EIGEN_STRONG_INLINE Scalar *data()
; 217  :     { return m_storage.data(); }
; 218  : 
; 219  :     /** Resizes \c *this to a \a rows x \a cols matrix.
; 220  :       *
; 221  :       * This method is intended for dynamic-size matrices, although it is legal to call it on any
; 222  :       * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
; 223  :       * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
; 224  :       *
; 225  :       * If the current number of coefficients of \c *this exactly matches the
; 226  :       * product \a rows * \a cols, then no memory allocation is performed and
; 227  :       * the current values are left unchanged. In all other cases, including
; 228  :       * shrinking, the data is reallocated and all previous values are lost.
; 229  :       *
; 230  :       * Example: \include Matrix_resize_int_int.cpp
; 231  :       * Output: \verbinclude Matrix_resize_int_int.out
; 232  :       *
; 233  :       * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
; 234  :       */
; 235  :     EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)
; 236  :     {
; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rbx, rbx
	jns	SHORT $LN184@setJandH
	mov	r8d, 241				; 000000f1H
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	call	QWORD PTR __imp__wassert
$LN184@setJandH:

; 45   :     if (error)

	test	dil, dil
	je	SHORT $LN191@setJandH

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN191@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 322  :       if(size != m_rows*_Cols)

	xor	r15d, r15d
	cmp	rbx, QWORD PTR [rsi+8]
	je	SHORT $LN196@setJandH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR [rsi]
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 325  :         if (size)

	test	rbx, rbx
	je	SHORT $LN197@setJandH

; 326  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

	mov	rcx, rbx
	call	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
	mov	QWORD PTR [rsi], rax

; 327  :         else

	jmp	SHORT $LN196@setJandH
$LN197@setJandH:

; 328  :           m_data = 0;

	mov	QWORD PTR [rsi], r15
$LN196@setJandH:

; 329  :         EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN
; 330  :       }
; 331  :       m_rows = nbRows;

	mov	QWORD PTR [rsi+8], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 404  :     const Index alignedEnd = alignedStart + ((size-alignedStart)/packetSize)*packetSize;

	mov	rax, rbx
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r8, rax
	add	r8, r8

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	mov	rcx, r15
	test	r8, r8
	jle	SHORT $LN306@setJandH
	xorps	xmm0, xmm0
	npad	14
$LL308@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 334  :     inline T *data() { return m_data; }

	mov	rax, QWORD PTR [rsi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [rax+rcx*8], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	add	rcx, 2
	cmp	rcx, r8
	jl	SHORT $LL308@setJandH
$LN306@setJandH:

; 409  :     {
; 410  :       dst.template copyPacket<Derived2, dstAlignment, srcAlignment>(index, src);
; 411  :     }
; 412  : 
; 413  :     unaligned_assign_impl<>::run(src,dst,alignedEnd,size);

	mov	r9, rbx
	mov	rdx, rsi
	lea	rcx, QWORD PTR $T8[rsp]
	call	??$run@V?$CwiseNullaryOp@U?$scalar_constant_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@?$unaligned_assign_impl@$0A@@internal@Eigen@@SAXAEBV?$CwiseNullaryOp@U?$scalar_constant_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@@2@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@_J2@Z ; Eigen::internal::unaligned_assign_impl<0>::run<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>,Eigen::Matrix<double,-1,1,0,-1,1> >,Eigen::Matrix<double,-1,1,0,-1,1> >
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 190  : 	Jv.setZero();

	lea	rsi, QWORD PTR [r13+288]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 313  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rbx, QWORD PTR [rsi+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h

; 63   :     explicit variable_if_dynamic(T value) : m_value(value) {}

	mov	QWORD PTR $T7[rsp+8], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h

; 517  :   EIGEN_STRONG_INLINE scalar_constant_op(const scalar_constant_op& other) : m_other(other.m_other) { }

	movsdx	QWORD PTR $T7[rsp+24], xmm7
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwisenullaryop.h

; 60   :       eigen_assert(nbRows >= 0

	test	rbx, rbx
	jns	SHORT $LN5926@setJandH
	mov	r8d, 63					; 0000003fH
	lea	rdx, OFFSET FLAT:??_C@_1LO@HNEDKPLG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1BDK@EFDGPJJE@?$AAn?$AAb?$AAR?$AAo?$AAw?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm@
	call	QWORD PTR __imp__wassert
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	test	rbx, rbx
$LN5926@setJandH:
	je	SHORT $LN558@setJandH
	cmp	rbx, r12
	setg	dil

; 45   :     if (error)

	test	dil, dil
	je	SHORT $LN484@setJandH

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN484@setJandH:

; 157  :     }
; 158  : 
; 159  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
; 160  :     {
; 161  :       return m_storage.data()[index];
; 162  :     }
; 163  : 
; 164  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
; 165  :     {
; 166  :       if(Flags & RowMajorBit)
; 167  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 168  :       else // column-major
; 169  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 170  :     }
; 171  : 
; 172  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
; 173  :     {
; 174  :       return m_storage.data()[index];
; 175  :     }
; 176  : 
; 177  :     /** \internal */
; 178  :     template<int LoadMode>
; 179  :     EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const
; 180  :     {
; 181  :       return internal::ploadt<PacketScalar, LoadMode>
; 182  :                (m_storage.data() + (Flags & RowMajorBit
; 183  :                                    ? colId + rowId * m_storage.cols()
; 184  :                                    : rowId + colId * m_storage.rows()));
; 185  :     }
; 186  : 
; 187  :     /** \internal */
; 188  :     template<int LoadMode>
; 189  :     EIGEN_STRONG_INLINE PacketScalar packet(Index index) const
; 190  :     {
; 191  :       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);
; 192  :     }
; 193  : 
; 194  :     /** \internal */
; 195  :     template<int StoreMode>
; 196  :     EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)
; 197  :     {
; 198  :       internal::pstoret<Scalar, PacketScalar, StoreMode>
; 199  :               (m_storage.data() + (Flags & RowMajorBit
; 200  :                                    ? colId + rowId * m_storage.cols()
; 201  :                                    : rowId + colId * m_storage.rows()), val);
; 202  :     }
; 203  : 
; 204  :     /** \internal */
; 205  :     template<int StoreMode>
; 206  :     EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
; 207  :     {
; 208  :       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
; 209  :     }
; 210  : 
; 211  :     /** \returns a const pointer to the data array of this matrix */
; 212  :     EIGEN_STRONG_INLINE const Scalar *data() const
; 213  :     { return m_storage.data(); }
; 214  : 
; 215  :     /** \returns a pointer to the data array of this matrix */
; 216  :     EIGEN_STRONG_INLINE Scalar *data()
; 217  :     { return m_storage.data(); }
; 218  : 
; 219  :     /** Resizes \c *this to a \a rows x \a cols matrix.
; 220  :       *
; 221  :       * This method is intended for dynamic-size matrices, although it is legal to call it on any
; 222  :       * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
; 223  :       * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
; 224  :       *
; 225  :       * If the current number of coefficients of \c *this exactly matches the
; 226  :       * product \a rows * \a cols, then no memory allocation is performed and
; 227  :       * the current values are left unchanged. In all other cases, including
; 228  :       * shrinking, the data is reallocated and all previous values are lost.
; 229  :       *
; 230  :       * Example: \include Matrix_resize_int_int.cpp
; 231  :       * Output: \verbinclude Matrix_resize_int_int.out
; 232  :       *
; 233  :       * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
; 234  :       */
; 235  :     EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)
; 236  :     {
; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rbx, rbx
	jns	SHORT $LN551@setJandH
	mov	r8d, 241				; 000000f1H
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	call	QWORD PTR __imp__wassert
$LN551@setJandH:

; 45   :     if (error)

	test	dil, dil
	je	SHORT $LN558@setJandH

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN558@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 322  :       if(size != m_rows*_Cols)

	cmp	rbx, QWORD PTR [rsi+8]
	je	SHORT $LN563@setJandH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR [rsi]
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 325  :         if (size)

	test	rbx, rbx
	je	SHORT $LN564@setJandH

; 326  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

	mov	rcx, rbx
	call	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
	mov	QWORD PTR [rsi], rax

; 327  :         else

	jmp	SHORT $LN563@setJandH
$LN564@setJandH:

; 328  :           m_data = 0;

	mov	QWORD PTR [rsi], r15
$LN563@setJandH:

; 329  :         EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN
; 330  :       }
; 331  :       m_rows = nbRows;

	mov	QWORD PTR [rsi+8], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 404  :     const Index alignedEnd = alignedStart + ((size-alignedStart)/packetSize)*packetSize;

	mov	rax, rbx
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r8, rax
	add	r8, r8

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	mov	rcx, r15
	test	r8, r8
	jle	SHORT $LN673@setJandH
	xorps	xmm0, xmm0
	npad	6
$LL675@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 334  :     inline T *data() { return m_data; }

	mov	rax, QWORD PTR [rsi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [rax+rcx*8], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	add	rcx, 2
	cmp	rcx, r8
	jl	SHORT $LL675@setJandH
$LN673@setJandH:

; 409  :     {
; 410  :       dst.template copyPacket<Derived2, dstAlignment, srcAlignment>(index, src);
; 411  :     }
; 412  : 
; 413  :     unaligned_assign_impl<>::run(src,dst,alignedEnd,size);

	mov	r9, rbx
	mov	rdx, rsi
	lea	rcx, QWORD PTR $T7[rsp]
	call	??$run@V?$CwiseNullaryOp@U?$scalar_constant_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@?$unaligned_assign_impl@$0A@@internal@Eigen@@SAXAEBV?$CwiseNullaryOp@U?$scalar_constant_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@@2@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@_J2@Z ; Eigen::internal::unaligned_assign_impl<0>::run<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>,Eigen::Matrix<double,-1,1,0,-1,1> >,Eigen::Matrix<double,-1,1,0,-1,1> >
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 191  : 	Hff.setZero();

	lea	rsi, QWORD PTR [r13+328]
	mov	QWORD PTR other$1$[rbp-256], rsi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 240  :     inline DenseIndex cols(void) const {return m_cols;}

	mov	rbx, QWORD PTR [rsi+16]

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rdi, QWORD PTR [rsi+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h

; 63   :     explicit variable_if_dynamic(T value) : m_value(value) {}

	mov	QWORD PTR $T6[rsp+8], rdi
	mov	QWORD PTR $T6[rsp+16], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h

; 517  :   EIGEN_STRONG_INLINE scalar_constant_op(const scalar_constant_op& other) : m_other(other.m_other) { }

	movsdx	QWORD PTR $T6[rsp+24], xmm7
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwisenullaryop.h

; 60   :       eigen_assert(nbRows >= 0

	test	rdi, rdi
	js	SHORT $LN785@setJandH
	test	rbx, rbx
	jns	SHORT $LN786@setJandH
$LN785@setJandH:
	mov	r8d, 63					; 0000003fH
	lea	rdx, OFFSET FLAT:??_C@_1LO@HNEDKPLG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1BDK@EFDGPJJE@?$AAn?$AAb?$AAR?$AAo?$AAw?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm@
	call	QWORD PTR __imp__wassert
$LN786@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	test	rdi, rdi
	je	SHORT $LN5928@setJandH
	test	rbx, rbx
	je	SHORT $LN849@setJandH
	mov	rax, r12
	cdq
	idiv	rbx
	cmp	rdi, rax
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN849@setJandH

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN849@setJandH:

; 157  :     }
; 158  : 
; 159  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
; 160  :     {
; 161  :       return m_storage.data()[index];
; 162  :     }
; 163  : 
; 164  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
; 165  :     {
; 166  :       if(Flags & RowMajorBit)
; 167  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 168  :       else // column-major
; 169  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 170  :     }
; 171  : 
; 172  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
; 173  :     {
; 174  :       return m_storage.data()[index];
; 175  :     }
; 176  : 
; 177  :     /** \internal */
; 178  :     template<int LoadMode>
; 179  :     EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const
; 180  :     {
; 181  :       return internal::ploadt<PacketScalar, LoadMode>
; 182  :                (m_storage.data() + (Flags & RowMajorBit
; 183  :                                    ? colId + rowId * m_storage.cols()
; 184  :                                    : rowId + colId * m_storage.rows()));
; 185  :     }
; 186  : 
; 187  :     /** \internal */
; 188  :     template<int LoadMode>
; 189  :     EIGEN_STRONG_INLINE PacketScalar packet(Index index) const
; 190  :     {
; 191  :       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);
; 192  :     }
; 193  : 
; 194  :     /** \internal */
; 195  :     template<int StoreMode>
; 196  :     EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)
; 197  :     {
; 198  :       internal::pstoret<Scalar, PacketScalar, StoreMode>
; 199  :               (m_storage.data() + (Flags & RowMajorBit
; 200  :                                    ? colId + rowId * m_storage.cols()
; 201  :                                    : rowId + colId * m_storage.rows()), val);
; 202  :     }
; 203  : 
; 204  :     /** \internal */
; 205  :     template<int StoreMode>
; 206  :     EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
; 207  :     {
; 208  :       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
; 209  :     }
; 210  : 
; 211  :     /** \returns a const pointer to the data array of this matrix */
; 212  :     EIGEN_STRONG_INLINE const Scalar *data() const
; 213  :     { return m_storage.data(); }
; 214  : 
; 215  :     /** \returns a pointer to the data array of this matrix */
; 216  :     EIGEN_STRONG_INLINE Scalar *data()
; 217  :     { return m_storage.data(); }
; 218  : 
; 219  :     /** Resizes \c *this to a \a rows x \a cols matrix.
; 220  :       *
; 221  :       * This method is intended for dynamic-size matrices, although it is legal to call it on any
; 222  :       * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
; 223  :       * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
; 224  :       *
; 225  :       * If the current number of coefficients of \c *this exactly matches the
; 226  :       * product \a rows * \a cols, then no memory allocation is performed and
; 227  :       * the current values are left unchanged. In all other cases, including
; 228  :       * shrinking, the data is reallocated and all previous values are lost.
; 229  :       *
; 230  :       * Example: \include Matrix_resize_int_int.cpp
; 231  :       * Output: \verbinclude Matrix_resize_int_int.out
; 232  :       *
; 233  :       * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
; 234  :       */
; 235  :     EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)
; 236  :     {
; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rdi, rdi
$LN5928@setJandH:
	js	SHORT $LN919@setJandH
	test	rbx, rbx
	jns	SHORT $LN920@setJandH
$LN919@setJandH:
	mov	r8d, 241				; 000000f1H
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	call	QWORD PTR __imp__wassert
$LN920@setJandH:

; 44   :                : (rows > max_index / cols);

	test	rdi, rdi
	je	SHORT $LN927@setJandH
	test	rbx, rbx
	je	SHORT $LN927@setJandH
	mov	rax, r12
	cdq
	idiv	rbx
	cmp	rdi, rax
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN921@setJandH

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN921@setJandH:

; 44   :                : (rows > max_index / cols);

	test	rbx, rbx
	je	SHORT $LN927@setJandH
	mov	rax, r12
	cdq
	idiv	rbx
	cmp	rdi, rax
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN927@setJandH

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN927@setJandH:

; 238  :                    && EIGEN_IMPLIES(ColsAtCompileTime!=Dynamic,nbCols==ColsAtCompileTime)
; 239  :                    && EIGEN_IMPLIES(RowsAtCompileTime==Dynamic && MaxRowsAtCompileTime!=Dynamic,nbRows<=MaxRowsAtCompileTime)
; 240  :                    && EIGEN_IMPLIES(ColsAtCompileTime==Dynamic && MaxColsAtCompileTime!=Dynamic,nbCols<=MaxColsAtCompileTime)
; 241  :                    && nbRows>=0 && nbCols>=0 && "Invalid sizes when resizing a matrix or array.");
; 242  :       internal::check_rows_cols_for_overflow<MaxSizeAtCompileTime>::run(nbRows, nbCols);
; 243  :       #ifdef EIGEN_INITIALIZE_COEFFS
; 244  :         Index size = nbRows*nbCols;
; 245  :         bool size_changed = size != this->size();
; 246  :         m_storage.resize(size, nbRows, nbCols);
; 247  :         if(size_changed) EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED
; 248  :       #else
; 249  :         internal::check_rows_cols_for_overflow<MaxSizeAtCompileTime>::run(nbRows, nbCols);
; 250  :         m_storage.resize(nbRows*nbCols, nbRows, nbCols);

	mov	rdx, rdi
	imul	rdx, rbx
	mov	r9, rbx
	mov	r8, rdi
	mov	rcx, rsi
	call	?resize@?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAAX_J00@Z ; Eigen::DenseStorage<double,-1,-1,-1,0>::resize
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	cmp	QWORD PTR [rsi+8], rdi
	jne	SHORT $LN940@setJandH
	cmp	QWORD PTR [rsi+16], rbx
	je	SHORT $LN5868@setJandH
$LN940@setJandH:
	mov	r8d, 498				; 000001f2H
	lea	rdx, OFFSET FLAT:??_C@_1KO@HDGCFKMN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GC@PBCDNLIH@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ@
	call	QWORD PTR __imp__wassert
$LN5868@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 240  :     inline DenseIndex cols(void) const {return m_cols;}

	mov	r9, QWORD PTR [rsi+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 49   :   inline Index size() const { return rows() * cols(); }

	imul	r9, QWORD PTR [rsi+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 404  :     const Index alignedEnd = alignedStart + ((size-alignedStart)/packetSize)*packetSize;

	mov	rax, r9
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r8, rax
	add	r8, r8

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	mov	rcx, r15
	test	r8, r8
	jle	SHORT $LN984@setJandH
	xorps	xmm0, xmm0
	npad	4
$LL986@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 262  :     inline T *data() { return m_data; }

	mov	rax, QWORD PTR [rsi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [rax+rcx*8], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	add	rcx, 2
	cmp	rcx, r8
	jl	SHORT $LL986@setJandH
$LN984@setJandH:

; 409  :     {
; 410  :       dst.template copyPacket<Derived2, dstAlignment, srcAlignment>(index, src);
; 411  :     }
; 412  : 
; 413  :     unaligned_assign_impl<>::run(src,dst,alignedEnd,size);

	mov	rdx, rsi
	lea	rcx, QWORD PTR $T6[rsp]
	call	??$run@V?$CwiseNullaryOp@U?$scalar_constant_op@N@internal@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@@?$unaligned_assign_impl@$0A@@internal@Eigen@@SAXAEBV?$CwiseNullaryOp@U?$scalar_constant_op@N@internal@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@2@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@_J2@Z ; Eigen::internal::unaligned_assign_impl<0>::run<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>,Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::Matrix<double,-1,-1,0,-1,-1> >
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 192  : 	Hvf.setZero();

	lea	rbx, QWORD PTR [r13+376]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 240  :     inline DenseIndex cols(void) const {return m_cols;}

	mov	rdi, QWORD PTR [rbx+16]

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rsi, QWORD PTR [rbx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h

; 63   :     explicit variable_if_dynamic(T value) : m_value(value) {}

	mov	QWORD PTR $T5[rsp+8], rsi
	mov	QWORD PTR $T5[rsp+16], rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h

; 517  :   EIGEN_STRONG_INLINE scalar_constant_op(const scalar_constant_op& other) : m_other(other.m_other) { }

	movsdx	QWORD PTR $T5[rsp+24], xmm7
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwisenullaryop.h

; 60   :       eigen_assert(nbRows >= 0

	test	rsi, rsi
	js	SHORT $LN1096@setJandH
	test	rdi, rdi
	jns	SHORT $LN1097@setJandH
$LN1096@setJandH:
	mov	r8d, 63					; 0000003fH
	lea	rdx, OFFSET FLAT:??_C@_1LO@HNEDKPLG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1BDK@EFDGPJJE@?$AAn?$AAb?$AAR?$AAo?$AAw?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm@
	call	QWORD PTR __imp__wassert
$LN1097@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	test	rsi, rsi
	je	SHORT $LN5930@setJandH
	test	rdi, rdi
	je	SHORT $LN1160@setJandH
	mov	rax, r12
	cdq
	idiv	rdi
	cmp	rsi, rax
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN1160@setJandH

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN1160@setJandH:

; 157  :     }
; 158  : 
; 159  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
; 160  :     {
; 161  :       return m_storage.data()[index];
; 162  :     }
; 163  : 
; 164  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
; 165  :     {
; 166  :       if(Flags & RowMajorBit)
; 167  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 168  :       else // column-major
; 169  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 170  :     }
; 171  : 
; 172  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
; 173  :     {
; 174  :       return m_storage.data()[index];
; 175  :     }
; 176  : 
; 177  :     /** \internal */
; 178  :     template<int LoadMode>
; 179  :     EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const
; 180  :     {
; 181  :       return internal::ploadt<PacketScalar, LoadMode>
; 182  :                (m_storage.data() + (Flags & RowMajorBit
; 183  :                                    ? colId + rowId * m_storage.cols()
; 184  :                                    : rowId + colId * m_storage.rows()));
; 185  :     }
; 186  : 
; 187  :     /** \internal */
; 188  :     template<int LoadMode>
; 189  :     EIGEN_STRONG_INLINE PacketScalar packet(Index index) const
; 190  :     {
; 191  :       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);
; 192  :     }
; 193  : 
; 194  :     /** \internal */
; 195  :     template<int StoreMode>
; 196  :     EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)
; 197  :     {
; 198  :       internal::pstoret<Scalar, PacketScalar, StoreMode>
; 199  :               (m_storage.data() + (Flags & RowMajorBit
; 200  :                                    ? colId + rowId * m_storage.cols()
; 201  :                                    : rowId + colId * m_storage.rows()), val);
; 202  :     }
; 203  : 
; 204  :     /** \internal */
; 205  :     template<int StoreMode>
; 206  :     EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
; 207  :     {
; 208  :       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
; 209  :     }
; 210  : 
; 211  :     /** \returns a const pointer to the data array of this matrix */
; 212  :     EIGEN_STRONG_INLINE const Scalar *data() const
; 213  :     { return m_storage.data(); }
; 214  : 
; 215  :     /** \returns a pointer to the data array of this matrix */
; 216  :     EIGEN_STRONG_INLINE Scalar *data()
; 217  :     { return m_storage.data(); }
; 218  : 
; 219  :     /** Resizes \c *this to a \a rows x \a cols matrix.
; 220  :       *
; 221  :       * This method is intended for dynamic-size matrices, although it is legal to call it on any
; 222  :       * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
; 223  :       * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
; 224  :       *
; 225  :       * If the current number of coefficients of \c *this exactly matches the
; 226  :       * product \a rows * \a cols, then no memory allocation is performed and
; 227  :       * the current values are left unchanged. In all other cases, including
; 228  :       * shrinking, the data is reallocated and all previous values are lost.
; 229  :       *
; 230  :       * Example: \include Matrix_resize_int_int.cpp
; 231  :       * Output: \verbinclude Matrix_resize_int_int.out
; 232  :       *
; 233  :       * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
; 234  :       */
; 235  :     EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)
; 236  :     {
; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rsi, rsi
$LN5930@setJandH:
	js	SHORT $LN1230@setJandH
	test	rdi, rdi
	jns	SHORT $LN1231@setJandH
$LN1230@setJandH:
	mov	r8d, 241				; 000000f1H
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	call	QWORD PTR __imp__wassert
$LN1231@setJandH:

; 44   :                : (rows > max_index / cols);

	test	rsi, rsi
	je	SHORT $LN1238@setJandH
	test	rdi, rdi
	je	SHORT $LN1238@setJandH
	mov	rax, r12
	cdq
	idiv	rdi
	cmp	rsi, rax
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN1232@setJandH

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN1232@setJandH:

; 44   :                : (rows > max_index / cols);

	test	rdi, rdi
	je	SHORT $LN1238@setJandH
	mov	rax, r12
	cdq
	idiv	rdi
	cmp	rsi, rax
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN1238@setJandH

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN1238@setJandH:

; 238  :                    && EIGEN_IMPLIES(ColsAtCompileTime!=Dynamic,nbCols==ColsAtCompileTime)
; 239  :                    && EIGEN_IMPLIES(RowsAtCompileTime==Dynamic && MaxRowsAtCompileTime!=Dynamic,nbRows<=MaxRowsAtCompileTime)
; 240  :                    && EIGEN_IMPLIES(ColsAtCompileTime==Dynamic && MaxColsAtCompileTime!=Dynamic,nbCols<=MaxColsAtCompileTime)
; 241  :                    && nbRows>=0 && nbCols>=0 && "Invalid sizes when resizing a matrix or array.");
; 242  :       internal::check_rows_cols_for_overflow<MaxSizeAtCompileTime>::run(nbRows, nbCols);
; 243  :       #ifdef EIGEN_INITIALIZE_COEFFS
; 244  :         Index size = nbRows*nbCols;
; 245  :         bool size_changed = size != this->size();
; 246  :         m_storage.resize(size, nbRows, nbCols);
; 247  :         if(size_changed) EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED
; 248  :       #else
; 249  :         internal::check_rows_cols_for_overflow<MaxSizeAtCompileTime>::run(nbRows, nbCols);
; 250  :         m_storage.resize(nbRows*nbCols, nbRows, nbCols);

	mov	rdx, rsi
	imul	rdx, rdi
	mov	r9, rdi
	mov	r8, rsi
	mov	rcx, rbx
	call	?resize@?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAAX_J00@Z ; Eigen::DenseStorage<double,-1,-1,-1,0>::resize
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	cmp	QWORD PTR [rbx+8], rsi
	jne	SHORT $LN1251@setJandH
	cmp	QWORD PTR [rbx+16], rdi
	je	SHORT $LN5876@setJandH
$LN1251@setJandH:
	mov	r8d, 498				; 000001f2H
	lea	rdx, OFFSET FLAT:??_C@_1KO@HDGCFKMN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GC@PBCDNLIH@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ@
	call	QWORD PTR __imp__wassert
$LN5876@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 240  :     inline DenseIndex cols(void) const {return m_cols;}

	mov	r9, QWORD PTR [rbx+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 49   :   inline Index size() const { return rows() * cols(); }

	imul	r9, QWORD PTR [rbx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 404  :     const Index alignedEnd = alignedStart + ((size-alignedStart)/packetSize)*packetSize;

	mov	rax, r9
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r8, rax
	add	r8, r8

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	mov	rcx, r15
	test	r8, r8
	jle	SHORT $LN1295@setJandH
	xorps	xmm0, xmm0
	npad	11
$LL1297@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 262  :     inline T *data() { return m_data; }

	mov	rax, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [rax+rcx*8], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	add	rcx, 2
	cmp	rcx, r8
	jl	SHORT $LL1297@setJandH
$LN1295@setJandH:

; 409  :     {
; 410  :       dst.template copyPacket<Derived2, dstAlignment, srcAlignment>(index, src);
; 411  :     }
; 412  : 
; 413  :     unaligned_assign_impl<>::run(src,dst,alignedEnd,size);

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T5[rsp]
	call	??$run@V?$CwiseNullaryOp@U?$scalar_constant_op@N@internal@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@@?$unaligned_assign_impl@$0A@@internal@Eigen@@SAXAEBV?$CwiseNullaryOp@U?$scalar_constant_op@N@internal@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@2@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@_J2@Z ; Eigen::internal::unaligned_assign_impl<0>::run<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>,Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::Matrix<double,-1,-1,0,-1,-1> >
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 193  : 	Hvv.setZero();

	lea	r14, QWORD PTR [r13+352]
	mov	QWORD PTR other$1$[rbp-256], r14
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 240  :     inline DenseIndex cols(void) const {return m_cols;}

	mov	rdi, QWORD PTR [r14+16]

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rsi, QWORD PTR [r14+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h

; 63   :     explicit variable_if_dynamic(T value) : m_value(value) {}

	mov	QWORD PTR $T4[rsp+8], rsi
	mov	QWORD PTR $T4[rsp+16], rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h

; 517  :   EIGEN_STRONG_INLINE scalar_constant_op(const scalar_constant_op& other) : m_other(other.m_other) { }

	movsdx	QWORD PTR $T4[rsp+24], xmm7
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwisenullaryop.h

; 60   :       eigen_assert(nbRows >= 0

	test	rsi, rsi
	js	SHORT $LN1399@setJandH
	test	rdi, rdi
	jns	SHORT $LN1400@setJandH
$LN1399@setJandH:
	mov	r8d, 63					; 0000003fH
	lea	rdx, OFFSET FLAT:??_C@_1LO@HNEDKPLG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1BDK@EFDGPJJE@?$AAn?$AAb?$AAR?$AAo?$AAw?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm@
	call	QWORD PTR __imp__wassert
$LN1400@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	test	rsi, rsi
	je	SHORT $LN5932@setJandH
	test	rdi, rdi
	je	SHORT $LN1463@setJandH
	mov	rax, r12
	cdq
	idiv	rdi
	cmp	rsi, rax
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN1463@setJandH

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN1463@setJandH:

; 157  :     }
; 158  : 
; 159  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
; 160  :     {
; 161  :       return m_storage.data()[index];
; 162  :     }
; 163  : 
; 164  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
; 165  :     {
; 166  :       if(Flags & RowMajorBit)
; 167  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 168  :       else // column-major
; 169  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 170  :     }
; 171  : 
; 172  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
; 173  :     {
; 174  :       return m_storage.data()[index];
; 175  :     }
; 176  : 
; 177  :     /** \internal */
; 178  :     template<int LoadMode>
; 179  :     EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const
; 180  :     {
; 181  :       return internal::ploadt<PacketScalar, LoadMode>
; 182  :                (m_storage.data() + (Flags & RowMajorBit
; 183  :                                    ? colId + rowId * m_storage.cols()
; 184  :                                    : rowId + colId * m_storage.rows()));
; 185  :     }
; 186  : 
; 187  :     /** \internal */
; 188  :     template<int LoadMode>
; 189  :     EIGEN_STRONG_INLINE PacketScalar packet(Index index) const
; 190  :     {
; 191  :       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);
; 192  :     }
; 193  : 
; 194  :     /** \internal */
; 195  :     template<int StoreMode>
; 196  :     EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)
; 197  :     {
; 198  :       internal::pstoret<Scalar, PacketScalar, StoreMode>
; 199  :               (m_storage.data() + (Flags & RowMajorBit
; 200  :                                    ? colId + rowId * m_storage.cols()
; 201  :                                    : rowId + colId * m_storage.rows()), val);
; 202  :     }
; 203  : 
; 204  :     /** \internal */
; 205  :     template<int StoreMode>
; 206  :     EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
; 207  :     {
; 208  :       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
; 209  :     }
; 210  : 
; 211  :     /** \returns a const pointer to the data array of this matrix */
; 212  :     EIGEN_STRONG_INLINE const Scalar *data() const
; 213  :     { return m_storage.data(); }
; 214  : 
; 215  :     /** \returns a pointer to the data array of this matrix */
; 216  :     EIGEN_STRONG_INLINE Scalar *data()
; 217  :     { return m_storage.data(); }
; 218  : 
; 219  :     /** Resizes \c *this to a \a rows x \a cols matrix.
; 220  :       *
; 221  :       * This method is intended for dynamic-size matrices, although it is legal to call it on any
; 222  :       * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
; 223  :       * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
; 224  :       *
; 225  :       * If the current number of coefficients of \c *this exactly matches the
; 226  :       * product \a rows * \a cols, then no memory allocation is performed and
; 227  :       * the current values are left unchanged. In all other cases, including
; 228  :       * shrinking, the data is reallocated and all previous values are lost.
; 229  :       *
; 230  :       * Example: \include Matrix_resize_int_int.cpp
; 231  :       * Output: \verbinclude Matrix_resize_int_int.out
; 232  :       *
; 233  :       * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
; 234  :       */
; 235  :     EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)
; 236  :     {
; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rsi, rsi
$LN5932@setJandH:
	js	SHORT $LN1533@setJandH
	test	rdi, rdi
	jns	SHORT $LN1534@setJandH
$LN1533@setJandH:
	mov	r8d, 241				; 000000f1H
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	call	QWORD PTR __imp__wassert
$LN1534@setJandH:

; 44   :                : (rows > max_index / cols);

	test	rsi, rsi
	je	SHORT $LN1541@setJandH
	test	rdi, rdi
	je	SHORT $LN1541@setJandH
	mov	rax, r12
	cdq
	idiv	rdi
	cmp	rsi, rax
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN1535@setJandH

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN1535@setJandH:

; 44   :                : (rows > max_index / cols);

	test	rdi, rdi
	je	SHORT $LN1541@setJandH
	mov	rax, r12
	cdq
	idiv	rdi
	cmp	rsi, rax
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN1541@setJandH

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN1541@setJandH:

; 238  :                    && EIGEN_IMPLIES(ColsAtCompileTime!=Dynamic,nbCols==ColsAtCompileTime)
; 239  :                    && EIGEN_IMPLIES(RowsAtCompileTime==Dynamic && MaxRowsAtCompileTime!=Dynamic,nbRows<=MaxRowsAtCompileTime)
; 240  :                    && EIGEN_IMPLIES(ColsAtCompileTime==Dynamic && MaxColsAtCompileTime!=Dynamic,nbCols<=MaxColsAtCompileTime)
; 241  :                    && nbRows>=0 && nbCols>=0 && "Invalid sizes when resizing a matrix or array.");
; 242  :       internal::check_rows_cols_for_overflow<MaxSizeAtCompileTime>::run(nbRows, nbCols);
; 243  :       #ifdef EIGEN_INITIALIZE_COEFFS
; 244  :         Index size = nbRows*nbCols;
; 245  :         bool size_changed = size != this->size();
; 246  :         m_storage.resize(size, nbRows, nbCols);
; 247  :         if(size_changed) EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED
; 248  :       #else
; 249  :         internal::check_rows_cols_for_overflow<MaxSizeAtCompileTime>::run(nbRows, nbCols);
; 250  :         m_storage.resize(nbRows*nbCols, nbRows, nbCols);

	mov	rdx, rdi
	imul	rdx, rsi
	mov	r9, rdi
	mov	r8, rsi
	mov	rcx, r14
	call	?resize@?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAAX_J00@Z ; Eigen::DenseStorage<double,-1,-1,-1,0>::resize
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	cmp	QWORD PTR [r14+8], rsi
	jne	SHORT $LN1554@setJandH
	cmp	QWORD PTR [r14+16], rdi
	je	SHORT $LN5884@setJandH
$LN1554@setJandH:
	mov	r8d, 498				; 000001f2H
	lea	rdx, OFFSET FLAT:??_C@_1KO@HDGCFKMN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GC@PBCDNLIH@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ@
	call	QWORD PTR __imp__wassert
$LN5884@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 240  :     inline DenseIndex cols(void) const {return m_cols;}

	mov	r9, QWORD PTR [r14+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 49   :   inline Index size() const { return rows() * cols(); }

	imul	r9, QWORD PTR [r14+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 404  :     const Index alignedEnd = alignedStart + ((size-alignedStart)/packetSize)*packetSize;

	mov	rax, r9
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r8, rax
	add	r8, r8

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	mov	rcx, r15
	test	r8, r8
	jle	SHORT $LN1598@setJandH
	xorps	xmm0, xmm0
	npad	7
$LL1600@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 262  :     inline T *data() { return m_data; }

	mov	rax, QWORD PTR [r14]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [rax+rcx*8], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	add	rcx, 2
	cmp	rcx, r8
	jl	SHORT $LL1600@setJandH
$LN1598@setJandH:

; 409  :     {
; 410  :       dst.template copyPacket<Derived2, dstAlignment, srcAlignment>(index, src);
; 411  :     }
; 412  : 
; 413  :     unaligned_assign_impl<>::run(src,dst,alignedEnd,size);

	mov	rdx, r14
	lea	rcx, QWORD PTR $T4[rsp]
	call	??$run@V?$CwiseNullaryOp@U?$scalar_constant_op@N@internal@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@@?$unaligned_assign_impl@$0A@@internal@Eigen@@SAXAEBV?$CwiseNullaryOp@U?$scalar_constant_op@N@internal@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@2@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@_J2@Z ; Eigen::internal::unaligned_assign_impl<0>::run<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>,Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::Matrix<double,-1,-1,0,-1,-1> >
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 194  : 	J.setZero();

	lea	r14, QWORD PTR [r13+256]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 313  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rdi, QWORD PTR [r14+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h

; 63   :     explicit variable_if_dynamic(T value) : m_value(value) {}

	mov	QWORD PTR $T3[rsp+8], rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h

; 517  :   EIGEN_STRONG_INLINE scalar_constant_op(const scalar_constant_op& other) : m_other(other.m_other) { }

	movsdx	QWORD PTR $T3[rsp+24], xmm7
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwisenullaryop.h

; 60   :       eigen_assert(nbRows >= 0

	test	rdi, rdi
	jns	SHORT $LN5934@setJandH
	mov	r8d, 63					; 0000003fH
	lea	rdx, OFFSET FLAT:??_C@_1LO@HNEDKPLG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1BDK@EFDGPJJE@?$AAn?$AAb?$AAR?$AAo?$AAw?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm@
	call	QWORD PTR __imp__wassert
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	test	rdi, rdi
$LN5934@setJandH:
	je	SHORT $LN1841@setJandH
	cmp	rdi, r12
	setg	sil

; 45   :     if (error)

	test	sil, sil
	je	SHORT $LN1767@setJandH

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN1767@setJandH:

; 157  :     }
; 158  : 
; 159  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
; 160  :     {
; 161  :       return m_storage.data()[index];
; 162  :     }
; 163  : 
; 164  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
; 165  :     {
; 166  :       if(Flags & RowMajorBit)
; 167  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 168  :       else // column-major
; 169  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 170  :     }
; 171  : 
; 172  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
; 173  :     {
; 174  :       return m_storage.data()[index];
; 175  :     }
; 176  : 
; 177  :     /** \internal */
; 178  :     template<int LoadMode>
; 179  :     EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const
; 180  :     {
; 181  :       return internal::ploadt<PacketScalar, LoadMode>
; 182  :                (m_storage.data() + (Flags & RowMajorBit
; 183  :                                    ? colId + rowId * m_storage.cols()
; 184  :                                    : rowId + colId * m_storage.rows()));
; 185  :     }
; 186  : 
; 187  :     /** \internal */
; 188  :     template<int LoadMode>
; 189  :     EIGEN_STRONG_INLINE PacketScalar packet(Index index) const
; 190  :     {
; 191  :       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);
; 192  :     }
; 193  : 
; 194  :     /** \internal */
; 195  :     template<int StoreMode>
; 196  :     EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)
; 197  :     {
; 198  :       internal::pstoret<Scalar, PacketScalar, StoreMode>
; 199  :               (m_storage.data() + (Flags & RowMajorBit
; 200  :                                    ? colId + rowId * m_storage.cols()
; 201  :                                    : rowId + colId * m_storage.rows()), val);
; 202  :     }
; 203  : 
; 204  :     /** \internal */
; 205  :     template<int StoreMode>
; 206  :     EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
; 207  :     {
; 208  :       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
; 209  :     }
; 210  : 
; 211  :     /** \returns a const pointer to the data array of this matrix */
; 212  :     EIGEN_STRONG_INLINE const Scalar *data() const
; 213  :     { return m_storage.data(); }
; 214  : 
; 215  :     /** \returns a pointer to the data array of this matrix */
; 216  :     EIGEN_STRONG_INLINE Scalar *data()
; 217  :     { return m_storage.data(); }
; 218  : 
; 219  :     /** Resizes \c *this to a \a rows x \a cols matrix.
; 220  :       *
; 221  :       * This method is intended for dynamic-size matrices, although it is legal to call it on any
; 222  :       * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
; 223  :       * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
; 224  :       *
; 225  :       * If the current number of coefficients of \c *this exactly matches the
; 226  :       * product \a rows * \a cols, then no memory allocation is performed and
; 227  :       * the current values are left unchanged. In all other cases, including
; 228  :       * shrinking, the data is reallocated and all previous values are lost.
; 229  :       *
; 230  :       * Example: \include Matrix_resize_int_int.cpp
; 231  :       * Output: \verbinclude Matrix_resize_int_int.out
; 232  :       *
; 233  :       * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
; 234  :       */
; 235  :     EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)
; 236  :     {
; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rdi, rdi
	jns	SHORT $LN1834@setJandH
	mov	r8d, 241				; 000000f1H
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	call	QWORD PTR __imp__wassert
$LN1834@setJandH:

; 45   :     if (error)

	test	sil, sil
	je	SHORT $LN1841@setJandH

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN1841@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 322  :       if(size != m_rows*_Cols)

	cmp	rdi, QWORD PTR [r14+8]
	je	SHORT $LN1846@setJandH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR [r14]
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 325  :         if (size)

	test	rdi, rdi
	je	SHORT $LN1847@setJandH

; 326  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

	mov	rcx, rdi
	call	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
	mov	QWORD PTR [r14], rax

; 327  :         else

	jmp	SHORT $LN1846@setJandH
$LN1847@setJandH:

; 328  :           m_data = 0;

	mov	QWORD PTR [r14], r15
$LN1846@setJandH:

; 329  :         EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN
; 330  :       }
; 331  :       m_rows = nbRows;

	mov	QWORD PTR [r14+8], rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 404  :     const Index alignedEnd = alignedStart + ((size-alignedStart)/packetSize)*packetSize;

	mov	rax, rdi
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r8, rax
	add	r8, r8

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	mov	rcx, r15
	test	r8, r8
	jle	SHORT $LN1956@setJandH
	xorps	xmm0, xmm0
	npad	9
$LL1958@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 334  :     inline T *data() { return m_data; }

	mov	rax, QWORD PTR [r14]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [rax+rcx*8], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	add	rcx, 2
	cmp	rcx, r8
	jl	SHORT $LL1958@setJandH
$LN1956@setJandH:

; 409  :     {
; 410  :       dst.template copyPacket<Derived2, dstAlignment, srcAlignment>(index, src);
; 411  :     }
; 412  : 
; 413  :     unaligned_assign_impl<>::run(src,dst,alignedEnd,size);

	mov	r9, rdi
	mov	rdx, r14
	lea	rcx, QWORD PTR $T3[rsp]
	call	??$run@V?$CwiseNullaryOp@U?$scalar_constant_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@?$unaligned_assign_impl@$0A@@internal@Eigen@@SAXAEBV?$CwiseNullaryOp@U?$scalar_constant_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@@2@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@_J2@Z ; Eigen::internal::unaligned_assign_impl<0>::run<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>,Eigen::Matrix<double,-1,1,0,-1,1> >,Eigen::Matrix<double,-1,1,0,-1,1> >
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 195  : 	H.setZero();

	lea	r14, QWORD PTR [r13+304]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 240  :     inline DenseIndex cols(void) const {return m_cols;}

	mov	rdi, QWORD PTR [r14+16]

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rsi, QWORD PTR [r14+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h

; 63   :     explicit variable_if_dynamic(T value) : m_value(value) {}

	mov	QWORD PTR $T2[rsp+8], rsi
	mov	QWORD PTR $T2[rsp+16], rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h

; 517  :   EIGEN_STRONG_INLINE scalar_constant_op(const scalar_constant_op& other) : m_other(other.m_other) { }

	movsdx	QWORD PTR $T2[rsp+24], xmm7
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwisenullaryop.h

; 60   :       eigen_assert(nbRows >= 0

	test	rsi, rsi
	js	SHORT $LN2060@setJandH
	test	rdi, rdi
	jns	SHORT $LN2061@setJandH
$LN2060@setJandH:
	mov	r8d, 63					; 0000003fH
	lea	rdx, OFFSET FLAT:??_C@_1LO@HNEDKPLG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1BDK@EFDGPJJE@?$AAn?$AAb?$AAR?$AAo?$AAw?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm@
	call	QWORD PTR __imp__wassert
$LN2061@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	test	rsi, rsi
	je	SHORT $LN5936@setJandH
	test	rdi, rdi
	je	SHORT $LN2124@setJandH
	mov	rax, r12
	cdq
	idiv	rdi
	cmp	rsi, rax
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN2124@setJandH

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN2124@setJandH:

; 157  :     }
; 158  : 
; 159  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
; 160  :     {
; 161  :       return m_storage.data()[index];
; 162  :     }
; 163  : 
; 164  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
; 165  :     {
; 166  :       if(Flags & RowMajorBit)
; 167  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 168  :       else // column-major
; 169  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 170  :     }
; 171  : 
; 172  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
; 173  :     {
; 174  :       return m_storage.data()[index];
; 175  :     }
; 176  : 
; 177  :     /** \internal */
; 178  :     template<int LoadMode>
; 179  :     EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const
; 180  :     {
; 181  :       return internal::ploadt<PacketScalar, LoadMode>
; 182  :                (m_storage.data() + (Flags & RowMajorBit
; 183  :                                    ? colId + rowId * m_storage.cols()
; 184  :                                    : rowId + colId * m_storage.rows()));
; 185  :     }
; 186  : 
; 187  :     /** \internal */
; 188  :     template<int LoadMode>
; 189  :     EIGEN_STRONG_INLINE PacketScalar packet(Index index) const
; 190  :     {
; 191  :       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);
; 192  :     }
; 193  : 
; 194  :     /** \internal */
; 195  :     template<int StoreMode>
; 196  :     EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)
; 197  :     {
; 198  :       internal::pstoret<Scalar, PacketScalar, StoreMode>
; 199  :               (m_storage.data() + (Flags & RowMajorBit
; 200  :                                    ? colId + rowId * m_storage.cols()
; 201  :                                    : rowId + colId * m_storage.rows()), val);
; 202  :     }
; 203  : 
; 204  :     /** \internal */
; 205  :     template<int StoreMode>
; 206  :     EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
; 207  :     {
; 208  :       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
; 209  :     }
; 210  : 
; 211  :     /** \returns a const pointer to the data array of this matrix */
; 212  :     EIGEN_STRONG_INLINE const Scalar *data() const
; 213  :     { return m_storage.data(); }
; 214  : 
; 215  :     /** \returns a pointer to the data array of this matrix */
; 216  :     EIGEN_STRONG_INLINE Scalar *data()
; 217  :     { return m_storage.data(); }
; 218  : 
; 219  :     /** Resizes \c *this to a \a rows x \a cols matrix.
; 220  :       *
; 221  :       * This method is intended for dynamic-size matrices, although it is legal to call it on any
; 222  :       * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
; 223  :       * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
; 224  :       *
; 225  :       * If the current number of coefficients of \c *this exactly matches the
; 226  :       * product \a rows * \a cols, then no memory allocation is performed and
; 227  :       * the current values are left unchanged. In all other cases, including
; 228  :       * shrinking, the data is reallocated and all previous values are lost.
; 229  :       *
; 230  :       * Example: \include Matrix_resize_int_int.cpp
; 231  :       * Output: \verbinclude Matrix_resize_int_int.out
; 232  :       *
; 233  :       * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
; 234  :       */
; 235  :     EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)
; 236  :     {
; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rsi, rsi
$LN5936@setJandH:
	js	SHORT $LN2194@setJandH
	test	rdi, rdi
	jns	SHORT $LN2195@setJandH
$LN2194@setJandH:
	mov	r8d, 241				; 000000f1H
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	call	QWORD PTR __imp__wassert
$LN2195@setJandH:

; 44   :                : (rows > max_index / cols);

	test	rsi, rsi
	je	SHORT $LN2202@setJandH
	test	rdi, rdi
	je	SHORT $LN2202@setJandH
	mov	rax, r12
	cdq
	idiv	rdi
	cmp	rsi, rax
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN2196@setJandH

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN2196@setJandH:

; 44   :                : (rows > max_index / cols);

	test	rdi, rdi
	je	SHORT $LN2202@setJandH
	mov	rax, r12
	cdq
	idiv	rdi
	cmp	rsi, rax
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN2202@setJandH

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN2202@setJandH:

; 238  :                    && EIGEN_IMPLIES(ColsAtCompileTime!=Dynamic,nbCols==ColsAtCompileTime)
; 239  :                    && EIGEN_IMPLIES(RowsAtCompileTime==Dynamic && MaxRowsAtCompileTime!=Dynamic,nbRows<=MaxRowsAtCompileTime)
; 240  :                    && EIGEN_IMPLIES(ColsAtCompileTime==Dynamic && MaxColsAtCompileTime!=Dynamic,nbCols<=MaxColsAtCompileTime)
; 241  :                    && nbRows>=0 && nbCols>=0 && "Invalid sizes when resizing a matrix or array.");
; 242  :       internal::check_rows_cols_for_overflow<MaxSizeAtCompileTime>::run(nbRows, nbCols);
; 243  :       #ifdef EIGEN_INITIALIZE_COEFFS
; 244  :         Index size = nbRows*nbCols;
; 245  :         bool size_changed = size != this->size();
; 246  :         m_storage.resize(size, nbRows, nbCols);
; 247  :         if(size_changed) EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED
; 248  :       #else
; 249  :         internal::check_rows_cols_for_overflow<MaxSizeAtCompileTime>::run(nbRows, nbCols);
; 250  :         m_storage.resize(nbRows*nbCols, nbRows, nbCols);

	mov	rdx, rsi
	imul	rdx, rdi
	mov	r9, rdi
	mov	r8, rsi
	mov	rcx, r14
	call	?resize@?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAAX_J00@Z ; Eigen::DenseStorage<double,-1,-1,-1,0>::resize
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	cmp	QWORD PTR [r14+8], rsi
	jne	SHORT $LN2215@setJandH
	cmp	QWORD PTR [r14+16], rdi
	je	SHORT $LN5900@setJandH
$LN2215@setJandH:
	mov	r8d, 498				; 000001f2H
	lea	rdx, OFFSET FLAT:??_C@_1KO@HDGCFKMN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GC@PBCDNLIH@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ@
	call	QWORD PTR __imp__wassert
$LN5900@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 240  :     inline DenseIndex cols(void) const {return m_cols;}

	mov	r9, QWORD PTR [r14+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 49   :   inline Index size() const { return rows() * cols(); }

	imul	r9, QWORD PTR [r14+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 404  :     const Index alignedEnd = alignedStart + ((size-alignedStart)/packetSize)*packetSize;

	mov	rax, r9
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r8, rax
	add	r8, r8

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	mov	rcx, r15
	test	r8, r8
	jle	SHORT $LN2259@setJandH
	xorps	xmm0, xmm0
	npad	8
$LL2261@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 262  :     inline T *data() { return m_data; }

	mov	rax, QWORD PTR [r14]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [rax+rcx*8], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	add	rcx, 2
	cmp	rcx, r8
	jl	SHORT $LL2261@setJandH
$LN2259@setJandH:

; 409  :     {
; 410  :       dst.template copyPacket<Derived2, dstAlignment, srcAlignment>(index, src);
; 411  :     }
; 412  : 
; 413  :     unaligned_assign_impl<>::run(src,dst,alignedEnd,size);

	mov	rdx, r14
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$run@V?$CwiseNullaryOp@U?$scalar_constant_op@N@internal@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@@?$unaligned_assign_impl@$0A@@internal@Eigen@@SAXAEBV?$CwiseNullaryOp@U?$scalar_constant_op@N@internal@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@2@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@_J2@Z ; Eigen::internal::unaligned_assign_impl<0>::run<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>,Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::Matrix<double,-1,-1,0,-1,-1> >
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 197  : 	Jf = 2.0 * lambdaSquared0 * Lf.transpose() * Lf * f;

	movsdx	xmm11, QWORD PTR __real@4000000000000000
	mulsd	xmm6, xmm11
	lea	r14, QWORD PTR [r13+152]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwiseunaryop.h

; 68   :       : m_xpr(xpr), m_functor(func) {}

	mov	QWORD PTR $T24[rsp+8], r14
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h

; 466  :   EIGEN_STRONG_INLINE scalar_multiple_op(const scalar_multiple_op& other) : m_other(other.m_other) { }

	movsdx	QWORD PTR $T24[rbp-240], xmm6
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 197  : 	Jf = 2.0 * lambdaSquared0 * Lf.transpose() * Lf * f;

	mov	r8, r14
	lea	rdx, QWORD PTR $T30[rbp-256]
	lea	rcx, QWORD PTR $T24[rsp+1]
	call	??$?DV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@?$MatrixBase@V?$CwiseUnaryOp@U?$scalar_multiple_op@N@internal@Eigen@@$$CBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Eigen@@@Eigen@@QEBA?BV?$GeneralProduct@V?$CwiseUnaryOp@U?$scalar_multiple_op@N@internal@Eigen@@$$CBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$04@1@AEBV?$MatrixBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@1@@Z ; Eigen::MatrixBase<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>,Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> > const > >::operator*<Eigen::Matrix<double,-1,-1,0,-1,-1> >
	npad	1
	lea	r12, QWORD PTR [r13+400]
	mov	r8, r12
	lea	rdx, QWORD PTR $T16[rsp]
	mov	rcx, rax
	call	??$?DV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$MatrixBase@V?$GeneralProduct@V?$CwiseUnaryOp@U?$scalar_multiple_op@N@internal@Eigen@@$$CBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$04@Eigen@@@Eigen@@QEBA?BV?$GeneralProduct@V?$GeneralProduct@V?$CwiseUnaryOp@U?$scalar_multiple_op@N@internal@Eigen@@$$CBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$04@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$03@1@AEBV?$MatrixBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z ; Eigen::MatrixBase<Eigen::GeneralProduct<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>,Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> > const >,Eigen::Matrix<double,-1,-1,0,-1,-1>,5> >::operator*<Eigen::Matrix<double,-1,1,0,-1,1> >
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 603  :     EIGEN_STRONG_INLINE void _set_selector(const OtherDerived& other, const internal::true_type&) { _set_noalias(other.eval()); }

	lea	rdx, QWORD PTR $T34[rbp-256]
	mov	rcx, rax
	call	?eval@?$DenseBase@V?$GeneralProduct@V?$GeneralProduct@V?$CwiseUnaryOp@U?$scalar_multiple_op@N@internal@Eigen@@$$CBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$04@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$03@Eigen@@@Eigen@@QEBA?BV?$Matrix@N$0?0$00$0A@$0?0$00@2@XZ ; Eigen::DenseBase<Eigen::GeneralProduct<Eigen::GeneralProduct<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>,Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> > const >,Eigen::Matrix<double,-1,-1,0,-1,-1>,5>,Eigen::Matrix<double,-1,1,0,-1,1>,4> >::eval
	mov	rsi, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 313  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rdi, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	test	rdi, rdi
	je	SHORT $LN5938@setJandH
	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	rdi, rax
	setg	cl

; 45   :     if (error)

	test	cl, cl
	je	SHORT $LN2392@setJandH

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN2392@setJandH:

; 157  :     }
; 158  : 
; 159  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
; 160  :     {
; 161  :       return m_storage.data()[index];
; 162  :     }
; 163  : 
; 164  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
; 165  :     {
; 166  :       if(Flags & RowMajorBit)
; 167  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 168  :       else // column-major
; 169  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 170  :     }
; 171  : 
; 172  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
; 173  :     {
; 174  :       return m_storage.data()[index];
; 175  :     }
; 176  : 
; 177  :     /** \internal */
; 178  :     template<int LoadMode>
; 179  :     EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const
; 180  :     {
; 181  :       return internal::ploadt<PacketScalar, LoadMode>
; 182  :                (m_storage.data() + (Flags & RowMajorBit
; 183  :                                    ? colId + rowId * m_storage.cols()
; 184  :                                    : rowId + colId * m_storage.rows()));
; 185  :     }
; 186  : 
; 187  :     /** \internal */
; 188  :     template<int LoadMode>
; 189  :     EIGEN_STRONG_INLINE PacketScalar packet(Index index) const
; 190  :     {
; 191  :       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);
; 192  :     }
; 193  : 
; 194  :     /** \internal */
; 195  :     template<int StoreMode>
; 196  :     EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)
; 197  :     {
; 198  :       internal::pstoret<Scalar, PacketScalar, StoreMode>
; 199  :               (m_storage.data() + (Flags & RowMajorBit
; 200  :                                    ? colId + rowId * m_storage.cols()
; 201  :                                    : rowId + colId * m_storage.rows()), val);
; 202  :     }
; 203  : 
; 204  :     /** \internal */
; 205  :     template<int StoreMode>
; 206  :     EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
; 207  :     {
; 208  :       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
; 209  :     }
; 210  : 
; 211  :     /** \returns a const pointer to the data array of this matrix */
; 212  :     EIGEN_STRONG_INLINE const Scalar *data() const
; 213  :     { return m_storage.data(); }
; 214  : 
; 215  :     /** \returns a pointer to the data array of this matrix */
; 216  :     EIGEN_STRONG_INLINE Scalar *data()
; 217  :     { return m_storage.data(); }
; 218  : 
; 219  :     /** Resizes \c *this to a \a rows x \a cols matrix.
; 220  :       *
; 221  :       * This method is intended for dynamic-size matrices, although it is legal to call it on any
; 222  :       * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
; 223  :       * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
; 224  :       *
; 225  :       * If the current number of coefficients of \c *this exactly matches the
; 226  :       * product \a rows * \a cols, then no memory allocation is performed and
; 227  :       * the current values are left unchanged. In all other cases, including
; 228  :       * shrinking, the data is reallocated and all previous values are lost.
; 229  :       *
; 230  :       * Example: \include Matrix_resize_int_int.cpp
; 231  :       * Output: \verbinclude Matrix_resize_int_int.out
; 232  :       *
; 233  :       * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
; 234  :       */
; 235  :     EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)
; 236  :     {
; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rdi, rdi
$LN5938@setJandH:
	jns	SHORT $LN2459@setJandH
	mov	r8d, 241				; 000000f1H
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	call	QWORD PTR __imp__wassert
$LN2459@setJandH:

; 44   :                : (rows > max_index / cols);

	test	rdi, rdi
	je	SHORT $LN2466@setJandH
	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	rdi, rax
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN2466@setJandH

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN2466@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 322  :       if(size != m_rows*_Cols)

	lea	r10, QWORD PTR [r13+272]
	cmp	rdi, QWORD PTR [r10+8]
	je	SHORT $LN2471@setJandH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR [r10]
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 325  :         if (size)

	test	rdi, rdi
	je	SHORT $LN2472@setJandH

; 326  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

	mov	rcx, rdi
	call	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
	lea	r10, QWORD PTR [r13+272]
	mov	QWORD PTR [r10], rax

; 327  :         else

	jmp	SHORT $LN2471@setJandH
$LN2472@setJandH:

; 328  :           m_data = 0;

	lea	r10, QWORD PTR [r13+272]
	mov	QWORD PTR [r10], r15
$LN2471@setJandH:

; 329  :         EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN
; 330  :       }
; 331  :       m_rows = nbRows;

	mov	QWORD PTR [r10+8], rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	cmp	rdi, QWORD PTR [rsi+8]
	je	SHORT $LN2536@setJandH
	mov	r8d, 498				; 000001f2H
	lea	rdx, OFFSET FLAT:??_C@_1KO@HDGCFKMN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GC@PBCDNLIH@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ@
	call	QWORD PTR __imp__wassert
	lea	r10, QWORD PTR [r13+272]
$LN2536@setJandH:

; 395  :     const Index size = dst.size();

	mov	r9, QWORD PTR [r10+8]

; 404  :     const Index alignedEnd = alignedStart + ((size-alignedStart)/packetSize)*packetSize;

	mov	rax, r9
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r8, rax
	add	r8, r8

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	mov	rcx, r15
	test	r8, r8
	jle	SHORT $LN2573@setJandH
	npad	9
$LL2575@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 333  :     inline const T *data() const { return m_data; }

	mov	rax, QWORD PTR [rsi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 220  : template<> EIGEN_STRONG_INLINE Packet2d pload<Packet2d>(const double*  from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_pd(from); }

	movaps	xmm0, XMMWORD PTR [rax+rcx*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 334  :     inline T *data() { return m_data; }

	mov	rax, QWORD PTR [r10]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [rax+rcx*8], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	add	rcx, 2
	cmp	rcx, r8
	jl	SHORT $LL2575@setJandH
$LN2573@setJandH:

; 409  :     {
; 410  :       dst.template copyPacket<Derived2, dstAlignment, srcAlignment>(index, src);
; 411  :     }
; 412  : 
; 413  :     unaligned_assign_impl<>::run(src,dst,alignedEnd,size);

	mov	rdx, r10
	mov	rcx, rsi
	call	??$run@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V12@@?$unaligned_assign_impl@$0A@@internal@Eigen@@SAXAEBV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEAV32@_J2@Z ; Eigen::internal::unaligned_assign_impl<0>::run<Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Matrix<double,-1,1,0,-1,1> >
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR $T34[rbp-256]
	call	QWORD PTR __imp_free
	npad	1
	mov	rcx, QWORD PTR $T16[rsp+16]
	call	QWORD PTR __imp_free
	npad	1
	mov	rcx, QWORD PTR $T30[rbp-224]
	call	QWORD PTR __imp_free
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 198  : 	Jv = 2.0 * lambdaSquared1 * Lv.transpose() * Lv * v;

	mulsd	xmm8, xmm11
	lea	r15, QWORD PTR [r13+176]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwiseunaryop.h

; 68   :       : m_xpr(xpr), m_functor(func) {}

	mov	QWORD PTR $T23[rsp+8], r15
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h

; 466  :   EIGEN_STRONG_INLINE scalar_multiple_op(const scalar_multiple_op& other) : m_other(other.m_other) { }

	movsdx	QWORD PTR $T23[rbp-240], xmm8
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 198  : 	Jv = 2.0 * lambdaSquared1 * Lv.transpose() * Lv * v;

	mov	r8, r15
	lea	rdx, QWORD PTR $T29[rbp-256]
	lea	rcx, QWORD PTR $T23[rsp+1]
	call	??$?DV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@?$MatrixBase@V?$CwiseUnaryOp@U?$scalar_multiple_op@N@internal@Eigen@@$$CBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Eigen@@@Eigen@@QEBA?BV?$GeneralProduct@V?$CwiseUnaryOp@U?$scalar_multiple_op@N@internal@Eigen@@$$CBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$04@1@AEBV?$MatrixBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@1@@Z ; Eigen::MatrixBase<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>,Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> > const > >::operator*<Eigen::Matrix<double,-1,-1,0,-1,-1> >
	npad	1
	lea	r8, QWORD PTR [r13+416]
	lea	rdx, QWORD PTR $T15[rsp]
	mov	rcx, rax
	call	??$?DV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$MatrixBase@V?$GeneralProduct@V?$CwiseUnaryOp@U?$scalar_multiple_op@N@internal@Eigen@@$$CBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$04@Eigen@@@Eigen@@QEBA?BV?$GeneralProduct@V?$GeneralProduct@V?$CwiseUnaryOp@U?$scalar_multiple_op@N@internal@Eigen@@$$CBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$04@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$03@1@AEBV?$MatrixBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z ; Eigen::MatrixBase<Eigen::GeneralProduct<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>,Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> > const >,Eigen::Matrix<double,-1,-1,0,-1,-1>,5> >::operator*<Eigen::Matrix<double,-1,1,0,-1,1> >
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 603  :     EIGEN_STRONG_INLINE void _set_selector(const OtherDerived& other, const internal::true_type&) { _set_noalias(other.eval()); }

	lea	rdx, QWORD PTR $T33[rbp-256]
	mov	rcx, rax
	call	?eval@?$DenseBase@V?$GeneralProduct@V?$GeneralProduct@V?$CwiseUnaryOp@U?$scalar_multiple_op@N@internal@Eigen@@$$CBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$04@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$03@Eigen@@@Eigen@@QEBA?BV?$Matrix@N$0?0$00$0A@$0?0$00@2@XZ ; Eigen::DenseBase<Eigen::GeneralProduct<Eigen::GeneralProduct<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>,Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> > const >,Eigen::Matrix<double,-1,-1,0,-1,-1>,5>,Eigen::Matrix<double,-1,1,0,-1,1>,4> >::eval
	mov	rsi, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 313  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rdi, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	test	rdi, rdi
	je	SHORT $LN5940@setJandH
	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	rdi, rax
	setg	cl

; 45   :     if (error)

	test	cl, cl
	je	SHORT $LN2766@setJandH

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN2766@setJandH:

; 157  :     }
; 158  : 
; 159  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
; 160  :     {
; 161  :       return m_storage.data()[index];
; 162  :     }
; 163  : 
; 164  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
; 165  :     {
; 166  :       if(Flags & RowMajorBit)
; 167  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 168  :       else // column-major
; 169  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 170  :     }
; 171  : 
; 172  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
; 173  :     {
; 174  :       return m_storage.data()[index];
; 175  :     }
; 176  : 
; 177  :     /** \internal */
; 178  :     template<int LoadMode>
; 179  :     EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const
; 180  :     {
; 181  :       return internal::ploadt<PacketScalar, LoadMode>
; 182  :                (m_storage.data() + (Flags & RowMajorBit
; 183  :                                    ? colId + rowId * m_storage.cols()
; 184  :                                    : rowId + colId * m_storage.rows()));
; 185  :     }
; 186  : 
; 187  :     /** \internal */
; 188  :     template<int LoadMode>
; 189  :     EIGEN_STRONG_INLINE PacketScalar packet(Index index) const
; 190  :     {
; 191  :       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);
; 192  :     }
; 193  : 
; 194  :     /** \internal */
; 195  :     template<int StoreMode>
; 196  :     EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)
; 197  :     {
; 198  :       internal::pstoret<Scalar, PacketScalar, StoreMode>
; 199  :               (m_storage.data() + (Flags & RowMajorBit
; 200  :                                    ? colId + rowId * m_storage.cols()
; 201  :                                    : rowId + colId * m_storage.rows()), val);
; 202  :     }
; 203  : 
; 204  :     /** \internal */
; 205  :     template<int StoreMode>
; 206  :     EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
; 207  :     {
; 208  :       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
; 209  :     }
; 210  : 
; 211  :     /** \returns a const pointer to the data array of this matrix */
; 212  :     EIGEN_STRONG_INLINE const Scalar *data() const
; 213  :     { return m_storage.data(); }
; 214  : 
; 215  :     /** \returns a pointer to the data array of this matrix */
; 216  :     EIGEN_STRONG_INLINE Scalar *data()
; 217  :     { return m_storage.data(); }
; 218  : 
; 219  :     /** Resizes \c *this to a \a rows x \a cols matrix.
; 220  :       *
; 221  :       * This method is intended for dynamic-size matrices, although it is legal to call it on any
; 222  :       * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
; 223  :       * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
; 224  :       *
; 225  :       * If the current number of coefficients of \c *this exactly matches the
; 226  :       * product \a rows * \a cols, then no memory allocation is performed and
; 227  :       * the current values are left unchanged. In all other cases, including
; 228  :       * shrinking, the data is reallocated and all previous values are lost.
; 229  :       *
; 230  :       * Example: \include Matrix_resize_int_int.cpp
; 231  :       * Output: \verbinclude Matrix_resize_int_int.out
; 232  :       *
; 233  :       * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
; 234  :       */
; 235  :     EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)
; 236  :     {
; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rdi, rdi
$LN5940@setJandH:
	jns	SHORT $LN2833@setJandH
	mov	r8d, 241				; 000000f1H
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	call	QWORD PTR __imp__wassert
$LN2833@setJandH:

; 44   :                : (rows > max_index / cols);

	test	rdi, rdi
	je	SHORT $LN2840@setJandH
	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	rdi, rax
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN2840@setJandH

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN2840@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 322  :       if(size != m_rows*_Cols)

	lea	r10, QWORD PTR [r13+288]
	cmp	rdi, QWORD PTR [r10+8]
	je	SHORT $LN2845@setJandH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR [r10]
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 325  :         if (size)

	test	rdi, rdi
	je	SHORT $LN2846@setJandH

; 326  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

	mov	rcx, rdi
	call	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
	lea	r10, QWORD PTR [r13+288]
	mov	QWORD PTR [r10], rax

; 327  :         else

	jmp	SHORT $LN2845@setJandH
$LN2846@setJandH:

; 328  :           m_data = 0;

	lea	r10, QWORD PTR [r13+288]
	mov	QWORD PTR [r10], 0
$LN2845@setJandH:

; 329  :         EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN
; 330  :       }
; 331  :       m_rows = nbRows;

	mov	QWORD PTR [r10+8], rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	cmp	rdi, QWORD PTR [rsi+8]
	je	SHORT $LN2910@setJandH
	mov	r8d, 498				; 000001f2H
	lea	rdx, OFFSET FLAT:??_C@_1KO@HDGCFKMN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GC@PBCDNLIH@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ@
	call	QWORD PTR __imp__wassert
	lea	r10, QWORD PTR [r13+288]
$LN2910@setJandH:

; 395  :     const Index size = dst.size();

	mov	r9, QWORD PTR [r10+8]

; 404  :     const Index alignedEnd = alignedStart + ((size-alignedStart)/packetSize)*packetSize;

	mov	rax, r9
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r8, rax
	add	r8, r8

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	xor	ecx, ecx
	test	r8, r8
	jle	SHORT $LN2947@setJandH
	npad	10
$LL2949@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 333  :     inline const T *data() const { return m_data; }

	mov	rax, QWORD PTR [rsi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 220  : template<> EIGEN_STRONG_INLINE Packet2d pload<Packet2d>(const double*  from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_pd(from); }

	movaps	xmm0, XMMWORD PTR [rax+rcx*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 334  :     inline T *data() { return m_data; }

	mov	rax, QWORD PTR [r10]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [rax+rcx*8], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	add	rcx, 2
	cmp	rcx, r8
	jl	SHORT $LL2949@setJandH
$LN2947@setJandH:

; 409  :     {
; 410  :       dst.template copyPacket<Derived2, dstAlignment, srcAlignment>(index, src);
; 411  :     }
; 412  : 
; 413  :     unaligned_assign_impl<>::run(src,dst,alignedEnd,size);

	mov	rdx, r10
	mov	rcx, rsi
	call	??$run@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V12@@?$unaligned_assign_impl@$0A@@internal@Eigen@@SAXAEBV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEAV32@_J2@Z ; Eigen::internal::unaligned_assign_impl<0>::run<Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Matrix<double,-1,1,0,-1,1> >
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR $T33[rbp-256]
	call	QWORD PTR __imp_free
	npad	1
	mov	rcx, QWORD PTR $T15[rsp+16]
	call	QWORD PTR __imp_free
	npad	1
	mov	rcx, QWORD PTR $T29[rbp-224]
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwiseunaryop.h

; 68   :       : m_xpr(xpr), m_functor(func) {}

	mov	QWORD PTR $T22[rsp+8], r14
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h

; 466  :   EIGEN_STRONG_INLINE scalar_multiple_op(const scalar_multiple_op& other) : m_other(other.m_other) { }

	movsdx	QWORD PTR $T22[rbp-240], xmm6
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 199  : 	Hff = 2.0 * lambdaSquared0 * Lf.transpose() * Lf;

	mov	r8, r14
	lea	rdx, QWORD PTR $T28[rbp-256]
	lea	rcx, QWORD PTR $T22[rsp+1]
	call	??$?DV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@?$MatrixBase@V?$CwiseUnaryOp@U?$scalar_multiple_op@N@internal@Eigen@@$$CBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Eigen@@@Eigen@@QEBA?BV?$GeneralProduct@V?$CwiseUnaryOp@U?$scalar_multiple_op@N@internal@Eigen@@$$CBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$04@1@AEBV?$MatrixBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@1@@Z ; Eigen::MatrixBase<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>,Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> > const > >::operator*<Eigen::Matrix<double,-1,-1,0,-1,-1> >
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 603  :     EIGEN_STRONG_INLINE void _set_selector(const OtherDerived& other, const internal::true_type&) { _set_noalias(other.eval()); }

	lea	rdx, QWORD PTR $T19[rsp]
	mov	rcx, rax
	call	?eval@?$DenseBase@V?$GeneralProduct@V?$CwiseUnaryOp@U?$scalar_multiple_op@N@internal@Eigen@@$$CBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$04@Eigen@@@Eigen@@QEBA?BV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@XZ ; Eigen::DenseBase<Eigen::GeneralProduct<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>,Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> > const >,Eigen::Matrix<double,-1,-1,0,-1,-1>,5> >::eval
	mov	r14, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 240  :     inline DenseIndex cols(void) const {return m_cols;}

	mov	rdi, QWORD PTR [rax+16]

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rsi, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	test	rsi, rsi
	je	SHORT $LN5942@setJandH
	test	rdi, rdi
	je	SHORT $LN3140@setJandH
	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cdq
	idiv	rdi
	cmp	rsi, rax
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN3140@setJandH

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN3140@setJandH:

; 157  :     }
; 158  : 
; 159  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
; 160  :     {
; 161  :       return m_storage.data()[index];
; 162  :     }
; 163  : 
; 164  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
; 165  :     {
; 166  :       if(Flags & RowMajorBit)
; 167  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 168  :       else // column-major
; 169  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 170  :     }
; 171  : 
; 172  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
; 173  :     {
; 174  :       return m_storage.data()[index];
; 175  :     }
; 176  : 
; 177  :     /** \internal */
; 178  :     template<int LoadMode>
; 179  :     EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const
; 180  :     {
; 181  :       return internal::ploadt<PacketScalar, LoadMode>
; 182  :                (m_storage.data() + (Flags & RowMajorBit
; 183  :                                    ? colId + rowId * m_storage.cols()
; 184  :                                    : rowId + colId * m_storage.rows()));
; 185  :     }
; 186  : 
; 187  :     /** \internal */
; 188  :     template<int LoadMode>
; 189  :     EIGEN_STRONG_INLINE PacketScalar packet(Index index) const
; 190  :     {
; 191  :       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);
; 192  :     }
; 193  : 
; 194  :     /** \internal */
; 195  :     template<int StoreMode>
; 196  :     EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)
; 197  :     {
; 198  :       internal::pstoret<Scalar, PacketScalar, StoreMode>
; 199  :               (m_storage.data() + (Flags & RowMajorBit
; 200  :                                    ? colId + rowId * m_storage.cols()
; 201  :                                    : rowId + colId * m_storage.rows()), val);
; 202  :     }
; 203  : 
; 204  :     /** \internal */
; 205  :     template<int StoreMode>
; 206  :     EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
; 207  :     {
; 208  :       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
; 209  :     }
; 210  : 
; 211  :     /** \returns a const pointer to the data array of this matrix */
; 212  :     EIGEN_STRONG_INLINE const Scalar *data() const
; 213  :     { return m_storage.data(); }
; 214  : 
; 215  :     /** \returns a pointer to the data array of this matrix */
; 216  :     EIGEN_STRONG_INLINE Scalar *data()
; 217  :     { return m_storage.data(); }
; 218  : 
; 219  :     /** Resizes \c *this to a \a rows x \a cols matrix.
; 220  :       *
; 221  :       * This method is intended for dynamic-size matrices, although it is legal to call it on any
; 222  :       * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
; 223  :       * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
; 224  :       *
; 225  :       * If the current number of coefficients of \c *this exactly matches the
; 226  :       * product \a rows * \a cols, then no memory allocation is performed and
; 227  :       * the current values are left unchanged. In all other cases, including
; 228  :       * shrinking, the data is reallocated and all previous values are lost.
; 229  :       *
; 230  :       * Example: \include Matrix_resize_int_int.cpp
; 231  :       * Output: \verbinclude Matrix_resize_int_int.out
; 232  :       *
; 233  :       * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
; 234  :       */
; 235  :     EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)
; 236  :     {
; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rsi, rsi
$LN5942@setJandH:
	js	SHORT $LN3210@setJandH
	test	rdi, rdi
	jns	SHORT $LN3211@setJandH
$LN3210@setJandH:
	mov	r8d, 241				; 000000f1H
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	call	QWORD PTR __imp__wassert
$LN3211@setJandH:

; 44   :                : (rows > max_index / cols);

	test	rsi, rsi
	je	SHORT $LN3218@setJandH
	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	test	rdi, rdi
	je	SHORT $LN3218@setJandH
	mov	rax, rcx
	cdq
	idiv	rdi
	cmp	rsi, rax
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN3212@setJandH

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN3212@setJandH:

; 44   :                : (rows > max_index / cols);

	test	rdi, rdi
	je	SHORT $LN3218@setJandH
	mov	rax, rcx
	cdq
	idiv	rdi
	cmp	rsi, rax
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN3218@setJandH

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN3218@setJandH:

; 238  :                    && EIGEN_IMPLIES(ColsAtCompileTime!=Dynamic,nbCols==ColsAtCompileTime)
; 239  :                    && EIGEN_IMPLIES(RowsAtCompileTime==Dynamic && MaxRowsAtCompileTime!=Dynamic,nbRows<=MaxRowsAtCompileTime)
; 240  :                    && EIGEN_IMPLIES(ColsAtCompileTime==Dynamic && MaxColsAtCompileTime!=Dynamic,nbCols<=MaxColsAtCompileTime)
; 241  :                    && nbRows>=0 && nbCols>=0 && "Invalid sizes when resizing a matrix or array.");
; 242  :       internal::check_rows_cols_for_overflow<MaxSizeAtCompileTime>::run(nbRows, nbCols);
; 243  :       #ifdef EIGEN_INITIALIZE_COEFFS
; 244  :         Index size = nbRows*nbCols;
; 245  :         bool size_changed = size != this->size();
; 246  :         m_storage.resize(size, nbRows, nbCols);
; 247  :         if(size_changed) EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED
; 248  :       #else
; 249  :         internal::check_rows_cols_for_overflow<MaxSizeAtCompileTime>::run(nbRows, nbCols);
; 250  :         m_storage.resize(nbRows*nbCols, nbRows, nbCols);

	mov	rdx, rdi
	imul	rdx, rsi
	mov	r9, rdi
	mov	r8, rsi
	lea	rdi, QWORD PTR [r13+328]
	mov	rcx, rdi
	call	?resize@?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAAX_J00@Z ; Eigen::DenseStorage<double,-1,-1,-1,0>::resize
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rax, QWORD PTR [rdi+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	cmp	rax, QWORD PTR [r14+8]
	jne	SHORT $LN3229@setJandH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 240  :     inline DenseIndex cols(void) const {return m_cols;}

	mov	rax, QWORD PTR [rdi+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	cmp	rax, QWORD PTR [r14+16]
	je	SHORT $LN3230@setJandH
$LN3229@setJandH:
	mov	r8d, 498				; 000001f2H
	lea	rdx, OFFSET FLAT:??_C@_1KO@HDGCFKMN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GC@PBCDNLIH@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ@
	call	QWORD PTR __imp__wassert
$LN3230@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 240  :     inline DenseIndex cols(void) const {return m_cols;}

	mov	r9, QWORD PTR [rdi+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 49   :   inline Index size() const { return rows() * cols(); }

	imul	r9, QWORD PTR [rdi+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 404  :     const Index alignedEnd = alignedStart + ((size-alignedStart)/packetSize)*packetSize;

	mov	rax, r9
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r8, rax
	add	r8, r8

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	xor	ecx, ecx
	test	r8, r8
	jle	SHORT $LN3267@setJandH
	npad	7
$LL3269@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 261  :     inline const T *data() const { return m_data; }

	mov	rax, QWORD PTR [r14]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 220  : template<> EIGEN_STRONG_INLINE Packet2d pload<Packet2d>(const double*  from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_pd(from); }

	movaps	xmm0, XMMWORD PTR [rax+rcx*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 262  :     inline T *data() { return m_data; }

	mov	rax, QWORD PTR [rdi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [rax+rcx*8], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	add	rcx, 2
	cmp	rcx, r8
	jl	SHORT $LL3269@setJandH
$LN3267@setJandH:

; 409  :     {
; 410  :       dst.template copyPacket<Derived2, dstAlignment, srcAlignment>(index, src);
; 411  :     }
; 412  : 
; 413  :     unaligned_assign_impl<>::run(src,dst,alignedEnd,size);

	mov	rdx, rdi
	mov	rcx, r14
	call	??$run@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V12@@?$unaligned_assign_impl@$0A@@internal@Eigen@@SAXAEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@AEAV32@_J2@Z ; Eigen::internal::unaligned_assign_impl<0>::run<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::Matrix<double,-1,-1,0,-1,-1> >
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR $T19[rsp]
	call	QWORD PTR __imp_free
	npad	1
	mov	rcx, QWORD PTR $T28[rbp-224]
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwiseunaryop.h

; 68   :       : m_xpr(xpr), m_functor(func) {}

	mov	QWORD PTR $T21[rsp+8], r15
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h

; 466  :   EIGEN_STRONG_INLINE scalar_multiple_op(const scalar_multiple_op& other) : m_other(other.m_other) { }

	movsdx	QWORD PTR $T21[rbp-240], xmm8
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 200  : 	Hvv = 2.0 * lambdaSquared1 * Lv.transpose() * Lv;

	mov	r8, r15
	lea	rdx, QWORD PTR $T27[rbp-256]
	lea	rcx, QWORD PTR $T21[rsp+1]
	call	??$?DV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@?$MatrixBase@V?$CwiseUnaryOp@U?$scalar_multiple_op@N@internal@Eigen@@$$CBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Eigen@@@Eigen@@QEBA?BV?$GeneralProduct@V?$CwiseUnaryOp@U?$scalar_multiple_op@N@internal@Eigen@@$$CBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$04@1@AEBV?$MatrixBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@1@@Z ; Eigen::MatrixBase<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>,Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> > const > >::operator*<Eigen::Matrix<double,-1,-1,0,-1,-1> >
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 603  :     EIGEN_STRONG_INLINE void _set_selector(const OtherDerived& other, const internal::true_type&) { _set_noalias(other.eval()); }

	lea	rdx, QWORD PTR $T18[rsp]
	mov	rcx, rax
	call	?eval@?$DenseBase@V?$GeneralProduct@V?$CwiseUnaryOp@U?$scalar_multiple_op@N@internal@Eigen@@$$CBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$04@Eigen@@@Eigen@@QEBA?BV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@XZ ; Eigen::DenseBase<Eigen::GeneralProduct<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>,Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> > const >,Eigen::Matrix<double,-1,-1,0,-1,-1>,5> >::eval
	mov	r14, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 240  :     inline DenseIndex cols(void) const {return m_cols;}

	mov	rdi, QWORD PTR [rax+16]

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rsi, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	mov	r15, 9223372036854775807		; 7fffffffffffffffH
	test	rsi, rsi
	je	SHORT $LN5949@setJandH
	test	rdi, rdi
	je	SHORT $LN3438@setJandH
	mov	rax, r15
	cdq
	idiv	rdi
	cmp	rsi, rax
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN3438@setJandH

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN3438@setJandH:

; 157  :     }
; 158  : 
; 159  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
; 160  :     {
; 161  :       return m_storage.data()[index];
; 162  :     }
; 163  : 
; 164  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
; 165  :     {
; 166  :       if(Flags & RowMajorBit)
; 167  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 168  :       else // column-major
; 169  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 170  :     }
; 171  : 
; 172  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
; 173  :     {
; 174  :       return m_storage.data()[index];
; 175  :     }
; 176  : 
; 177  :     /** \internal */
; 178  :     template<int LoadMode>
; 179  :     EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const
; 180  :     {
; 181  :       return internal::ploadt<PacketScalar, LoadMode>
; 182  :                (m_storage.data() + (Flags & RowMajorBit
; 183  :                                    ? colId + rowId * m_storage.cols()
; 184  :                                    : rowId + colId * m_storage.rows()));
; 185  :     }
; 186  : 
; 187  :     /** \internal */
; 188  :     template<int LoadMode>
; 189  :     EIGEN_STRONG_INLINE PacketScalar packet(Index index) const
; 190  :     {
; 191  :       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);
; 192  :     }
; 193  : 
; 194  :     /** \internal */
; 195  :     template<int StoreMode>
; 196  :     EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)
; 197  :     {
; 198  :       internal::pstoret<Scalar, PacketScalar, StoreMode>
; 199  :               (m_storage.data() + (Flags & RowMajorBit
; 200  :                                    ? colId + rowId * m_storage.cols()
; 201  :                                    : rowId + colId * m_storage.rows()), val);
; 202  :     }
; 203  : 
; 204  :     /** \internal */
; 205  :     template<int StoreMode>
; 206  :     EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
; 207  :     {
; 208  :       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
; 209  :     }
; 210  : 
; 211  :     /** \returns a const pointer to the data array of this matrix */
; 212  :     EIGEN_STRONG_INLINE const Scalar *data() const
; 213  :     { return m_storage.data(); }
; 214  : 
; 215  :     /** \returns a pointer to the data array of this matrix */
; 216  :     EIGEN_STRONG_INLINE Scalar *data()
; 217  :     { return m_storage.data(); }
; 218  : 
; 219  :     /** Resizes \c *this to a \a rows x \a cols matrix.
; 220  :       *
; 221  :       * This method is intended for dynamic-size matrices, although it is legal to call it on any
; 222  :       * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
; 223  :       * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
; 224  :       *
; 225  :       * If the current number of coefficients of \c *this exactly matches the
; 226  :       * product \a rows * \a cols, then no memory allocation is performed and
; 227  :       * the current values are left unchanged. In all other cases, including
; 228  :       * shrinking, the data is reallocated and all previous values are lost.
; 229  :       *
; 230  :       * Example: \include Matrix_resize_int_int.cpp
; 231  :       * Output: \verbinclude Matrix_resize_int_int.out
; 232  :       *
; 233  :       * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
; 234  :       */
; 235  :     EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)
; 236  :     {
; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rsi, rsi
$LN5949@setJandH:
	js	SHORT $LN3508@setJandH
	test	rdi, rdi
	jns	SHORT $LN3509@setJandH
$LN3508@setJandH:
	mov	r8d, 241				; 000000f1H
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	call	QWORD PTR __imp__wassert
$LN3509@setJandH:

; 44   :                : (rows > max_index / cols);

	test	rsi, rsi
	je	SHORT $LN3516@setJandH
	test	rdi, rdi
	je	SHORT $LN3516@setJandH
	mov	rax, r15
	cdq
	idiv	rdi
	cmp	rsi, rax
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN3510@setJandH

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN3510@setJandH:

; 44   :                : (rows > max_index / cols);

	test	rdi, rdi
	je	SHORT $LN3516@setJandH
	mov	rax, r15
	cdq
	idiv	rdi
	cmp	rsi, rax
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN3516@setJandH

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN3516@setJandH:

; 238  :                    && EIGEN_IMPLIES(ColsAtCompileTime!=Dynamic,nbCols==ColsAtCompileTime)
; 239  :                    && EIGEN_IMPLIES(RowsAtCompileTime==Dynamic && MaxRowsAtCompileTime!=Dynamic,nbRows<=MaxRowsAtCompileTime)
; 240  :                    && EIGEN_IMPLIES(ColsAtCompileTime==Dynamic && MaxColsAtCompileTime!=Dynamic,nbCols<=MaxColsAtCompileTime)
; 241  :                    && nbRows>=0 && nbCols>=0 && "Invalid sizes when resizing a matrix or array.");
; 242  :       internal::check_rows_cols_for_overflow<MaxSizeAtCompileTime>::run(nbRows, nbCols);
; 243  :       #ifdef EIGEN_INITIALIZE_COEFFS
; 244  :         Index size = nbRows*nbCols;
; 245  :         bool size_changed = size != this->size();
; 246  :         m_storage.resize(size, nbRows, nbCols);
; 247  :         if(size_changed) EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED
; 248  :       #else
; 249  :         internal::check_rows_cols_for_overflow<MaxSizeAtCompileTime>::run(nbRows, nbCols);
; 250  :         m_storage.resize(nbRows*nbCols, nbRows, nbCols);

	mov	rdx, rdi
	imul	rdx, rsi
	mov	r9, rdi
	mov	r8, rsi
	lea	rdi, QWORD PTR [r13+352]
	mov	rcx, rdi
	call	?resize@?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAAX_J00@Z ; Eigen::DenseStorage<double,-1,-1,-1,0>::resize
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rax, QWORD PTR [rdi+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	cmp	rax, QWORD PTR [r14+8]
	jne	SHORT $LN3527@setJandH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 240  :     inline DenseIndex cols(void) const {return m_cols;}

	mov	rax, QWORD PTR [rdi+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	cmp	rax, QWORD PTR [r14+16]
	je	SHORT $LN3528@setJandH
$LN3527@setJandH:
	mov	r8d, 498				; 000001f2H
	lea	rdx, OFFSET FLAT:??_C@_1KO@HDGCFKMN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GC@PBCDNLIH@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ@
	call	QWORD PTR __imp__wassert
$LN3528@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 240  :     inline DenseIndex cols(void) const {return m_cols;}

	mov	r9, QWORD PTR [rdi+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 49   :   inline Index size() const { return rows() * cols(); }

	imul	r9, QWORD PTR [rdi+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 404  :     const Index alignedEnd = alignedStart + ((size-alignedStart)/packetSize)*packetSize;

	mov	rax, r9
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r8, rax
	add	r8, r8

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	xor	ecx, ecx
	test	r8, r8
	jle	SHORT $LN3565@setJandH
	npad	8
$LL3567@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 261  :     inline const T *data() const { return m_data; }

	mov	rax, QWORD PTR [r14]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 220  : template<> EIGEN_STRONG_INLINE Packet2d pload<Packet2d>(const double*  from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_pd(from); }

	movaps	xmm0, XMMWORD PTR [rax+rcx*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 262  :     inline T *data() { return m_data; }

	mov	rax, QWORD PTR [rdi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [rax+rcx*8], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	add	rcx, 2
	cmp	rcx, r8
	jl	SHORT $LL3567@setJandH
$LN3565@setJandH:

; 409  :     {
; 410  :       dst.template copyPacket<Derived2, dstAlignment, srcAlignment>(index, src);
; 411  :     }
; 412  : 
; 413  :     unaligned_assign_impl<>::run(src,dst,alignedEnd,size);

	mov	rdx, rdi
	mov	rcx, r14
	call	??$run@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V12@@?$unaligned_assign_impl@$0A@@internal@Eigen@@SAXAEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@AEAV32@_J2@Z ; Eigen::internal::unaligned_assign_impl<0>::run<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::Matrix<double,-1,-1,0,-1,-1> >
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR $T18[rsp]
	call	QWORD PTR __imp_free
	npad	1
	mov	rcx, QWORD PTR $T27[rbp-224]
	call	QWORD PTR __imp_free
	xor	eax, eax
	mov	QWORD PTR z$[rbp-256], rax
	mov	QWORD PTR z$[rbp-248], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwiseunaryop.h

; 68   :       : m_xpr(xpr), m_functor(func) {}

	mov	QWORD PTR $T20[rsp+8], r12
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 203  : 	Eigen::VectorXd z = f.array().exp().matrix();

	lea	rdx, QWORD PTR $T32[rbp-256]
	lea	rcx, QWORD PTR $T20[rsp+1]
	call	?matrix@?$ArrayBase@V?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@Eigen@@QEBA?BV?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@XZ ; Eigen::ArrayBase<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > >::matrix
	mov	r15, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 313  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rcx, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 442  :     {

	mov	r8, rdx
	lea	rcx, QWORD PTR z$[rbp-256]
	call	??0?$DenseStorage@N$0?0$0?0$00$0A@@Eigen@@QEAA@_J00@Z ; Eigen::DenseStorage<double,-1,-1,1,0>::DenseStorage<double,-1,-1,1,0>
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 313  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rcx, QWORD PTR [r15+8]
	mov	r12, QWORD PTR [rcx+8]
	mov	QWORD PTR othersize$1$[rsp], r12
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	mov	rdi, 9223372036854775807		; 7fffffffffffffffH
	test	r12, r12
	je	SHORT $LN5950@setJandH
	cmp	r12, rdi
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN3799@setJandH

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN3799@setJandH:

; 157  :     }
; 158  : 
; 159  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
; 160  :     {
; 161  :       return m_storage.data()[index];
; 162  :     }
; 163  : 
; 164  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
; 165  :     {
; 166  :       if(Flags & RowMajorBit)
; 167  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 168  :       else // column-major
; 169  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 170  :     }
; 171  : 
; 172  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
; 173  :     {
; 174  :       return m_storage.data()[index];
; 175  :     }
; 176  : 
; 177  :     /** \internal */
; 178  :     template<int LoadMode>
; 179  :     EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const
; 180  :     {
; 181  :       return internal::ploadt<PacketScalar, LoadMode>
; 182  :                (m_storage.data() + (Flags & RowMajorBit
; 183  :                                    ? colId + rowId * m_storage.cols()
; 184  :                                    : rowId + colId * m_storage.rows()));
; 185  :     }
; 186  : 
; 187  :     /** \internal */
; 188  :     template<int LoadMode>
; 189  :     EIGEN_STRONG_INLINE PacketScalar packet(Index index) const
; 190  :     {
; 191  :       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);
; 192  :     }
; 193  : 
; 194  :     /** \internal */
; 195  :     template<int StoreMode>
; 196  :     EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)
; 197  :     {
; 198  :       internal::pstoret<Scalar, PacketScalar, StoreMode>
; 199  :               (m_storage.data() + (Flags & RowMajorBit
; 200  :                                    ? colId + rowId * m_storage.cols()
; 201  :                                    : rowId + colId * m_storage.rows()), val);
; 202  :     }
; 203  : 
; 204  :     /** \internal */
; 205  :     template<int StoreMode>
; 206  :     EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
; 207  :     {
; 208  :       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
; 209  :     }
; 210  : 
; 211  :     /** \returns a const pointer to the data array of this matrix */
; 212  :     EIGEN_STRONG_INLINE const Scalar *data() const
; 213  :     { return m_storage.data(); }
; 214  : 
; 215  :     /** \returns a pointer to the data array of this matrix */
; 216  :     EIGEN_STRONG_INLINE Scalar *data()
; 217  :     { return m_storage.data(); }
; 218  : 
; 219  :     /** Resizes \c *this to a \a rows x \a cols matrix.
; 220  :       *
; 221  :       * This method is intended for dynamic-size matrices, although it is legal to call it on any
; 222  :       * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
; 223  :       * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
; 224  :       *
; 225  :       * If the current number of coefficients of \c *this exactly matches the
; 226  :       * product \a rows * \a cols, then no memory allocation is performed and
; 227  :       * the current values are left unchanged. In all other cases, including
; 228  :       * shrinking, the data is reallocated and all previous values are lost.
; 229  :       *
; 230  :       * Example: \include Matrix_resize_int_int.cpp
; 231  :       * Output: \verbinclude Matrix_resize_int_int.out
; 232  :       *
; 233  :       * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
; 234  :       */
; 235  :     EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)
; 236  :     {
; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	r12, r12
$LN5950@setJandH:
	jns	SHORT $LN5944@setJandH
	mov	r8d, 241				; 000000f1H
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	call	QWORD PTR __imp__wassert

; 44   :                : (rows > max_index / cols);

	test	r12, r12
$LN5944@setJandH:
	je	SHORT $LN3909@setJandH
	cmp	r12, rdi
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN3909@setJandH

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN3909@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 322  :       if(size != m_rows*_Cols)

	cmp	r12, QWORD PTR z$[rbp-248]
	je	SHORT $LN5910@setJandH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR z$[rbp-256]
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 325  :         if (size)

	test	r12, r12
	je	SHORT $LN3915@setJandH

; 326  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

	mov	rcx, r12
	call	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
	mov	rsi, rax
	mov	QWORD PTR z$[rbp-256], rax

; 327  :         else

	jmp	SHORT $LN3914@setJandH
$LN3915@setJandH:

; 328  :           m_data = 0;

	xor	esi, esi
	mov	QWORD PTR z$[rbp-256], rsi
	jmp	SHORT $LN3914@setJandH
$LN5910@setJandH:
	mov	rsi, QWORD PTR z$[rbp-256]
$LN3914@setJandH:

; 329  :         EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN
; 330  :       }
; 331  :       m_rows = nbRows;

	mov	QWORD PTR z$[rbp-248], r12

; 313  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rax, QWORD PTR [r15+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	cmp	r12, QWORD PTR [rax+8]
	je	SHORT $LN3991@setJandH
	mov	r8d, 498				; 000001f2H
	lea	rdx, OFFSET FLAT:??_C@_1KO@HDGCFKMN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GC@PBCDNLIH@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ@
	call	QWORD PTR __imp__wassert
$LN3991@setJandH:

; 404  :     const Index alignedEnd = alignedStart + ((size-alignedStart)/packetSize)*packetSize;

	mov	rax, r12
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r14, rax
	add	r14, r14

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	xor	edi, edi
	test	r14, r14
	jle	SHORT $LN4040@setJandH
$LL4042@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 538  :         other.derived().template packet<LoadMode>(index));

	mov	r8, rdi
	lea	rdx, QWORD PTR $T17[rsp]
	mov	rcx, r15
	call	??$packet@$00@?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@Eigen@@QEBA?BU__m128d@@_J@Z ; Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >::packet<1>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	xmm0, XMMWORD PTR [rax]
	movaps	XMMWORD PTR [rsi], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	add	rdi, 2
	lea	rsi, QWORD PTR [rsi+16]
	cmp	rdi, r14
	jl	SHORT $LL4042@setJandH
$LN4040@setJandH:

; 409  :     {
; 410  :       dst.template copyPacket<Derived2, dstAlignment, srcAlignment>(index, src);
; 411  :     }
; 412  : 
; 413  :     unaligned_assign_impl<>::run(src,dst,alignedEnd,size);

	mov	r9, r12
	mov	r8, r14
	lea	rdx, QWORD PTR z$[rbp-256]
	mov	rcx, r15
	call	??$run@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@?$unaligned_assign_impl@$0A@@internal@Eigen@@SAXAEBV?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@_J2@Z ; Eigen::internal::unaligned_assign_impl<0>::run<Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,Eigen::Matrix<double,-1,1,0,-1,1> >
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h

; 518  :   EIGEN_STRONG_INLINE scalar_constant_op(const Scalar& other) : m_other(other) { }

	movsdx	QWORD PTR $T26[rbp-256], xmm7
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwisenullaryop.h

; 119  :   return CwiseNullaryOp<CustomNullaryOp, Derived>(rows, cols, func);

	lea	r9, QWORD PTR $T26[rbp-256]
	mov	r8, QWORD PTR [r13+120]
	mov	rdx, QWORD PTR [r13+112]
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$CwiseNullaryOp@U?$scalar_constant_op@N@internal@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@Eigen@@QEAA@_J0AEBU?$scalar_constant_op@N@internal@1@@Z ; Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>,Eigen::Matrix<double,-1,-1,0,-1,-1> >::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>,Eigen::Matrix<double,-1,-1,0,-1,-1> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	mov	rdi, QWORD PTR $T1[rsp+16]
	mov	rsi, QWORD PTR $T1[rsp+8]
	mov	r14, 9223372036854775807		; 7fffffffffffffffH
	test	rsi, rsi
	je	SHORT $LN5951@setJandH
	test	rdi, rdi
	je	SHORT $LN4180@setJandH
	mov	rax, r14
	cdq
	idiv	rdi
	cmp	rsi, rax
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN4180@setJandH

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN4180@setJandH:

; 157  :     }
; 158  : 
; 159  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
; 160  :     {
; 161  :       return m_storage.data()[index];
; 162  :     }
; 163  : 
; 164  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
; 165  :     {
; 166  :       if(Flags & RowMajorBit)
; 167  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 168  :       else // column-major
; 169  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 170  :     }
; 171  : 
; 172  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
; 173  :     {
; 174  :       return m_storage.data()[index];
; 175  :     }
; 176  : 
; 177  :     /** \internal */
; 178  :     template<int LoadMode>
; 179  :     EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const
; 180  :     {
; 181  :       return internal::ploadt<PacketScalar, LoadMode>
; 182  :                (m_storage.data() + (Flags & RowMajorBit
; 183  :                                    ? colId + rowId * m_storage.cols()
; 184  :                                    : rowId + colId * m_storage.rows()));
; 185  :     }
; 186  : 
; 187  :     /** \internal */
; 188  :     template<int LoadMode>
; 189  :     EIGEN_STRONG_INLINE PacketScalar packet(Index index) const
; 190  :     {
; 191  :       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);
; 192  :     }
; 193  : 
; 194  :     /** \internal */
; 195  :     template<int StoreMode>
; 196  :     EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)
; 197  :     {
; 198  :       internal::pstoret<Scalar, PacketScalar, StoreMode>
; 199  :               (m_storage.data() + (Flags & RowMajorBit
; 200  :                                    ? colId + rowId * m_storage.cols()
; 201  :                                    : rowId + colId * m_storage.rows()), val);
; 202  :     }
; 203  : 
; 204  :     /** \internal */
; 205  :     template<int StoreMode>
; 206  :     EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
; 207  :     {
; 208  :       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
; 209  :     }
; 210  : 
; 211  :     /** \returns a const pointer to the data array of this matrix */
; 212  :     EIGEN_STRONG_INLINE const Scalar *data() const
; 213  :     { return m_storage.data(); }
; 214  : 
; 215  :     /** \returns a pointer to the data array of this matrix */
; 216  :     EIGEN_STRONG_INLINE Scalar *data()
; 217  :     { return m_storage.data(); }
; 218  : 
; 219  :     /** Resizes \c *this to a \a rows x \a cols matrix.
; 220  :       *
; 221  :       * This method is intended for dynamic-size matrices, although it is legal to call it on any
; 222  :       * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
; 223  :       * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
; 224  :       *
; 225  :       * If the current number of coefficients of \c *this exactly matches the
; 226  :       * product \a rows * \a cols, then no memory allocation is performed and
; 227  :       * the current values are left unchanged. In all other cases, including
; 228  :       * shrinking, the data is reallocated and all previous values are lost.
; 229  :       *
; 230  :       * Example: \include Matrix_resize_int_int.cpp
; 231  :       * Output: \verbinclude Matrix_resize_int_int.out
; 232  :       *
; 233  :       * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
; 234  :       */
; 235  :     EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)
; 236  :     {
; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rsi, rsi
$LN5951@setJandH:
	js	SHORT $LN4250@setJandH
	test	rdi, rdi
	jns	SHORT $LN4251@setJandH
$LN4250@setJandH:
	mov	r8d, 241				; 000000f1H
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	call	QWORD PTR __imp__wassert
$LN4251@setJandH:

; 44   :                : (rows > max_index / cols);

	test	rsi, rsi
	je	SHORT $LN4258@setJandH
	test	rdi, rdi
	je	SHORT $LN4258@setJandH
	mov	rax, r14
	cdq
	idiv	rdi
	cmp	rsi, rax
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN4252@setJandH

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN4252@setJandH:

; 44   :                : (rows > max_index / cols);

	test	rdi, rdi
	je	SHORT $LN4258@setJandH
	mov	rax, r14
	cdq
	idiv	rdi
	cmp	rsi, rax
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN4258@setJandH

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN4258@setJandH:

; 238  :                    && EIGEN_IMPLIES(ColsAtCompileTime!=Dynamic,nbCols==ColsAtCompileTime)
; 239  :                    && EIGEN_IMPLIES(RowsAtCompileTime==Dynamic && MaxRowsAtCompileTime!=Dynamic,nbRows<=MaxRowsAtCompileTime)
; 240  :                    && EIGEN_IMPLIES(ColsAtCompileTime==Dynamic && MaxColsAtCompileTime!=Dynamic,nbCols<=MaxColsAtCompileTime)
; 241  :                    && nbRows>=0 && nbCols>=0 && "Invalid sizes when resizing a matrix or array.");
; 242  :       internal::check_rows_cols_for_overflow<MaxSizeAtCompileTime>::run(nbRows, nbCols);
; 243  :       #ifdef EIGEN_INITIALIZE_COEFFS
; 244  :         Index size = nbRows*nbCols;
; 245  :         bool size_changed = size != this->size();
; 246  :         m_storage.resize(size, nbRows, nbCols);
; 247  :         if(size_changed) EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED
; 248  :       #else
; 249  :         internal::check_rows_cols_for_overflow<MaxSizeAtCompileTime>::run(nbRows, nbCols);
; 250  :         m_storage.resize(nbRows*nbCols, nbRows, nbCols);

	mov	rdx, rsi
	imul	rdx, rdi
	mov	r9, rdi
	mov	r8, rsi
	lea	rcx, QWORD PTR [r13+104]
	call	?resize@?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAAX_J00@Z ; Eigen::DenseStorage<double,-1,-1,-1,0>::resize
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	cmp	QWORD PTR [r13+112], rsi
	lea	rsi, QWORD PTR [r13+104]
	jne	SHORT $LN4271@setJandH
	cmp	QWORD PTR [rsi+16], rdi
	je	SHORT $LN5908@setJandH
$LN4271@setJandH:
	mov	r8d, 498				; 000001f2H
	lea	rdx, OFFSET FLAT:??_C@_1KO@HDGCFKMN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GC@PBCDNLIH@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ@
	call	QWORD PTR __imp__wassert
$LN5908@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 240  :     inline DenseIndex cols(void) const {return m_cols;}

	mov	r9, QWORD PTR [rsi+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 49   :   inline Index size() const { return rows() * cols(); }

	imul	r9, QWORD PTR [rsi+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 404  :     const Index alignedEnd = alignedStart + ((size-alignedStart)/packetSize)*packetSize;

	mov	rax, r9
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r8, rax
	add	r8, r8

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	xor	edi, edi
	mov	ecx, edi
	test	r8, r8
	jle	SHORT $LN4315@setJandH
	movsdx	xmm0, QWORD PTR $T1[rsp+24]
	unpcklpd xmm0, xmm0
	npad	9
$LL4317@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 262  :     inline T *data() { return m_data; }

	mov	rax, QWORD PTR [rsi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [rax+rcx*8], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	add	rcx, 2
	cmp	rcx, r8
	jl	SHORT $LL4317@setJandH
$LN4315@setJandH:

; 409  :     {
; 410  :       dst.template copyPacket<Derived2, dstAlignment, srcAlignment>(index, src);
; 411  :     }
; 412  : 
; 413  :     unaligned_assign_impl<>::run(src,dst,alignedEnd,size);

	mov	rdx, rsi
	lea	rcx, QWORD PTR $T1[rsp]
	call	??$run@V?$CwiseNullaryOp@U?$scalar_constant_op@N@internal@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@@?$unaligned_assign_impl@$0A@@internal@Eigen@@SAXAEBV?$CwiseNullaryOp@U?$scalar_constant_op@N@internal@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@2@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@_J2@Z ; Eigen::internal::unaligned_assign_impl<0>::run<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>,Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::Matrix<double,-1,-1,0,-1,-1> >
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 207  : 	for (size_t i = 0; i < size_i; ++i){

	mov	r14, rdi
	cmp	QWORD PTR [r13], rdi
	jbe	$LN10@setJandH
	npad	6
$LL12@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 394  :       eigen_assert(index >= 0 && index < size());

	test	r14, r14
	js	SHORT $LN4391@setJandH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 240  :     inline DenseIndex cols(void) const {return m_cols;}

	mov	rax, QWORD PTR [r13+216]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 49   :   inline Index size() const { return rows() * cols(); }

	imul	rax, QWORD PTR [r13+208]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 394  :       eigen_assert(index >= 0 && index < size());

	cmp	r14, rax
	jl	SHORT $LN4392@setJandH
$LN4391@setJandH:
	mov	r8d, 394				; 0000018aH
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	call	QWORD PTR __imp__wassert
$LN4392@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 262  :     inline T *data() { return m_data; }

	mov	rax, QWORD PTR [r13+200]
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 208  : 		double res_i = d(i);

	movsdx	xmm10, QWORD PTR [rax+r14*8]

; 209  : 
; 210  : 		for (size_t l = 0; l < size_j; ++l)

	cmp	QWORD PTR [r13+8], 0
	jbe	$LN7@setJandH
	npad	5
$LL9@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 336  :       eigen_assert(row >= 0 && row < rows()

	test	r14, r14
	js	SHORT $LN4419@setJandH
	cmp	r14, QWORD PTR [r13+88]
	jge	SHORT $LN4419@setJandH
	test	rdi, rdi
	js	SHORT $LN4419@setJandH
	cmp	rdi, QWORD PTR [r13+96]
	jl	SHORT $LN4420@setJandH
$LN4419@setJandH:
	mov	r8d, 337				; 00000151H
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GK@FICMDKNL@?$AAr?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw?$AA?5?$AA?$DM?$AA?5?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AA?5@
	call	QWORD PTR __imp__wassert
$LN4420@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 262  :     inline T *data() { return m_data; }

	mov	r15, QWORD PTR [r13+80]

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rsi, QWORD PTR [r13+88]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];

	imul	rsi, rdi
	add	rsi, r14
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 378  :       eigen_assert(index >= 0 && index < size());

	test	rdi, rdi
	js	SHORT $LN4453@setJandH
	cmp	rdi, r12
	jl	SHORT $LN4454@setJandH
$LN4453@setJandH:
	mov	r8d, 378				; 0000017aH
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	call	QWORD PTR __imp__wassert
$LN4454@setJandH:
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 211  : 			res_i -= A(i, l) * z[l];

	mov	rax, QWORD PTR z$[rbp-256]
	movsdx	xmm0, QWORD PTR [rax+rdi*8]
	mulsd	xmm0, QWORD PTR [r15+rsi*8]
	subsd	xmm10, xmm0

; 209  : 
; 210  : 		for (size_t l = 0; l < size_j; ++l)

	inc	rdi
	cmp	rdi, QWORD PTR [r13+8]
	jb	SHORT $LL9@setJandH
	lea	rsi, QWORD PTR [r13+104]
$LN7@setJandH:

; 212  : 
; 213  : 		for (size_t j = 0; j < size_j; ++j){

	xor	edi, edi
	mov	r15d, edi
	cmp	QWORD PTR [r13+8], rdi
	jbe	$LN11@setJandH
	mulsd	xmm10, xmm11
	npad	8
$LL6@setJandH:

; 214  : 			
; 215  : 			double A_ij   = getA_ij(i, j);

	mov	r8, r15
	mov	rdx, r14
	mov	rcx, r13
	call	?getA_ij@Tikhonov2D@@AEBAN_K0@Z		; Tikhonov2D::getA_ij
	movaps	xmm9, xmm0

; 216  : 			double Adv_ij = getAdv_ij(i, j);

	mov	r8, r15
	mov	rdx, r14
	mov	rcx, r13
	call	?getAdv_ij@Tikhonov2D@@AEBAN_K0@Z	; Tikhonov2D::getAdv_ij
	movaps	xmm8, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 336  :       eigen_assert(row >= 0 && row < rows()

	test	r14, r14
	js	SHORT $LN4481@setJandH
	cmp	r14, QWORD PTR [rsi+8]
	jge	SHORT $LN4481@setJandH
	test	r15, r15
	js	SHORT $LN4481@setJandH
	cmp	r15, QWORD PTR [rsi+16]
	jl	SHORT $LN4482@setJandH
$LN4481@setJandH:
	mov	r8d, 337				; 00000151H
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GK@FICMDKNL@?$AAr?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw?$AA?5?$AA?$DM?$AA?5?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AA?5@
	call	QWORD PTR __imp__wassert
$LN4482@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 262  :     inline T *data() { return m_data; }

	mov	rcx, QWORD PTR [rsi]

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rax, QWORD PTR [rsi+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];

	imul	rax, r15
	add	rax, r14
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 217  : 			Aij(i, j) = A_ij;

	movsdx	QWORD PTR [rcx+rax*8], xmm9
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 378  :       eigen_assert(index >= 0 && index < size());

	lea	rdi, QWORD PTR [r13+272]
	test	r15, r15
	js	SHORT $LN4515@setJandH
	cmp	r15, QWORD PTR [rdi+8]
	jl	SHORT $LN4516@setJandH
$LN4515@setJandH:
	mov	r8d, 378				; 0000017aH
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	call	QWORD PTR __imp__wassert
$LN4516@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 334  :     inline T *data() { return m_data; }

	mov	rsi, QWORD PTR [rdi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 378  :       eigen_assert(index >= 0 && index < size());

	test	r15, r15
	js	SHORT $LN4543@setJandH
	cmp	r15, r12
	jl	SHORT $LN4544@setJandH
$LN4543@setJandH:
	mov	r8d, 378				; 0000017aH
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	call	QWORD PTR __imp__wassert
$LN4544@setJandH:
	test	r14, r14
	js	SHORT $LN4571@setJandH
	cmp	r14, QWORD PTR [r13+248]
	jl	SHORT $LN4572@setJandH
$LN4571@setJandH:
	mov	r8d, 378				; 0000017aH
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	call	QWORD PTR __imp__wassert
$LN4572@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 334  :     inline T *data() { return m_data; }

	mov	rdi, QWORD PTR [r13+240]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 378  :       eigen_assert(index >= 0 && index < size());

	test	r14, r14
	js	SHORT $LN4599@setJandH
	cmp	r14, QWORD PTR [r13+248]
	jl	SHORT $LN4600@setJandH
$LN4599@setJandH:
	mov	r8d, 378				; 0000017aH
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	call	QWORD PTR __imp__wassert
$LN4600@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 334  :     inline T *data() { return m_data; }

	mov	rax, QWORD PTR [r13+240]
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 219  : 			Jf[j] += -2.0 * res_i * A_ij   * z[j] / sigma[i] / sigma[i];

	movaps	xmm1, xmm10
	mulsd	xmm1, xmm9
	mov	rcx, QWORD PTR z$[rbp-256]
	mulsd	xmm1, QWORD PTR [rcx+r15*8]
	divsd	xmm1, QWORD PTR [rdi+r14*8]
	divsd	xmm1, QWORD PTR [rax+r14*8]
	movsdx	xmm0, QWORD PTR [rsi+r15*8]
	subsd	xmm0, xmm1
	movsdx	QWORD PTR [rsi+r15*8], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 378  :       eigen_assert(index >= 0 && index < size());

	lea	rdi, QWORD PTR [r13+288]
	test	r15, r15
	js	SHORT $LN4627@setJandH
	cmp	r15, QWORD PTR [rdi+8]
	jl	SHORT $LN4628@setJandH
$LN4627@setJandH:
	mov	r8d, 378				; 0000017aH
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	call	QWORD PTR __imp__wassert
$LN4628@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 334  :     inline T *data() { return m_data; }

	mov	rsi, QWORD PTR [rdi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 378  :       eigen_assert(index >= 0 && index < size());

	test	r15, r15
	js	SHORT $LN4655@setJandH
	cmp	r15, r12
	jl	SHORT $LN4656@setJandH
$LN4655@setJandH:
	mov	r8d, 378				; 0000017aH
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	call	QWORD PTR __imp__wassert
$LN4656@setJandH:
	test	r14, r14
	js	SHORT $LN4683@setJandH
	cmp	r14, QWORD PTR [r13+248]
	jl	SHORT $LN4684@setJandH
$LN4683@setJandH:
	mov	r8d, 378				; 0000017aH
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	call	QWORD PTR __imp__wassert
$LN4684@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 334  :     inline T *data() { return m_data; }

	mov	rdi, QWORD PTR [r13+240]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 378  :       eigen_assert(index >= 0 && index < size());

	test	r14, r14
	js	SHORT $LN4711@setJandH
	cmp	r14, QWORD PTR [r13+248]
	jl	SHORT $LN4712@setJandH
$LN4711@setJandH:
	mov	r8d, 378				; 0000017aH
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	call	QWORD PTR __imp__wassert
$LN4712@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 334  :     inline T *data() { return m_data; }

	mov	rax, QWORD PTR [r13+240]
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 220  : 			Jv[j] += -2.0 * res_i * Adv_ij * z[j] / sigma[i] / sigma[i];

	movaps	xmm1, xmm10
	mulsd	xmm1, xmm8
	mov	rcx, QWORD PTR z$[rbp-256]
	mulsd	xmm1, QWORD PTR [rcx+r15*8]
	divsd	xmm1, QWORD PTR [rdi+r14*8]
	divsd	xmm1, QWORD PTR [rax+r14*8]
	movsdx	xmm0, QWORD PTR [rsi+r15*8]
	subsd	xmm0, xmm1
	movsdx	QWORD PTR [rsi+r15*8], xmm0

; 221  : 
; 222  : 			for (size_t k = 0; k < size_j; ++k){

	xor	edi, edi
	cmp	QWORD PTR [r13+8], rdi
	jbe	$LN5@setJandH
	mulsd	xmm9, xmm11
	mulsd	xmm8, xmm11
	npad	2
$LL3@setJandH:

; 223  : 				double A_ik   = getA_ij(i, k);

	mov	r8, rdi
	mov	rdx, r14
	mov	rcx, r13
	call	?getA_ij@Tikhonov2D@@AEBAN_K0@Z		; Tikhonov2D::getA_ij
	movaps	xmm6, xmm0

; 224  : 				double Adv_ik = getAdv_ij(i, k);

	mov	r8, rdi
	mov	rdx, r14
	mov	rcx, r13
	call	?getAdv_ij@Tikhonov2D@@AEBAN_K0@Z	; Tikhonov2D::getAdv_ij
	movaps	xmm7, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 336  :       eigen_assert(row >= 0 && row < rows()

	test	r15, r15
	js	SHORT $LN5912@setJandH
	lea	rsi, QWORD PTR [r13+328]
	cmp	r15, QWORD PTR [rsi+8]
	jge	SHORT $LN4739@setJandH
	test	rdi, rdi
	js	SHORT $LN4739@setJandH
	cmp	rdi, QWORD PTR [rsi+16]
	jl	SHORT $LN4740@setJandH
	jmp	SHORT $LN4739@setJandH
$LN5912@setJandH:
	mov	rsi, QWORD PTR other$1$[rbp-256]
$LN4739@setJandH:
	mov	r8d, 337				; 00000151H
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GK@FICMDKNL@?$AAr?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw?$AA?5?$AA?$DM?$AA?5?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AA?5@
	call	QWORD PTR __imp__wassert
$LN4740@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 262  :     inline T *data() { return m_data; }

	mov	r13, QWORD PTR [rsi]

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	r12, QWORD PTR [rsi+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];

	imul	r12, rdi
	add	r12, r15
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 378  :       eigen_assert(index >= 0 && index < size());

	test	r15, r15
	js	SHORT $LN4773@setJandH
	mov	rax, QWORD PTR othersize$1$[rsp]
	cmp	r15, rax
	jl	SHORT $LN4774@setJandH
$LN4773@setJandH:
	mov	r8d, 378				; 0000017aH
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	call	QWORD PTR __imp__wassert
	mov	rax, QWORD PTR othersize$1$[rsp]
$LN4774@setJandH:
	test	rdi, rdi
	js	SHORT $LN4801@setJandH
	cmp	rdi, rax
	jl	SHORT $LN4802@setJandH
$LN4801@setJandH:
	mov	r8d, 378				; 0000017aH
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	call	QWORD PTR __imp__wassert
$LN4802@setJandH:
	test	r14, r14
	js	SHORT $LN4829@setJandH
	mov	rax, QWORD PTR this$GSCopy$1$[rsp]
	cmp	r14, QWORD PTR [rax+248]
	jl	SHORT $LN4830@setJandH
$LN4829@setJandH:
	mov	r8d, 378				; 0000017aH
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	call	QWORD PTR __imp__wassert
	mov	rax, QWORD PTR this$GSCopy$1$[rsp]
$LN4830@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 334  :     inline T *data() { return m_data; }

	mov	rsi, QWORD PTR [rax+240]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 378  :       eigen_assert(index >= 0 && index < size());

	test	r14, r14
	js	SHORT $LN4857@setJandH
	cmp	r14, QWORD PTR [rax+248]
	jl	SHORT $LN4858@setJandH
$LN4857@setJandH:
	mov	r8d, 378				; 0000017aH
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	call	QWORD PTR __imp__wassert
	mov	rax, QWORD PTR this$GSCopy$1$[rsp]
$LN4858@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 334  :     inline T *data() { return m_data; }

	mov	rax, QWORD PTR [rax+240]
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 226  : 				Hff(j, k) += 2.0 * A_ij   * z[j] * A_ik   * z[k] / sigma[i] / sigma[i];

	movaps	xmm0, xmm9
	mov	rcx, QWORD PTR z$[rbp-256]
	mulsd	xmm0, QWORD PTR [rcx+r15*8]
	mulsd	xmm0, xmm6
	mulsd	xmm0, QWORD PTR [rcx+rdi*8]
	divsd	xmm0, QWORD PTR [rsi+r14*8]
	divsd	xmm0, QWORD PTR [rax+r14*8]
	addsd	xmm0, QWORD PTR [r13+r12*8]
	movsdx	QWORD PTR [r13+r12*8], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 336  :       eigen_assert(row >= 0 && row < rows()

	test	r15, r15
	js	SHORT $LN4885@setJandH
	cmp	r15, QWORD PTR [rbx+8]
	jge	SHORT $LN4885@setJandH
	test	rdi, rdi
	js	SHORT $LN4885@setJandH
	cmp	rdi, QWORD PTR [rbx+16]
	jl	SHORT $LN4886@setJandH
$LN4885@setJandH:
	mov	r8d, 337				; 00000151H
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GK@FICMDKNL@?$AAr?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw?$AA?5?$AA?$DM?$AA?5?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AA?5@
	call	QWORD PTR __imp__wassert
$LN4886@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 262  :     inline T *data() { return m_data; }

	mov	r13, QWORD PTR [rbx]

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	r12, QWORD PTR [rbx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];

	imul	r12, rdi
	add	r12, r15
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 378  :       eigen_assert(index >= 0 && index < size());

	test	r15, r15
	js	SHORT $LN4919@setJandH
	mov	rax, QWORD PTR othersize$1$[rsp]
	cmp	r15, rax
	jl	SHORT $LN4920@setJandH
$LN4919@setJandH:
	mov	r8d, 378				; 0000017aH
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	call	QWORD PTR __imp__wassert
	mov	rax, QWORD PTR othersize$1$[rsp]
$LN4920@setJandH:
	test	rdi, rdi
	js	SHORT $LN4947@setJandH
	cmp	rdi, rax
	jl	SHORT $LN4948@setJandH
$LN4947@setJandH:
	mov	r8d, 378				; 0000017aH
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	call	QWORD PTR __imp__wassert
$LN4948@setJandH:
	test	r14, r14
	js	SHORT $LN4975@setJandH
	mov	rax, QWORD PTR this$GSCopy$1$[rsp]
	cmp	r14, QWORD PTR [rax+248]
	jl	SHORT $LN4976@setJandH
$LN4975@setJandH:
	mov	r8d, 378				; 0000017aH
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	call	QWORD PTR __imp__wassert
	mov	rax, QWORD PTR this$GSCopy$1$[rsp]
$LN4976@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 334  :     inline T *data() { return m_data; }

	mov	rsi, QWORD PTR [rax+240]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 378  :       eigen_assert(index >= 0 && index < size());

	test	r14, r14
	js	SHORT $LN5003@setJandH
	cmp	r14, QWORD PTR [rax+248]
	jl	SHORT $LN5004@setJandH
$LN5003@setJandH:
	mov	r8d, 378				; 0000017aH
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	call	QWORD PTR __imp__wassert
	mov	rax, QWORD PTR this$GSCopy$1$[rsp]
$LN5004@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 334  :     inline T *data() { return m_data; }

	mov	rax, QWORD PTR [rax+240]
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 227  : 				Hvf(j, k) += 2.0 * Adv_ij * z[j] * A_ik   * z[k] / sigma[i] / sigma[i];

	movaps	xmm0, xmm8
	mov	rcx, QWORD PTR z$[rbp-256]
	mulsd	xmm0, QWORD PTR [rcx+r15*8]
	mulsd	xmm0, xmm6
	mulsd	xmm0, QWORD PTR [rcx+rdi*8]
	divsd	xmm0, QWORD PTR [rsi+r14*8]
	divsd	xmm0, QWORD PTR [rax+r14*8]
	addsd	xmm0, QWORD PTR [r13+r12*8]
	movsdx	QWORD PTR [r13+r12*8], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 336  :       eigen_assert(row >= 0 && row < rows()

	mov	rsi, QWORD PTR other$1$[rbp-256]
	test	r15, r15
	js	SHORT $LN5031@setJandH
	cmp	r15, QWORD PTR [rsi+8]
	jge	SHORT $LN5031@setJandH
	test	rdi, rdi
	js	SHORT $LN5031@setJandH
	cmp	rdi, QWORD PTR [rsi+16]
	jl	SHORT $LN5032@setJandH
$LN5031@setJandH:
	mov	r8d, 337				; 00000151H
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GK@FICMDKNL@?$AAr?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw?$AA?5?$AA?$DM?$AA?5?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AA?5@
	call	QWORD PTR __imp__wassert
$LN5032@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 262  :     inline T *data() { return m_data; }

	mov	r13, QWORD PTR [rsi]

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	r12, QWORD PTR [rsi+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];

	imul	r12, rdi
	add	r12, r15
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 378  :       eigen_assert(index >= 0 && index < size());

	test	r15, r15
	js	SHORT $LN5065@setJandH
	mov	rax, QWORD PTR othersize$1$[rsp]
	cmp	r15, rax
	jl	SHORT $LN5066@setJandH
$LN5065@setJandH:
	mov	r8d, 378				; 0000017aH
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	call	QWORD PTR __imp__wassert
	mov	rax, QWORD PTR othersize$1$[rsp]
$LN5066@setJandH:
	test	rdi, rdi
	js	SHORT $LN5093@setJandH
	cmp	rdi, rax
	jl	SHORT $LN5094@setJandH
$LN5093@setJandH:
	mov	r8d, 378				; 0000017aH
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	call	QWORD PTR __imp__wassert
$LN5094@setJandH:
	test	r14, r14
	js	SHORT $LN5121@setJandH
	mov	rax, QWORD PTR this$GSCopy$1$[rsp]
	cmp	r14, QWORD PTR [rax+248]
	jl	SHORT $LN5122@setJandH
$LN5121@setJandH:
	mov	r8d, 378				; 0000017aH
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	call	QWORD PTR __imp__wassert
	mov	rax, QWORD PTR this$GSCopy$1$[rsp]
$LN5122@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 334  :     inline T *data() { return m_data; }

	mov	rsi, QWORD PTR [rax+240]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 378  :       eigen_assert(index >= 0 && index < size());

	test	r14, r14
	js	SHORT $LN5149@setJandH
	cmp	r14, QWORD PTR [rax+248]
	jl	SHORT $LN5150@setJandH
$LN5149@setJandH:
	mov	r8d, 378				; 0000017aH
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	call	QWORD PTR __imp__wassert
	mov	rax, QWORD PTR this$GSCopy$1$[rsp]
$LN5150@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 334  :     inline T *data() { return m_data; }

	mov	rax, QWORD PTR [rax+240]
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 228  : 				Hvv(j, k) += 2.0 * Adv_ij * z[j] * Adv_ik * z[k] / sigma[i] / sigma[i];

	movaps	xmm0, xmm8
	mov	rcx, QWORD PTR z$[rbp-256]
	mulsd	xmm0, QWORD PTR [rcx+r15*8]
	mulsd	xmm0, xmm7
	mulsd	xmm0, QWORD PTR [rcx+rdi*8]
	divsd	xmm0, QWORD PTR [rsi+r14*8]
	divsd	xmm0, QWORD PTR [rax+r14*8]
	addsd	xmm0, QWORD PTR [r13+r12*8]
	movsdx	QWORD PTR [r13+r12*8], xmm0

; 221  : 
; 222  : 			for (size_t k = 0; k < size_j; ++k){

	inc	rdi
	mov	r13, QWORD PTR this$GSCopy$1$[rsp]
	cmp	rdi, QWORD PTR [r13+8]
	jb	$LL3@setJandH
	mov	r12, QWORD PTR othersize$1$[rsp]
$LN5@setJandH:

; 212  : 
; 213  : 		for (size_t j = 0; j < size_j; ++j){

	inc	r15
	cmp	r15, QWORD PTR [r13+8]
	lea	rsi, QWORD PTR [r13+104]
	jb	$LL6@setJandH
	xor	edi, edi
$LN11@setJandH:

; 207  : 	for (size_t i = 0; i < size_i; ++i){

	inc	r14
	cmp	r14, QWORD PTR [r13]
	lea	rsi, QWORD PTR [r13+104]
	jb	$LL12@setJandH
	lea	rsi, QWORD PTR [r13+104]
$LN10@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 240  :     inline DenseIndex cols(void) const {return m_cols;}

	mov	rsi, QWORD PTR [rsi+16]

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	r14, QWORD PTR [r13+112]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	mov	r12, 9223372036854775807		; 7fffffffffffffffH
	test	r14, r14
	je	SHORT $LN5952@setJandH
	test	rsi, rsi
	je	SHORT $LN5215@setJandH
	mov	rax, r12
	cdq
	idiv	rsi
	cmp	r14, rax
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN5215@setJandH

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN5215@setJandH:

; 157  :     }
; 158  : 
; 159  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
; 160  :     {
; 161  :       return m_storage.data()[index];
; 162  :     }
; 163  : 
; 164  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
; 165  :     {
; 166  :       if(Flags & RowMajorBit)
; 167  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 168  :       else // column-major
; 169  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 170  :     }
; 171  : 
; 172  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
; 173  :     {
; 174  :       return m_storage.data()[index];
; 175  :     }
; 176  : 
; 177  :     /** \internal */
; 178  :     template<int LoadMode>
; 179  :     EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const
; 180  :     {
; 181  :       return internal::ploadt<PacketScalar, LoadMode>
; 182  :                (m_storage.data() + (Flags & RowMajorBit
; 183  :                                    ? colId + rowId * m_storage.cols()
; 184  :                                    : rowId + colId * m_storage.rows()));
; 185  :     }
; 186  : 
; 187  :     /** \internal */
; 188  :     template<int LoadMode>
; 189  :     EIGEN_STRONG_INLINE PacketScalar packet(Index index) const
; 190  :     {
; 191  :       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);
; 192  :     }
; 193  : 
; 194  :     /** \internal */
; 195  :     template<int StoreMode>
; 196  :     EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)
; 197  :     {
; 198  :       internal::pstoret<Scalar, PacketScalar, StoreMode>
; 199  :               (m_storage.data() + (Flags & RowMajorBit
; 200  :                                    ? colId + rowId * m_storage.cols()
; 201  :                                    : rowId + colId * m_storage.rows()), val);
; 202  :     }
; 203  : 
; 204  :     /** \internal */
; 205  :     template<int StoreMode>
; 206  :     EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
; 207  :     {
; 208  :       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
; 209  :     }
; 210  : 
; 211  :     /** \returns a const pointer to the data array of this matrix */
; 212  :     EIGEN_STRONG_INLINE const Scalar *data() const
; 213  :     { return m_storage.data(); }
; 214  : 
; 215  :     /** \returns a pointer to the data array of this matrix */
; 216  :     EIGEN_STRONG_INLINE Scalar *data()
; 217  :     { return m_storage.data(); }
; 218  : 
; 219  :     /** Resizes \c *this to a \a rows x \a cols matrix.
; 220  :       *
; 221  :       * This method is intended for dynamic-size matrices, although it is legal to call it on any
; 222  :       * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
; 223  :       * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
; 224  :       *
; 225  :       * If the current number of coefficients of \c *this exactly matches the
; 226  :       * product \a rows * \a cols, then no memory allocation is performed and
; 227  :       * the current values are left unchanged. In all other cases, including
; 228  :       * shrinking, the data is reallocated and all previous values are lost.
; 229  :       *
; 230  :       * Example: \include Matrix_resize_int_int.cpp
; 231  :       * Output: \verbinclude Matrix_resize_int_int.out
; 232  :       *
; 233  :       * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
; 234  :       */
; 235  :     EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)
; 236  :     {
; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	r14, r14
$LN5952@setJandH:
	js	SHORT $LN5285@setJandH
	test	rsi, rsi
	jns	SHORT $LN5286@setJandH
$LN5285@setJandH:
	mov	r8d, 241				; 000000f1H
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	call	QWORD PTR __imp__wassert
$LN5286@setJandH:

; 44   :                : (rows > max_index / cols);

	test	r14, r14
	je	SHORT $LN5293@setJandH
	test	rsi, rsi
	je	SHORT $LN5293@setJandH
	mov	rax, r12
	cdq
	idiv	rsi
	cmp	r14, rax
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN5287@setJandH

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN5287@setJandH:

; 44   :                : (rows > max_index / cols);

	test	rsi, rsi
	je	SHORT $LN5293@setJandH
	mov	rax, r12
	cdq
	idiv	rsi
	cmp	r14, rax
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN5293@setJandH

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN5293@setJandH:

; 238  :                    && EIGEN_IMPLIES(ColsAtCompileTime!=Dynamic,nbCols==ColsAtCompileTime)
; 239  :                    && EIGEN_IMPLIES(RowsAtCompileTime==Dynamic && MaxRowsAtCompileTime!=Dynamic,nbRows<=MaxRowsAtCompileTime)
; 240  :                    && EIGEN_IMPLIES(ColsAtCompileTime==Dynamic && MaxColsAtCompileTime!=Dynamic,nbCols<=MaxColsAtCompileTime)
; 241  :                    && nbRows>=0 && nbCols>=0 && "Invalid sizes when resizing a matrix or array.");
; 242  :       internal::check_rows_cols_for_overflow<MaxSizeAtCompileTime>::run(nbRows, nbCols);
; 243  :       #ifdef EIGEN_INITIALIZE_COEFFS
; 244  :         Index size = nbRows*nbCols;
; 245  :         bool size_changed = size != this->size();
; 246  :         m_storage.resize(size, nbRows, nbCols);
; 247  :         if(size_changed) EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED
; 248  :       #else
; 249  :         internal::check_rows_cols_for_overflow<MaxSizeAtCompileTime>::run(nbRows, nbCols);
; 250  :         m_storage.resize(nbRows*nbCols, nbRows, nbCols);

	mov	rdx, rsi
	imul	rdx, r14
	mov	r9, rsi
	mov	r8, r14
	lea	rcx, QWORD PTR [r13+80]
	call	?resize@?$DenseStorage@N$0?0$0?0$0?0$0A@@Eigen@@QEAAX_J00@Z ; Eigen::DenseStorage<double,-1,-1,-1,0>::resize
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rax, QWORD PTR [r13+88]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	cmp	rax, QWORD PTR [r13+112]
	jne	SHORT $LN5304@setJandH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 240  :     inline DenseIndex cols(void) const {return m_cols;}

	mov	rax, QWORD PTR [r13+96]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	cmp	rax, QWORD PTR [r13+120]
	je	SHORT $LN5305@setJandH
$LN5304@setJandH:
	mov	r8d, 498				; 000001f2H
	lea	rdx, OFFSET FLAT:??_C@_1KO@HDGCFKMN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GC@PBCDNLIH@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ@
	call	QWORD PTR __imp__wassert
$LN5305@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 240  :     inline DenseIndex cols(void) const {return m_cols;}

	mov	r9, QWORD PTR [r13+96]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 49   :   inline Index size() const { return rows() * cols(); }

	imul	r9, QWORD PTR [r13+88]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 404  :     const Index alignedEnd = alignedStart + ((size-alignedStart)/packetSize)*packetSize;

	mov	rax, r9
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r8, rax
	add	r8, r8

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	test	r8, r8
	jle	SHORT $LN5342@setJandH
	xor	ecx, ecx
	npad	8
$LL5344@setJandH:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 261  :     inline const T *data() const { return m_data; }

	mov	rax, QWORD PTR [r13+104]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 220  : template<> EIGEN_STRONG_INLINE Packet2d pload<Packet2d>(const double*  from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_pd(from); }

	movaps	xmm0, XMMWORD PTR [rax+rcx*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 262  :     inline T *data() { return m_data; }

	mov	rax, QWORD PTR [r13+80]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [rax+rcx*8], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	add	rcx, 2
	cmp	rcx, r8
	jl	SHORT $LL5344@setJandH
$LN5342@setJandH:

; 409  :     {
; 410  :       dst.template copyPacket<Derived2, dstAlignment, srcAlignment>(index, src);
; 411  :     }
; 412  : 
; 413  :     unaligned_assign_impl<>::run(src,dst,alignedEnd,size);

	lea	rdx, QWORD PTR [r13+80]
	lea	rcx, QWORD PTR [r13+104]
	call	??$run@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V12@@?$unaligned_assign_impl@$0A@@internal@Eigen@@SAXAEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@AEAV32@_J2@Z ; Eigen::internal::unaligned_assign_impl<0>::run<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::Matrix<double,-1,-1,0,-1,-1> >
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 234  : 	J.block(     0, 0, size_j, 1) = Jf;

	mov	rax, QWORD PTR [r13+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\plugins\blockmethods.h

; 58   :   return Block<Derived>(derived(), startRow, startCol, blockRows, blockCols);

	mov	QWORD PTR [rsp+32], rax
	xor	r8d, r8d
	lea	rdx, QWORD PTR [r13+256]
	lea	rcx, QWORD PTR $T14[rsp]
	call	??0?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@QEAA@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@_J111@Z ; Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 313  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rax, QWORD PTR [r13+280]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	cmp	QWORD PTR $T14[rsp+8], rax
	jne	SHORT $LN5430@setJandH
	cmp	QWORD PTR $T14[rsp+16], 1
	je	SHORT $LN5431@setJandH
$LN5430@setJandH:
	mov	r8d, 498				; 000001f2H
	lea	rdx, OFFSET FLAT:??_C@_1KO@HDGCFKMN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GC@PBCDNLIH@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ@
	call	QWORD PTR __imp__wassert
$LN5431@setJandH:

; 499  :   internal::assign_impl<Derived, OtherDerived, int(SameType) ? int(internal::assign_traits<Derived, OtherDerived>::Traversal)
; 500  :                                                        : int(InvalidTraversal)>::run(derived(),other.derived());

	lea	rdx, QWORD PTR [r13+272]
	lea	rcx, QWORD PTR $T14[rsp]
	call	?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z ; Eigen::internal::assign_impl<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,Eigen::Matrix<double,-1,1,0,-1,1>,4,0,0>::run
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 235  : 	J.block(size_j, 0, size_j, 1) = Jv;

	mov	r8, QWORD PTR [r13+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\plugins\blockmethods.h

; 58   :   return Block<Derived>(derived(), startRow, startCol, blockRows, blockCols);

	mov	QWORD PTR [rsp+32], r8
	lea	rdx, QWORD PTR [r13+256]
	lea	rcx, QWORD PTR $T13[rsp]
	call	??0?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@QEAA@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@_J111@Z ; Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 313  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rax, QWORD PTR [r13+296]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	cmp	QWORD PTR $T13[rsp+8], rax
	jne	SHORT $LN5488@setJandH
	cmp	QWORD PTR $T13[rsp+16], 1
	je	SHORT $LN5489@setJandH
$LN5488@setJandH:
	mov	r8d, 498				; 000001f2H
	lea	rdx, OFFSET FLAT:??_C@_1KO@HDGCFKMN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GC@PBCDNLIH@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ@
	call	QWORD PTR __imp__wassert
$LN5489@setJandH:

; 499  :   internal::assign_impl<Derived, OtherDerived, int(SameType) ? int(internal::assign_traits<Derived, OtherDerived>::Traversal)
; 500  :                                                        : int(InvalidTraversal)>::run(derived(),other.derived());

	lea	rdx, QWORD PTR [r13+288]
	lea	rcx, QWORD PTR $T13[rsp]
	call	?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z ; Eigen::internal::assign_impl<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,Eigen::Matrix<double,-1,1,0,-1,1>,4,0,0>::run
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 236  : 	H.block(     0,      0, size_j, size_j) = Hff;

	mov	rax, QWORD PTR [r13+8]
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	xor	r8d, r8d
	lea	rdx, QWORD PTR $T12[rsp]
	lea	rcx, QWORD PTR [r13+304]
	call	?block@?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAA?AV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@2@_J000@Z ; Eigen::DenseBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::block
	mov	rdi, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h

; 64   :     T value() const { return m_value; }

	mov	rcx, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	cmp	rcx, QWORD PTR [r13+336]
	jne	SHORT $LN5542@setJandH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h

; 64   :     T value() const { return m_value; }

	mov	rcx, QWORD PTR [rax+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	cmp	rcx, QWORD PTR [r13+344]
	je	SHORT $LN5543@setJandH
$LN5542@setJandH:
	mov	r8d, 498				; 000001f2H
	lea	rdx, OFFSET FLAT:??_C@_1KO@HDGCFKMN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GC@PBCDNLIH@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ@
	call	QWORD PTR __imp__wassert
$LN5543@setJandH:

; 499  :   internal::assign_impl<Derived, OtherDerived, int(SameType) ? int(internal::assign_traits<Derived, OtherDerived>::Traversal)
; 500  :                                                        : int(InvalidTraversal)>::run(derived(),other.derived());

	lea	rdx, QWORD PTR [r13+328]
	mov	rcx, rdi
	call	?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@Z ; Eigen::internal::assign_impl<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,Eigen::Matrix<double,-1,-1,0,-1,-1>,4,0,0>::run
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 237  : 	H.block(     0, size_j, size_j, size_j) = Hvf;

	mov	r9, QWORD PTR [r13+8]
	mov	QWORD PTR [rsp+40], r9
	mov	QWORD PTR [rsp+32], r9
	xor	r8d, r8d
	lea	rdx, QWORD PTR $T11[rsp]
	lea	rcx, QWORD PTR [r13+304]
	call	?block@?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAA?AV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@2@_J000@Z ; Eigen::DenseBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::block
	mov	rdi, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h

; 64   :     T value() const { return m_value; }

	mov	rcx, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	cmp	rcx, QWORD PTR [rbx+8]
	jne	SHORT $LN5596@setJandH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h

; 64   :     T value() const { return m_value; }

	mov	rcx, QWORD PTR [rax+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	cmp	rcx, QWORD PTR [rbx+16]
	je	SHORT $LN5597@setJandH
$LN5596@setJandH:
	mov	r8d, 498				; 000001f2H
	lea	rdx, OFFSET FLAT:??_C@_1KO@HDGCFKMN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GC@PBCDNLIH@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ@
	call	QWORD PTR __imp__wassert
$LN5597@setJandH:

; 499  :   internal::assign_impl<Derived, OtherDerived, int(SameType) ? int(internal::assign_traits<Derived, OtherDerived>::Traversal)
; 500  :                                                        : int(InvalidTraversal)>::run(derived(),other.derived());

	mov	rdx, rbx
	mov	rcx, rdi
	call	?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@Z ; Eigen::internal::assign_impl<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,Eigen::Matrix<double,-1,-1,0,-1,-1>,4,0,0>::run
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h

; 65   :     inline Transpose(MatrixType& a_matrix) : m_matrix(a_matrix) {}

	mov	QWORD PTR $T25[rbp-256], rbx
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 238  : 	H.block(size_j,      0, size_j, size_j) = Hvf.transpose();

	mov	r8, QWORD PTR [r13+8]
	mov	QWORD PTR [rsp+40], r8
	mov	QWORD PTR [rsp+32], r8
	xor	r9d, r9d
	lea	rdx, QWORD PTR $T10[rsp]
	lea	rcx, QWORD PTR [r13+304]
	call	?block@?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAA?AV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@2@_J000@Z ; Eigen::DenseBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::block
	mov	rdi, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h

; 64   :     T value() const { return m_value; }

	mov	rcx, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	cmp	rcx, QWORD PTR [rbx+16]
	jne	SHORT $LN5656@setJandH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h

; 64   :     T value() const { return m_value; }

	mov	rcx, QWORD PTR [rax+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	cmp	rcx, QWORD PTR [rbx+8]
	je	SHORT $LN5657@setJandH
$LN5656@setJandH:
	mov	r8d, 498				; 000001f2H
	lea	rdx, OFFSET FLAT:??_C@_1KO@HDGCFKMN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GC@PBCDNLIH@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ@
	call	QWORD PTR __imp__wassert
$LN5657@setJandH:

; 499  :   internal::assign_impl<Derived, OtherDerived, int(SameType) ? int(internal::assign_traits<Derived, OtherDerived>::Traversal)
; 500  :                                                        : int(InvalidTraversal)>::run(derived(),other.derived());

	lea	rdx, QWORD PTR $T25[rbp-256]
	mov	rcx, rdi
	call	?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@$0A@$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Z ; Eigen::internal::assign_impl<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> >,0,0,0>::run

; 501  : #ifndef EIGEN_NO_DEBUG
; 502  :   checkTransposeAliasing(other.derived());

	lea	rdx, QWORD PTR $T25[rbp-256]
	mov	rcx, rdi
	call	??$checkTransposeAliasing@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@?$DenseBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@IEBAXAEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@1@@Z ; Eigen::DenseBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::checkTransposeAliasing<Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> > >
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 239  : 	H.block(size_j, size_j, size_j, size_j) = Hvv;

	mov	r8, QWORD PTR [r13+8]
	mov	QWORD PTR [rsp+40], r8
	mov	QWORD PTR [rsp+32], r8
	mov	r9, r8
	lea	rdx, QWORD PTR $T9[rsp]
	lea	rcx, QWORD PTR [r13+304]
	call	?block@?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAA?AV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@2@_J000@Z ; Eigen::DenseBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::block
	mov	rbx, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h

; 64   :     T value() const { return m_value; }

	mov	r9, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	cmp	r9, QWORD PTR [r13+360]
	jne	SHORT $LN5714@setJandH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h

; 64   :     T value() const { return m_value; }

	mov	r9, QWORD PTR [rax+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	cmp	r9, QWORD PTR [r13+368]
	je	SHORT $LN5715@setJandH
$LN5714@setJandH:
	mov	r8d, 498				; 000001f2H
	lea	rdx, OFFSET FLAT:??_C@_1KO@HDGCFKMN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GC@PBCDNLIH@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ@
	call	QWORD PTR __imp__wassert
$LN5715@setJandH:

; 499  :   internal::assign_impl<Derived, OtherDerived, int(SameType) ? int(internal::assign_traits<Derived, OtherDerived>::Traversal)
; 500  :                                                        : int(InvalidTraversal)>::run(derived(),other.derived());

	lea	rdx, QWORD PTR [r13+352]
	mov	rcx, rbx
	call	?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@Z ; Eigen::internal::assign_impl<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,Eigen::Matrix<double,-1,-1,0,-1,-1>,4,0,0>::run
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR z$[rbp-256]
	call	QWORD PTR __imp_free
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 240  : 	return true;

	mov	al, 1

; 241  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+384]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rdi, QWORD PTR [r11+72]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
$LN5924@setJandH:
?setJandH@Tikhonov2D@@AEAA_NNN@Z ENDP			; Tikhonov2D::setJandH
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$GSCopy$1$ = 48
$T1 = 56
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
$T9 = 56
$T10 = 56
$T11 = 56
$T12 = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
othersize$1$ = 96
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
$T22 = 112
$T23 = 112
$T24 = 112
other$1$ = 144
$T25 = 144
$T26 = 152
other$1$ = 160
$T27 = 168
$T28 = 168
$T29 = 168
$T30 = 168
$T31 = 224
$T32 = 232
$T33 = 256
$T34 = 256
z$ = 256
__$ArrayPad$ = 272
this$ = 432
lambdaSquared0$ = 440
lambdaSquared1$ = 448
?dtor$0@?0??setJandH@Tikhonov2D@@AEAA_NNN@Z@4HA PROC	; `Tikhonov2D::setJandH'::`1'::dtor$0
	lea	rcx, QWORD PTR $T30[rdx]
	jmp	??1?$GeneralProduct@V?$CwiseUnaryOp@U?$scalar_multiple_op@N@internal@Eigen@@$$CBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$04@Eigen@@QEAA@XZ
?dtor$0@?0??setJandH@Tikhonov2D@@AEAA_NNN@Z@4HA ENDP	; `Tikhonov2D::setJandH'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$GSCopy$1$ = 48
$T1 = 56
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
$T9 = 56
$T10 = 56
$T11 = 56
$T12 = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
othersize$1$ = 96
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
$T22 = 112
$T23 = 112
$T24 = 112
other$1$ = 144
$T25 = 144
$T26 = 152
other$1$ = 160
$T27 = 168
$T28 = 168
$T29 = 168
$T30 = 168
$T31 = 224
$T32 = 232
$T33 = 256
$T34 = 256
z$ = 256
__$ArrayPad$ = 272
this$ = 432
lambdaSquared0$ = 440
lambdaSquared1$ = 448
?dtor$1@?0??setJandH@Tikhonov2D@@AEAA_NNN@Z@4HA PROC	; `Tikhonov2D::setJandH'::`1'::dtor$1
	lea	rcx, QWORD PTR $T16[rdx]
	jmp	??1?$GeneralProduct@V?$GeneralProduct@V?$CwiseUnaryOp@U?$scalar_multiple_op@N@internal@Eigen@@$$CBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$04@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$03@Eigen@@QEAA@XZ
?dtor$1@?0??setJandH@Tikhonov2D@@AEAA_NNN@Z@4HA ENDP	; `Tikhonov2D::setJandH'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$GSCopy$1$ = 48
$T1 = 56
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
$T9 = 56
$T10 = 56
$T11 = 56
$T12 = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
othersize$1$ = 96
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
$T22 = 112
$T23 = 112
$T24 = 112
other$1$ = 144
$T25 = 144
$T26 = 152
other$1$ = 160
$T27 = 168
$T28 = 168
$T29 = 168
$T30 = 168
$T31 = 224
$T32 = 232
$T33 = 256
$T34 = 256
z$ = 256
__$ArrayPad$ = 272
this$ = 432
lambdaSquared0$ = 440
lambdaSquared1$ = 448
?dtor$7@?0??setJandH@Tikhonov2D@@AEAA_NNN@Z@4HA PROC	; `Tikhonov2D::setJandH'::`1'::dtor$7
	lea	rcx, QWORD PTR $T34[rdx]
	jmp	??1?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@XZ
?dtor$7@?0??setJandH@Tikhonov2D@@AEAA_NNN@Z@4HA ENDP	; `Tikhonov2D::setJandH'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$GSCopy$1$ = 48
$T1 = 56
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
$T9 = 56
$T10 = 56
$T11 = 56
$T12 = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
othersize$1$ = 96
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
$T22 = 112
$T23 = 112
$T24 = 112
other$1$ = 144
$T25 = 144
$T26 = 152
other$1$ = 160
$T27 = 168
$T28 = 168
$T29 = 168
$T30 = 168
$T31 = 224
$T32 = 232
$T33 = 256
$T34 = 256
z$ = 256
__$ArrayPad$ = 272
this$ = 432
lambdaSquared0$ = 440
lambdaSquared1$ = 448
?dtor$2@?0??setJandH@Tikhonov2D@@AEAA_NNN@Z@4HA PROC	; `Tikhonov2D::setJandH'::`1'::dtor$2
	lea	rcx, QWORD PTR $T29[rdx]
	jmp	??1?$GeneralProduct@V?$CwiseUnaryOp@U?$scalar_multiple_op@N@internal@Eigen@@$$CBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$04@Eigen@@QEAA@XZ
?dtor$2@?0??setJandH@Tikhonov2D@@AEAA_NNN@Z@4HA ENDP	; `Tikhonov2D::setJandH'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$GSCopy$1$ = 48
$T1 = 56
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
$T9 = 56
$T10 = 56
$T11 = 56
$T12 = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
othersize$1$ = 96
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
$T22 = 112
$T23 = 112
$T24 = 112
other$1$ = 144
$T25 = 144
$T26 = 152
other$1$ = 160
$T27 = 168
$T28 = 168
$T29 = 168
$T30 = 168
$T31 = 224
$T32 = 232
$T33 = 256
$T34 = 256
z$ = 256
__$ArrayPad$ = 272
this$ = 432
lambdaSquared0$ = 440
lambdaSquared1$ = 448
?dtor$3@?0??setJandH@Tikhonov2D@@AEAA_NNN@Z@4HA PROC	; `Tikhonov2D::setJandH'::`1'::dtor$3
	lea	rcx, QWORD PTR $T15[rdx]
	jmp	??1?$GeneralProduct@V?$GeneralProduct@V?$CwiseUnaryOp@U?$scalar_multiple_op@N@internal@Eigen@@$$CBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$04@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$03@Eigen@@QEAA@XZ
?dtor$3@?0??setJandH@Tikhonov2D@@AEAA_NNN@Z@4HA ENDP	; `Tikhonov2D::setJandH'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$GSCopy$1$ = 48
$T1 = 56
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
$T9 = 56
$T10 = 56
$T11 = 56
$T12 = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
othersize$1$ = 96
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
$T22 = 112
$T23 = 112
$T24 = 112
other$1$ = 144
$T25 = 144
$T26 = 152
other$1$ = 160
$T27 = 168
$T28 = 168
$T29 = 168
$T30 = 168
$T31 = 224
$T32 = 232
$T33 = 256
$T34 = 256
z$ = 256
__$ArrayPad$ = 272
this$ = 432
lambdaSquared0$ = 440
lambdaSquared1$ = 448
?dtor$8@?0??setJandH@Tikhonov2D@@AEAA_NNN@Z@4HA PROC	; `Tikhonov2D::setJandH'::`1'::dtor$8
	lea	rcx, QWORD PTR $T33[rdx]
	jmp	??1?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@XZ
?dtor$8@?0??setJandH@Tikhonov2D@@AEAA_NNN@Z@4HA ENDP	; `Tikhonov2D::setJandH'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$GSCopy$1$ = 48
$T1 = 56
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
$T9 = 56
$T10 = 56
$T11 = 56
$T12 = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
othersize$1$ = 96
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
$T22 = 112
$T23 = 112
$T24 = 112
other$1$ = 144
$T25 = 144
$T26 = 152
other$1$ = 160
$T27 = 168
$T28 = 168
$T29 = 168
$T30 = 168
$T31 = 224
$T32 = 232
$T33 = 256
$T34 = 256
z$ = 256
__$ArrayPad$ = 272
this$ = 432
lambdaSquared0$ = 440
lambdaSquared1$ = 448
?dtor$4@?0??setJandH@Tikhonov2D@@AEAA_NNN@Z@4HA PROC	; `Tikhonov2D::setJandH'::`1'::dtor$4
	lea	rcx, QWORD PTR $T28[rdx]
	jmp	??1?$GeneralProduct@V?$CwiseUnaryOp@U?$scalar_multiple_op@N@internal@Eigen@@$$CBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$04@Eigen@@QEAA@XZ
?dtor$4@?0??setJandH@Tikhonov2D@@AEAA_NNN@Z@4HA ENDP	; `Tikhonov2D::setJandH'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$GSCopy$1$ = 48
$T1 = 56
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
$T9 = 56
$T10 = 56
$T11 = 56
$T12 = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
othersize$1$ = 96
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
$T22 = 112
$T23 = 112
$T24 = 112
other$1$ = 144
$T25 = 144
$T26 = 152
other$1$ = 160
$T27 = 168
$T28 = 168
$T29 = 168
$T30 = 168
$T31 = 224
$T32 = 232
$T33 = 256
$T34 = 256
z$ = 256
__$ArrayPad$ = 272
this$ = 432
lambdaSquared0$ = 440
lambdaSquared1$ = 448
?dtor$9@?0??setJandH@Tikhonov2D@@AEAA_NNN@Z@4HA PROC	; `Tikhonov2D::setJandH'::`1'::dtor$9
	lea	rcx, QWORD PTR $T19[rdx]
	jmp	??1?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@XZ
?dtor$9@?0??setJandH@Tikhonov2D@@AEAA_NNN@Z@4HA ENDP	; `Tikhonov2D::setJandH'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$GSCopy$1$ = 48
$T1 = 56
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
$T9 = 56
$T10 = 56
$T11 = 56
$T12 = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
othersize$1$ = 96
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
$T22 = 112
$T23 = 112
$T24 = 112
other$1$ = 144
$T25 = 144
$T26 = 152
other$1$ = 160
$T27 = 168
$T28 = 168
$T29 = 168
$T30 = 168
$T31 = 224
$T32 = 232
$T33 = 256
$T34 = 256
z$ = 256
__$ArrayPad$ = 272
this$ = 432
lambdaSquared0$ = 440
lambdaSquared1$ = 448
?dtor$5@?0??setJandH@Tikhonov2D@@AEAA_NNN@Z@4HA PROC	; `Tikhonov2D::setJandH'::`1'::dtor$5
	lea	rcx, QWORD PTR $T27[rdx]
	jmp	??1?$GeneralProduct@V?$CwiseUnaryOp@U?$scalar_multiple_op@N@internal@Eigen@@$$CBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$04@Eigen@@QEAA@XZ
?dtor$5@?0??setJandH@Tikhonov2D@@AEAA_NNN@Z@4HA ENDP	; `Tikhonov2D::setJandH'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$GSCopy$1$ = 48
$T1 = 56
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
$T9 = 56
$T10 = 56
$T11 = 56
$T12 = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
othersize$1$ = 96
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
$T22 = 112
$T23 = 112
$T24 = 112
other$1$ = 144
$T25 = 144
$T26 = 152
other$1$ = 160
$T27 = 168
$T28 = 168
$T29 = 168
$T30 = 168
$T31 = 224
$T32 = 232
$T33 = 256
$T34 = 256
z$ = 256
__$ArrayPad$ = 272
this$ = 432
lambdaSquared0$ = 440
lambdaSquared1$ = 448
?dtor$10@?0??setJandH@Tikhonov2D@@AEAA_NNN@Z@4HA PROC	; `Tikhonov2D::setJandH'::`1'::dtor$10
	lea	rcx, QWORD PTR $T18[rdx]
	jmp	??1?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@XZ
?dtor$10@?0??setJandH@Tikhonov2D@@AEAA_NNN@Z@4HA ENDP	; `Tikhonov2D::setJandH'::`1'::dtor$10
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$GSCopy$1$ = 48
$T1 = 56
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
$T9 = 56
$T10 = 56
$T11 = 56
$T12 = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
othersize$1$ = 96
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
$T22 = 112
$T23 = 112
$T24 = 112
other$1$ = 144
$T25 = 144
$T26 = 152
other$1$ = 160
$T27 = 168
$T28 = 168
$T29 = 168
$T30 = 168
$T31 = 224
$T32 = 232
$T33 = 256
$T34 = 256
z$ = 256
__$ArrayPad$ = 272
this$ = 432
lambdaSquared0$ = 440
lambdaSquared1$ = 448
?dtor$11@?0??setJandH@Tikhonov2D@@AEAA_NNN@Z@4HA PROC	; `Tikhonov2D::setJandH'::`1'::dtor$11
	lea	rcx, QWORD PTR z$[rdx]
	jmp	??1?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAA@XZ
?dtor$11@?0??setJandH@Tikhonov2D@@AEAA_NNN@Z@4HA ENDP	; `Tikhonov2D::setJandH'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$GSCopy$1$ = 48
$T1 = 56
$T2 = 56
$T3 = 56
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
$T9 = 56
$T10 = 56
$T11 = 56
$T12 = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
othersize$1$ = 96
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
$T22 = 112
$T23 = 112
$T24 = 112
other$1$ = 144
$T25 = 144
$T26 = 152
other$1$ = 160
$T27 = 168
$T28 = 168
$T29 = 168
$T30 = 168
$T31 = 224
$T32 = 232
$T33 = 256
$T34 = 256
z$ = 256
__$ArrayPad$ = 272
this$ = 432
lambdaSquared0$ = 440
lambdaSquared1$ = 448
?dtor$6@?0??setJandH@Tikhonov2D@@AEAA_NNN@Z@4HA PROC	; `Tikhonov2D::setJandH'::`1'::dtor$6
	lea	rcx, QWORD PTR z$[rdx]
	jmp	??1?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@XZ
?dtor$6@?0??setJandH@Tikhonov2D@@AEAA_NNN@Z@4HA ENDP	; `Tikhonov2D::setJandH'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
;	COMDAT ?getA_ij@Tikhonov2D@@AEBAN_K0@Z
_TEXT	SEGMENT
this$ = 80
i$ = 88
j$ = 96
?getA_ij@Tikhonov2D@@AEBAN_K0@Z PROC			; Tikhonov2D::getA_ij, COMDAT

; 243  : double Tikhonov2D::getA_ij(const size_t i, const size_t j)const{

$LN174:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 48					; 00000030H

; 244  : 	
; 245  : 	if (j == size_j - 1)

	mov	rax, QWORD PTR [rcx+8]
	mov	rdi, r8
	mov	rsi, rdx
	dec	rax
	mov	rbx, rcx
	cmp	r8, rax
	jne	SHORT $LN2@getA_ij

; 246  : 		return 1.0;

	movsdx	xmm0, QWORD PTR __real@3ff0000000000000

; 250  : 	
; 251  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN2@getA_ij:
	mov	QWORD PTR [rsp+80], rbp
	mov	QWORD PTR [rsp+88], r12
	mov	QWORD PTR [rsp+96], r13
	mov	QWORD PTR [rsp+40], r14
	mov	QWORD PTR [rsp+32], r15
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 173  :       eigen_assert(index >= 0 && index < size());

	test	rdx, rdx
	js	SHORT $LN7@getA_ij
	cmp	rdx, QWORD PTR [rcx+40]
	jl	SHORT $LN8@getA_ij
$LN7@getA_ij:
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	mov	r8d, 173				; 000000adH
	call	QWORD PTR __imp__wassert
$LN8@getA_ij:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 333  :     inline const T *data() const { return m_data; }

	mov	r13, QWORD PTR [rbx+32]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 156  :       eigen_assert(index >= 0 && index < size());

	test	rdi, rdi
	js	SHORT $LN35@getA_ij
	cmp	rdi, QWORD PTR [rbx+424]
	jl	SHORT $LN36@getA_ij
$LN35@getA_ij:
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	mov	r8d, 156				; 0000009cH
	call	QWORD PTR __imp__wassert
$LN36@getA_ij:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 333  :     inline const T *data() const { return m_data; }

	mov	r12, QWORD PTR [rbx+416]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 173  :       eigen_assert(index >= 0 && index < size());

	test	rdi, rdi
	js	SHORT $LN63@getA_ij
	cmp	rdi, QWORD PTR [rbx+56]
	jl	SHORT $LN64@getA_ij
$LN63@getA_ij:
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	mov	r8d, 173				; 000000adH
	call	QWORD PTR __imp__wassert
$LN64@getA_ij:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 333  :     inline const T *data() const { return m_data; }

	mov	r15, QWORD PTR [rbx+48]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 173  :       eigen_assert(index >= 0 && index < size());

	test	rsi, rsi
	js	SHORT $LN91@getA_ij
	cmp	rsi, QWORD PTR [rbx+40]
	jl	SHORT $LN92@getA_ij
$LN91@getA_ij:
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	mov	r8d, 173				; 000000adH
	call	QWORD PTR __imp__wassert
$LN92@getA_ij:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 333  :     inline const T *data() const { return m_data; }

	mov	r14, QWORD PTR [rbx+32]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 156  :       eigen_assert(index >= 0 && index < size());

	test	rdi, rdi
	js	SHORT $LN119@getA_ij
	cmp	rdi, QWORD PTR [rbx+424]
	jl	SHORT $LN120@getA_ij
$LN119@getA_ij:
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	mov	r8d, 156				; 0000009cH
	call	QWORD PTR __imp__wassert
$LN120@getA_ij:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 333  :     inline const T *data() const { return m_data; }

	mov	rbp, QWORD PTR [rbx+416]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 173  :       eigen_assert(index >= 0 && index < size());

	test	rdi, rdi
	js	SHORT $LN147@getA_ij
	cmp	rdi, QWORD PTR [rbx+56]
	jl	SHORT $LN148@getA_ij
$LN147@getA_ij:
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	mov	r8d, 173				; 000000adH
	call	QWORD PTR __imp__wassert
$LN148@getA_ij:
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 249  : 	        	* ((wavelength(i) - lambda0 + v[j] * lambda0 / vlight) / width(j))));

	movsdx	xmm3, QWORD PTR [rbx+24]
	movsdx	xmm0, QWORD PTR [r13+rsi*8]
	movsdx	xmm1, QWORD PTR [r14+rsi*8]
	mov	rax, QWORD PTR [rbx+48]
	subsd	xmm0, xmm3
	movaps	xmm4, xmm3
	subsd	xmm1, xmm3
	mulsd	xmm4, QWORD PTR [r12+rdi*8]
	divsd	xmm4, QWORD PTR [rbx+16]
	addsd	xmm4, xmm0
	movaps	xmm0, xmm3
	mulsd	xmm0, QWORD PTR [rbp+rdi*8]
	divsd	xmm0, QWORD PTR [rbx+16]
	divsd	xmm4, QWORD PTR [r15+rdi*8]
	addsd	xmm0, xmm1
	divsd	xmm0, QWORD PTR [rax+rdi*8]
	mulsd	xmm0, xmm4
	xorps	xmm0, QWORD PTR __xmm@80000000000000008000000000000000
	mov	r15, QWORD PTR [rsp+32]
	mov	r14, QWORD PTR [rsp+40]
	mov	r13, QWORD PTR [rsp+96]
	mov	r12, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+80]

; 250  : 	
; 251  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbx

; 249  : 	        	* ((wavelength(i) - lambda0 + v[j] * lambda0 / vlight) / width(j))));

	jmp	exp
?getA_ij@Tikhonov2D@@AEBAN_K0@Z ENDP			; Tikhonov2D::getA_ij
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp
;	COMDAT ?getAdv_ij@Tikhonov2D@@AEBAN_K0@Z
_TEXT	SEGMENT
this$ = 96
i$ = 104
j$ = 112
?getAdv_ij@Tikhonov2D@@AEBAN_K0@Z PROC			; Tikhonov2D::getAdv_ij, COMDAT

; 252  : double Tikhonov2D::getAdv_ij(const size_t i, const size_t j)const{

$LN118:
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 64					; 00000040H

; 253  : 	if (j == size_j - 1)

	mov	rax, QWORD PTR [rcx+8]
	mov	rsi, r8
	mov	rbp, rdx
	dec	rax
	mov	rdi, rcx
	cmp	r8, rax
	jne	SHORT $LN2@getAdv_ij
	xorps	xmm0, xmm0

; 258  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN2@getAdv_ij:
	mov	QWORD PTR [rsp+96], rbx
	mov	QWORD PTR [rsp+104], r12
	mov	QWORD PTR [rsp+112], r14
	mov	QWORD PTR [rsp+120], r15
	movaps	XMMWORD PTR [rsp+48], xmm6
	movaps	XMMWORD PTR [rsp+32], xmm7
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 173  :       eigen_assert(index >= 0 && index < size());

	test	rdx, rdx
	js	SHORT $LN7@getAdv_ij
	cmp	rdx, QWORD PTR [rcx+40]
	jl	SHORT $LN8@getAdv_ij
$LN7@getAdv_ij:
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	mov	r8d, 173				; 000000adH
	call	QWORD PTR __imp__wassert
$LN8@getAdv_ij:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 333  :     inline const T *data() const { return m_data; }

	mov	r12, QWORD PTR [rdi+32]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 156  :       eigen_assert(index >= 0 && index < size());

	test	rsi, rsi
	js	SHORT $LN35@getAdv_ij
	cmp	rsi, QWORD PTR [rdi+424]
	jl	SHORT $LN36@getAdv_ij
$LN35@getAdv_ij:
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	mov	r8d, 156				; 0000009cH
	call	QWORD PTR __imp__wassert
$LN36@getAdv_ij:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 333  :     inline const T *data() const { return m_data; }

	mov	r15, QWORD PTR [rdi+416]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 173  :       eigen_assert(index >= 0 && index < size());

	test	rsi, rsi
	js	SHORT $LN63@getAdv_ij
	cmp	rsi, QWORD PTR [rdi+56]
	jl	SHORT $LN64@getAdv_ij
$LN63@getAdv_ij:
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	mov	r8d, 173				; 000000adH
	call	QWORD PTR __imp__wassert
$LN64@getAdv_ij:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 333  :     inline const T *data() const { return m_data; }

	mov	r14, QWORD PTR [rdi+48]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 173  :       eigen_assert(index >= 0 && index < size());

	test	rsi, rsi
	js	SHORT $LN91@getAdv_ij
	cmp	rsi, QWORD PTR [rdi+56]
	jl	SHORT $LN92@getAdv_ij
$LN91@getAdv_ij:
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	mov	r8d, 173				; 000000adH
	call	QWORD PTR __imp__wassert
$LN92@getAdv_ij:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 333  :     inline const T *data() const { return m_data; }

	mov	rbx, QWORD PTR [rdi+48]
; File c:\users\jumpei tono\documents\visual studio 2013\projects\fujii\tikhonov_nonlin2d_study\tikhonov2d.cpp

; 257  : 			/ vlight / width(j) / width(j));

	movsdx	xmm6, QWORD PTR [rdi+24]
	movsdx	xmm7, QWORD PTR [rdi+16]
	mov	r8, rsi
	mov	rdx, rbp
	mov	rcx, rdi
	call	?getA_ij@Tikhonov2D@@AEBAN_K0@Z		; Tikhonov2D::getA_ij
	movsdx	xmm1, QWORD PTR [r12+rbp*8]
	mov	r12, QWORD PTR [rsp+104]
	movaps	xmm2, xmm6
	mulsd	xmm2, QWORD PTR [r15+rsi*8]
	mov	r15, QWORD PTR [rsp+120]
	subsd	xmm1, xmm6
	mulsd	xmm0, QWORD PTR __real@4000000000000000
	divsd	xmm2, xmm7
	addsd	xmm2, xmm1
	mulsd	xmm0, xmm6
	movaps	xmm6, XMMWORD PTR [rsp+48]
	mulsd	xmm0, xmm2
	divsd	xmm0, xmm7
	movaps	xmm7, XMMWORD PTR [rsp+32]
	divsd	xmm0, QWORD PTR [r14+rsi*8]
	mov	r14, QWORD PTR [rsp+112]
	divsd	xmm0, QWORD PTR [rbx+rsi*8]
	mov	rbx, QWORD PTR [rsp+96]
	xorps	xmm0, QWORD PTR __xmm@80000000000000008000000000000000

; 258  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?getAdv_ij@Tikhonov2D@@AEBAN_K0@Z ENDP			; Tikhonov2D::getAdv_ij
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\plugins\blockmethods.h
;	COMDAT ?block@?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAA?AV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@_J000@Z
_TEXT	SEGMENT
this$ = 64
__$ReturnUdt$ = 72
startRow$ = 80
startCol$dead$ = 88
blockRows$ = 96
blockCols$dead$ = 104
?block@?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAA?AV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@_J000@Z PROC ; Eigen::DenseBase<Eigen::Matrix<double,-1,1,0,-1,1> >::block, COMDAT

; 57   : {

$LN6:
	push	rbx
	sub	rsp, 48					; 00000030H

; 58   :   return Block<Derived>(derived(), startRow, startCol, blockRows, blockCols);

	mov	rax, QWORD PTR blockRows$[rsp]
	mov	rbx, rdx
	mov	rdx, rcx
	mov	rcx, rbx
	mov	QWORD PTR [rsp+32], rax
	call	??0?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@QEAA@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@_J111@Z ; Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>
	mov	rax, rbx

; 59   : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
?block@?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAA?AV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@_J000@Z ENDP ; Eigen::DenseBase<Eigen::Matrix<double,-1,1,0,-1,1> >::block
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
;	COMDAT ??A?$DenseCoeffsBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0A@@Eigen@@QEBAAEBN_J@Z
_TEXT	SEGMENT
this$ = 48
index$ = 56
??A?$DenseCoeffsBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0A@@Eigen@@QEBAAEBN_J@Z PROC ; Eigen::DenseCoeffsBase<Eigen::Matrix<double,-1,1,0,-1,1>,0>::operator[], COMDAT

; 151  :     {

$LN30:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx

; 152  :       #ifndef EIGEN2_SUPPORT
; 153  :       EIGEN_STATIC_ASSERT(Derived::IsVectorAtCompileTime,
; 154  :                           THE_BRACKET_OPERATOR_IS_ONLY_FOR_VECTORS__USE_THE_PARENTHESIS_OPERATOR_INSTEAD)
; 155  :       #endif
; 156  :       eigen_assert(index >= 0 && index < size());

	test	rdx, rdx
	js	SHORT $LN3@operator
	cmp	rdx, QWORD PTR [rcx+8]
	jl	SHORT $LN4@operator
$LN3@operator:
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	mov	r8d, 156				; 0000009cH
	call	QWORD PTR __imp__wassert
$LN4@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 148  :       return m_storage.data()[index];

	mov	rax, QWORD PTR [rdi]
	lea	rax, QWORD PTR [rax+rbx*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 158  :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??A?$DenseCoeffsBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0A@@Eigen@@QEBAAEBN_J@Z ENDP ; Eigen::DenseCoeffsBase<Eigen::Matrix<double,-1,1,0,-1,1>,0>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
;	COMDAT ??R?$DenseCoeffsBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0A@@Eigen@@QEBAAEBN_J@Z
_TEXT	SEGMENT
this$ = 48
index$ = 56
??R?$DenseCoeffsBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0A@@Eigen@@QEBAAEBN_J@Z PROC ; Eigen::DenseCoeffsBase<Eigen::Matrix<double,-1,1,0,-1,1>,0>::operator(), COMDAT

; 172  :     {

$LN30:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx

; 173  :       eigen_assert(index >= 0 && index < size());

	test	rdx, rdx
	js	SHORT $LN3@operator
	cmp	rdx, QWORD PTR [rcx+8]
	jl	SHORT $LN4@operator
$LN3@operator:
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	mov	r8d, 173				; 000000adH
	call	QWORD PTR __imp__wassert
$LN4@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 148  :       return m_storage.data()[index];

	mov	rax, QWORD PTR [rdi]
	lea	rax, QWORD PTR [rax+rbx*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 175  :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??R?$DenseCoeffsBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0A@@Eigen@@QEBAAEBN_J@Z ENDP ; Eigen::DenseCoeffsBase<Eigen::Matrix<double,-1,1,0,-1,1>,0>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\plugins\blockmethods.h
;	COMDAT ?block@?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAA?AV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@2@_J000@Z
_TEXT	SEGMENT
this$ = 64
__$ReturnUdt$ = 72
startRow$ = 80
startCol$ = 88
blockRows$ = 96
blockCols$ = 104
?block@?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAA?AV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@2@_J000@Z PROC ; Eigen::DenseBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::block, COMDAT

; 57   : {

$LN6:
	push	rbx
	sub	rsp, 48					; 00000030H

; 58   :   return Block<Derived>(derived(), startRow, startCol, blockRows, blockCols);

	mov	rax, QWORD PTR blockCols$[rsp]
	mov	rbx, rdx
	mov	rdx, rcx
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR blockRows$[rsp]
	mov	rcx, rbx
	mov	QWORD PTR [rsp+32], rax
	call	??0?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@QEAA@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@_J111@Z ; Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>
	mov	rax, rbx

; 59   : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
?block@?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAA?AV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@2@_J000@Z ENDP ; Eigen::DenseBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::block
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
;	COMDAT ??R?$DenseCoeffsBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$00@Eigen@@QEAAAEAN_J@Z
_TEXT	SEGMENT
this$ = 48
index$ = 56
??R?$DenseCoeffsBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$00@Eigen@@QEAAAEAN_J@Z PROC ; Eigen::DenseCoeffsBase<Eigen::Matrix<double,-1,-1,0,-1,-1>,1>::operator(), COMDAT

; 393  :     {

$LN30:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx
	mov	rbx, rcx

; 394  :       eigen_assert(index >= 0 && index < size());

	test	rdx, rdx
	js	SHORT $LN3@operator
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 49   :   inline Index size() const { return rows() * cols(); }

	mov	rax, QWORD PTR [rcx+16]
	imul	rax, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 394  :       eigen_assert(index >= 0 && index < size());

	cmp	rdx, rax
	jl	SHORT $LN4@operator
$LN3@operator:
	lea	rdx, OFFSET FLAT:??_C@_1MA@ILBJIPNP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DK@KFNEMHOJ@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	mov	r8d, 394				; 0000018aH
	call	QWORD PTR __imp__wassert
$LN4@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 161  :       return m_storage.data()[index];

	mov	rax, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 396  :     }

	mov	rbx, QWORD PTR [rsp+48]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 161  :       return m_storage.data()[index];

	lea	rax, QWORD PTR [rax+rdi*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 396  :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??R?$DenseCoeffsBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$00@Eigen@@QEAAAEAN_J@Z ENDP ; Eigen::DenseCoeffsBase<Eigen::Matrix<double,-1,-1,0,-1,-1>,1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h
;	COMDAT ??0?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@QEAA@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@_J111@Z
_TEXT	SEGMENT
this$ = 48
xpr$ = 56
a_startRow$ = 64
a_startCol$dead$ = 72
blockRows$ = 80
blockCols$dead$ = 88
??0?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@QEAA@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@_J111@Z PROC ; Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>, COMDAT

; 137  :     {

$LN98:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];

	mov	rax, QWORD PTR [rdx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h

; 63   :     explicit variable_if_dynamic(T value) : m_value(value) {}

	mov	rdi, QWORD PTR blockRows$[rsp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h

; 137  :     {

	mov	rbp, r8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];

	lea	r9, QWORD PTR [rax+r8*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h

; 137  :     {

	mov	rsi, rdx
	mov	rbx, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 145  :     {

	mov	QWORD PTR [rcx], r9
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h

; 63   :     explicit variable_if_dynamic(T value) : m_value(value) {}

	mov	QWORD PTR [rcx+8], rdi
	mov	QWORD PTR [rcx+16], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 146  :       eigen_assert( (dataPtr == 0)

	test	r9, r9
	je	SHORT $LN28@Block
	test	rdi, rdi
	jns	SHORT $LN28@Block
	lea	rdx, OFFSET FLAT:??_C@_1LA@MIDGNIKC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1BGE@MDFDAGNB@?$AA?$CI?$AAd?$AAa?$AAt?$AAa?$AAP?$AAt?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$CJ?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AA?$CI?$AA?5?$AAn?$AAb?$AAR?$AAo?$AAw?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5@
	mov	r8d, 148				; 00000094H
	call	QWORD PTR __imp__wassert
$LN28@Block:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h

; 351  :     {

	mov	QWORD PTR [rbx+24], rsi

; 352  :       init();
; 353  :     }
; 354  : 
; 355  :     const typename internal::remove_all<typename XprType::Nested>::type& nestedExpression() const 
; 356  :     { 
; 357  :       return m_xpr; 
; 358  :     }
; 359  :       
; 360  :     /** \sa MapBase::innerStride() */
; 361  :     inline Index innerStride() const
; 362  :     {
; 363  :       return internal::traits<BlockType>::HasSameStorageOrderAsXprType
; 364  :              ? m_xpr.innerStride()
; 365  :              : m_xpr.outerStride();
; 366  :     }
; 367  : 
; 368  :     /** \sa MapBase::outerStride() */
; 369  :     inline Index outerStride() const
; 370  :     {
; 371  :       return m_outerStride;
; 372  :     }
; 373  : 
; 374  :   #ifndef __SUNPRO_CC
; 375  :   // FIXME sunstudio is not friendly with the above friend...
; 376  :   // META-FIXME there is no 'friend' keyword around here. Is this obsolete?
; 377  :   protected:
; 378  :   #endif
; 379  : 
; 380  :     #ifndef EIGEN_PARSED_BY_DOXYGEN
; 381  :     /** \internal used by allowAligned() */
; 382  :     inline BlockImpl_dense(XprType& xpr, const Scalar* data, Index blockRows, Index blockCols)
; 383  :       : Base(data, blockRows, blockCols), m_xpr(xpr)
; 384  :     {
; 385  :       init();
; 386  :     }
; 387  :     #endif
; 388  : 
; 389  :   protected:
; 390  :     void init()
; 391  :     {
; 392  :       m_outerStride = internal::traits<BlockType>::HasSameStorageOrderAsXprType
; 393  :                     ? m_xpr.outerStride()
; 394  :                     : m_xpr.innerStride();

	mov	rax, QWORD PTR [rsi+8]
	mov	QWORD PTR [rbx+32], rax

; 138  :       eigen_assert((RowsAtCompileTime==Dynamic || RowsAtCompileTime==blockRows)
; 139  :           && (ColsAtCompileTime==Dynamic || ColsAtCompileTime==blockCols));
; 140  :       eigen_assert(a_startRow >= 0 && blockRows >= 0 && a_startRow  <= xpr.rows() - blockRows

	test	rbp, rbp
	js	SHORT $LN3@Block
	test	rdi, rdi
	js	SHORT $LN3@Block
	mov	rax, QWORD PTR [rsi+8]
	sub	rax, rdi
	cmp	rbp, rax
	jle	SHORT $LN96@Block
$LN3@Block:
	lea	rdx, OFFSET FLAT:??_C@_1KM@LCMGCMD@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1BCO@NFJGBHKC@?$AAa?$AA_?$AAs?$AAt?$AAa?$AAr?$AAt?$AAR?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAb?$AAl?$AAo?$AAc?$AAk?$AAR?$AAo?$AAw?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5@
	mov	r8d, 141				; 0000008dH
	call	QWORD PTR __imp__wassert
$LN96@Block:

; 141  :           && a_startCol >= 0 && blockCols >= 0 && a_startCol <= xpr.cols() - blockCols);
; 142  :     }

	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@QEAA@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@_J111@Z ENDP ; Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h
;	COMDAT ??0?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@QEAA@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@_J111@Z
_TEXT	SEGMENT
this$ = 64
xpr$ = 72
a_startRow$ = 80
a_startCol$ = 88
blockRows$ = 96
blockCols$ = 104
??0?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@QEAA@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@_J111@Z PROC ; Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>, COMDAT

; 137  :     {

$LN96:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];

	mov	rax, QWORD PTR [rdx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h

; 63   :     explicit variable_if_dynamic(T value) : m_value(value) {}

	mov	rbp, QWORD PTR blockRows$[rsp]
	mov	rsi, QWORD PTR blockCols$[rsp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];

	mov	r10, r9
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h

; 137  :     {

	mov	r14, r9
	mov	r15, r8
	mov	rdi, rdx
	mov	rbx, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];

	imul	r10, QWORD PTR [rdx+8]
	add	r10, r8
	lea	r11, QWORD PTR [rax+r10*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 145  :     {

	mov	QWORD PTR [rcx], r11
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h

; 63   :     explicit variable_if_dynamic(T value) : m_value(value) {}

	mov	QWORD PTR [rcx+8], rbp
	mov	QWORD PTR [rcx+16], rsi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 146  :       eigen_assert( (dataPtr == 0)

	test	r11, r11
	je	SHORT $LN28@Block
	test	rbp, rbp
	js	SHORT $LN27@Block
	test	rsi, rsi
	jns	SHORT $LN28@Block
$LN27@Block:
	lea	rdx, OFFSET FLAT:??_C@_1LA@MIDGNIKC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1BGE@MDFDAGNB@?$AA?$CI?$AAd?$AAa?$AAt?$AAa?$AAP?$AAt?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$CJ?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AA?$CI?$AA?5?$AAn?$AAb?$AAR?$AAo?$AAw?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5@
	mov	r8d, 148				; 00000094H
	call	QWORD PTR __imp__wassert
$LN28@Block:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h

; 351  :     {

	mov	QWORD PTR [rbx+24], rdi

; 352  :       init();
; 353  :     }
; 354  : 
; 355  :     const typename internal::remove_all<typename XprType::Nested>::type& nestedExpression() const 
; 356  :     { 
; 357  :       return m_xpr; 
; 358  :     }
; 359  :       
; 360  :     /** \sa MapBase::innerStride() */
; 361  :     inline Index innerStride() const
; 362  :     {
; 363  :       return internal::traits<BlockType>::HasSameStorageOrderAsXprType
; 364  :              ? m_xpr.innerStride()
; 365  :              : m_xpr.outerStride();
; 366  :     }
; 367  : 
; 368  :     /** \sa MapBase::outerStride() */
; 369  :     inline Index outerStride() const
; 370  :     {
; 371  :       return m_outerStride;
; 372  :     }
; 373  : 
; 374  :   #ifndef __SUNPRO_CC
; 375  :   // FIXME sunstudio is not friendly with the above friend...
; 376  :   // META-FIXME there is no 'friend' keyword around here. Is this obsolete?
; 377  :   protected:
; 378  :   #endif
; 379  : 
; 380  :     #ifndef EIGEN_PARSED_BY_DOXYGEN
; 381  :     /** \internal used by allowAligned() */
; 382  :     inline BlockImpl_dense(XprType& xpr, const Scalar* data, Index blockRows, Index blockCols)
; 383  :       : Base(data, blockRows, blockCols), m_xpr(xpr)
; 384  :     {
; 385  :       init();
; 386  :     }
; 387  :     #endif
; 388  : 
; 389  :   protected:
; 390  :     void init()
; 391  :     {
; 392  :       m_outerStride = internal::traits<BlockType>::HasSameStorageOrderAsXprType
; 393  :                     ? m_xpr.outerStride()
; 394  :                     : m_xpr.innerStride();

	mov	rax, QWORD PTR [rdi+8]
	mov	QWORD PTR [rbx+32], rax

; 138  :       eigen_assert((RowsAtCompileTime==Dynamic || RowsAtCompileTime==blockRows)
; 139  :           && (ColsAtCompileTime==Dynamic || ColsAtCompileTime==blockCols));
; 140  :       eigen_assert(a_startRow >= 0 && blockRows >= 0 && a_startRow  <= xpr.rows() - blockRows

	test	r15, r15
	js	SHORT $LN3@Block
	test	rbp, rbp
	js	SHORT $LN3@Block
	mov	rax, QWORD PTR [rdi+8]
	sub	rax, rbp
	cmp	r15, rax
	jg	SHORT $LN3@Block
	test	r14, r14
	js	SHORT $LN3@Block
	test	rsi, rsi
	js	SHORT $LN3@Block
	mov	rax, QWORD PTR [rdi+16]
	sub	rax, rsi
	cmp	r14, rax
	jle	SHORT $LN94@Block
$LN3@Block:
	lea	rdx, OFFSET FLAT:??_C@_1KM@LCMGCMD@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1BCO@NFJGBHKC@?$AAa?$AA_?$AAs?$AAt?$AAa?$AAr?$AAt?$AAR?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAb?$AAl?$AAo?$AAc?$AAk?$AAR?$AAo?$AAw?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5@
	mov	r8d, 141				; 0000008dH
	call	QWORD PTR __imp__wassert
$LN94@Block:

; 141  :           && a_startCol >= 0 && blockCols >= 0 && a_startCol <= xpr.cols() - blockCols);
; 142  :     }

	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
??0?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@QEAA@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@_J111@Z ENDP ; Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h
;	COMDAT ??0?$BlockImpl@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@UDense@2@@Eigen@@QEAA@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@_J111@Z
_TEXT	SEGMENT
this$ = 48
xpr$ = 56
a_startRow$ = 64
a_startCol$dead$ = 72
blockRows$ = 80
blockCols$dead$ = 88
??0?$BlockImpl@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@UDense@2@@Eigen@@QEAA@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@_J111@Z PROC ; Eigen::BlockImpl<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0,Eigen::Dense>::BlockImpl<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0,Eigen::Dense>, COMDAT

; 158  :     inline BlockImpl(XprType& xpr, Index a_startRow, Index a_startCol, Index blockRows, Index blockCols)

$LN82:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];

	mov	rax, QWORD PTR [rdx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h

; 158  :     inline BlockImpl(XprType& xpr, Index a_startRow, Index a_startCol, Index blockRows, Index blockCols)

	mov	rdi, rdx
	mov	rbx, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];

	lea	r9, QWORD PTR [rax+r8*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h

; 63   :     explicit variable_if_dynamic(T value) : m_value(value) {}

	mov	rax, QWORD PTR blockRows$[rsp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 145  :     {

	mov	QWORD PTR [rcx], r9
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h

; 63   :     explicit variable_if_dynamic(T value) : m_value(value) {}

	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 146  :       eigen_assert( (dataPtr == 0)

	test	r9, r9
	je	SHORT $LN24@BlockImpl
	test	rax, rax
	jns	SHORT $LN24@BlockImpl
	lea	rdx, OFFSET FLAT:??_C@_1LA@MIDGNIKC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1BGE@MDFDAGNB@?$AA?$CI?$AAd?$AAa?$AAt?$AAa?$AAP?$AAt?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$CJ?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AA?$CI?$AA?5?$AAn?$AAb?$AAR?$AAo?$AAw?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5@
	mov	r8d, 148				; 00000094H
	call	QWORD PTR __imp__wassert
$LN24@BlockImpl:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h

; 351  :     {

	mov	QWORD PTR [rbx+24], rdi

; 352  :       init();
; 353  :     }
; 354  : 
; 355  :     const typename internal::remove_all<typename XprType::Nested>::type& nestedExpression() const 
; 356  :     { 
; 357  :       return m_xpr; 
; 358  :     }
; 359  :       
; 360  :     /** \sa MapBase::innerStride() */
; 361  :     inline Index innerStride() const
; 362  :     {
; 363  :       return internal::traits<BlockType>::HasSameStorageOrderAsXprType
; 364  :              ? m_xpr.innerStride()
; 365  :              : m_xpr.outerStride();
; 366  :     }
; 367  : 
; 368  :     /** \sa MapBase::outerStride() */
; 369  :     inline Index outerStride() const
; 370  :     {
; 371  :       return m_outerStride;
; 372  :     }
; 373  : 
; 374  :   #ifndef __SUNPRO_CC
; 375  :   // FIXME sunstudio is not friendly with the above friend...
; 376  :   // META-FIXME there is no 'friend' keyword around here. Is this obsolete?
; 377  :   protected:
; 378  :   #endif
; 379  : 
; 380  :     #ifndef EIGEN_PARSED_BY_DOXYGEN
; 381  :     /** \internal used by allowAligned() */
; 382  :     inline BlockImpl_dense(XprType& xpr, const Scalar* data, Index blockRows, Index blockCols)
; 383  :       : Base(data, blockRows, blockCols), m_xpr(xpr)
; 384  :     {
; 385  :       init();
; 386  :     }
; 387  :     #endif
; 388  : 
; 389  :   protected:
; 390  :     void init()
; 391  :     {
; 392  :       m_outerStride = internal::traits<BlockType>::HasSameStorageOrderAsXprType
; 393  :                     ? m_xpr.outerStride()
; 394  :                     : m_xpr.innerStride();

	mov	rax, QWORD PTR [rdi+8]
	mov	QWORD PTR [rbx+32], rax

; 158  :     inline BlockImpl(XprType& xpr, Index a_startRow, Index a_startCol, Index blockRows, Index blockCols)

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0?$BlockImpl@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@UDense@2@@Eigen@@QEAA@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@_J111@Z ENDP ; Eigen::BlockImpl<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0,Eigen::Dense>::BlockImpl<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0,Eigen::Dense>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h
;	COMDAT ??0?$BlockImpl@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@UDense@2@@Eigen@@QEAA@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@_J111@Z
_TEXT	SEGMENT
this$ = 48
xpr$ = 56
a_startRow$ = 64
a_startCol$ = 72
blockRows$ = 80
blockCols$ = 88
??0?$BlockImpl@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@UDense@2@@Eigen@@QEAA@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@_J111@Z PROC ; Eigen::BlockImpl<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0,Eigen::Dense>::BlockImpl<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0,Eigen::Dense>, COMDAT

; 158  :     inline BlockImpl(XprType& xpr, Index a_startRow, Index a_startCol, Index blockRows, Index blockCols)

$LN82:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];

	imul	r9, QWORD PTR [rdx+8]
	mov	rax, QWORD PTR [rdx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h

; 158  :     inline BlockImpl(XprType& xpr, Index a_startRow, Index a_startCol, Index blockRows, Index blockCols)

	mov	rbx, rcx
	mov	rdi, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];

	add	r9, r8
	lea	r8, QWORD PTR [rax+r9*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h

; 63   :     explicit variable_if_dynamic(T value) : m_value(value) {}

	mov	rax, QWORD PTR blockCols$[rsp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 145  :     {

	mov	QWORD PTR [rcx], r8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h

; 63   :     explicit variable_if_dynamic(T value) : m_value(value) {}

	mov	rcx, QWORD PTR blockRows$[rsp]
	mov	QWORD PTR [rbx+8], rcx
	mov	QWORD PTR [rbx+16], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 146  :       eigen_assert( (dataPtr == 0)

	test	r8, r8
	je	SHORT $LN24@BlockImpl
	test	rcx, rcx
	js	SHORT $LN23@BlockImpl
	test	rax, rax
	jns	SHORT $LN24@BlockImpl
$LN23@BlockImpl:
	lea	rdx, OFFSET FLAT:??_C@_1LA@MIDGNIKC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1BGE@MDFDAGNB@?$AA?$CI?$AAd?$AAa?$AAt?$AAa?$AAP?$AAt?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$CJ?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AA?$CI?$AA?5?$AAn?$AAb?$AAR?$AAo?$AAw?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5@
	mov	r8d, 148				; 00000094H
	call	QWORD PTR __imp__wassert
$LN24@BlockImpl:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h

; 351  :     {

	mov	QWORD PTR [rbx+24], rdi

; 352  :       init();
; 353  :     }
; 354  : 
; 355  :     const typename internal::remove_all<typename XprType::Nested>::type& nestedExpression() const 
; 356  :     { 
; 357  :       return m_xpr; 
; 358  :     }
; 359  :       
; 360  :     /** \sa MapBase::innerStride() */
; 361  :     inline Index innerStride() const
; 362  :     {
; 363  :       return internal::traits<BlockType>::HasSameStorageOrderAsXprType
; 364  :              ? m_xpr.innerStride()
; 365  :              : m_xpr.outerStride();
; 366  :     }
; 367  : 
; 368  :     /** \sa MapBase::outerStride() */
; 369  :     inline Index outerStride() const
; 370  :     {
; 371  :       return m_outerStride;
; 372  :     }
; 373  : 
; 374  :   #ifndef __SUNPRO_CC
; 375  :   // FIXME sunstudio is not friendly with the above friend...
; 376  :   // META-FIXME there is no 'friend' keyword around here. Is this obsolete?
; 377  :   protected:
; 378  :   #endif
; 379  : 
; 380  :     #ifndef EIGEN_PARSED_BY_DOXYGEN
; 381  :     /** \internal used by allowAligned() */
; 382  :     inline BlockImpl_dense(XprType& xpr, const Scalar* data, Index blockRows, Index blockCols)
; 383  :       : Base(data, blockRows, blockCols), m_xpr(xpr)
; 384  :     {
; 385  :       init();
; 386  :     }
; 387  :     #endif
; 388  : 
; 389  :   protected:
; 390  :     void init()
; 391  :     {
; 392  :       m_outerStride = internal::traits<BlockType>::HasSameStorageOrderAsXprType
; 393  :                     ? m_xpr.outerStride()
; 394  :                     : m_xpr.innerStride();

	mov	rax, QWORD PTR [rdi+8]
	mov	QWORD PTR [rbx+32], rax

; 158  :     inline BlockImpl(XprType& xpr, Index a_startRow, Index a_startCol, Index blockRows, Index blockCols)

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0?$BlockImpl@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@UDense@2@@Eigen@@QEAA@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@_J111@Z ENDP ; Eigen::BlockImpl<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0,Eigen::Dense>::BlockImpl<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0,Eigen::Dense>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h
;	COMDAT ??0?$BlockImpl_dense@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@$00@internal@Eigen@@QEAA@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@_J111@Z
_TEXT	SEGMENT
this$ = 48
xpr$ = 56
startRow$ = 64
startCol$dead$ = 72
blockRows$ = 80
blockCols$dead$ = 88
??0?$BlockImpl_dense@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@$00@internal@Eigen@@QEAA@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@_J111@Z PROC ; Eigen::internal::BlockImpl_dense<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0,1>::BlockImpl_dense<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0,1>, COMDAT

; 351  :     {

$LN80:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];

	mov	rax, QWORD PTR [rdx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h

; 351  :     {

	mov	rdi, rdx
	mov	rbx, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];

	lea	r9, QWORD PTR [rax+r8*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h

; 63   :     explicit variable_if_dynamic(T value) : m_value(value) {}

	mov	rax, QWORD PTR blockRows$[rsp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 145  :     {

	mov	QWORD PTR [rcx], r9
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h

; 63   :     explicit variable_if_dynamic(T value) : m_value(value) {}

	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 146  :       eigen_assert( (dataPtr == 0)

	test	r9, r9
	je	SHORT $LN22@BlockImpl_
	test	rax, rax
	jns	SHORT $LN22@BlockImpl_
	lea	rdx, OFFSET FLAT:??_C@_1LA@MIDGNIKC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1BGE@MDFDAGNB@?$AA?$CI?$AAd?$AAa?$AAt?$AAa?$AAP?$AAt?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$CJ?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AA?$CI?$AA?5?$AAn?$AAb?$AAR?$AAo?$AAw?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5@
	mov	r8d, 148				; 00000094H
	call	QWORD PTR __imp__wassert
$LN22@BlockImpl_:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h

; 351  :     {

	mov	QWORD PTR [rbx+24], rdi

; 354  : 
; 355  :     const typename internal::remove_all<typename XprType::Nested>::type& nestedExpression() const 
; 356  :     { 
; 357  :       return m_xpr; 
; 358  :     }
; 359  :       
; 360  :     /** \sa MapBase::innerStride() */
; 361  :     inline Index innerStride() const
; 362  :     {
; 363  :       return internal::traits<BlockType>::HasSameStorageOrderAsXprType
; 364  :              ? m_xpr.innerStride()
; 365  :              : m_xpr.outerStride();
; 366  :     }
; 367  : 
; 368  :     /** \sa MapBase::outerStride() */
; 369  :     inline Index outerStride() const
; 370  :     {
; 371  :       return m_outerStride;
; 372  :     }
; 373  : 
; 374  :   #ifndef __SUNPRO_CC
; 375  :   // FIXME sunstudio is not friendly with the above friend...
; 376  :   // META-FIXME there is no 'friend' keyword around here. Is this obsolete?
; 377  :   protected:
; 378  :   #endif
; 379  : 
; 380  :     #ifndef EIGEN_PARSED_BY_DOXYGEN
; 381  :     /** \internal used by allowAligned() */
; 382  :     inline BlockImpl_dense(XprType& xpr, const Scalar* data, Index blockRows, Index blockCols)
; 383  :       : Base(data, blockRows, blockCols), m_xpr(xpr)
; 384  :     {
; 385  :       init();
; 386  :     }
; 387  :     #endif
; 388  : 
; 389  :   protected:
; 390  :     void init()
; 391  :     {
; 392  :       m_outerStride = internal::traits<BlockType>::HasSameStorageOrderAsXprType
; 393  :                     ? m_xpr.outerStride()
; 394  :                     : m_xpr.innerStride();

	mov	rax, QWORD PTR [rdi+8]
	mov	QWORD PTR [rbx+32], rax

; 352  :       init();
; 353  :     }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0?$BlockImpl_dense@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@$00@internal@Eigen@@QEAA@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@_J111@Z ENDP ; Eigen::internal::BlockImpl_dense<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0,1>::BlockImpl_dense<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h
;	COMDAT ??0?$BlockImpl_dense@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@$00@internal@Eigen@@QEAA@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@_J111@Z
_TEXT	SEGMENT
this$ = 48
xpr$ = 56
startRow$ = 64
startCol$ = 72
blockRows$ = 80
blockCols$ = 88
??0?$BlockImpl_dense@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@$00@internal@Eigen@@QEAA@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@_J111@Z PROC ; Eigen::internal::BlockImpl_dense<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0,1>::BlockImpl_dense<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0,1>, COMDAT

; 351  :     {

$LN80:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];

	imul	r9, QWORD PTR [rdx+8]
	mov	rax, QWORD PTR [rdx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h

; 351  :     {

	mov	rbx, rcx
	mov	rdi, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];

	add	r9, r8
	lea	r8, QWORD PTR [rax+r9*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h

; 63   :     explicit variable_if_dynamic(T value) : m_value(value) {}

	mov	rax, QWORD PTR blockCols$[rsp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 145  :     {

	mov	QWORD PTR [rcx], r8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h

; 63   :     explicit variable_if_dynamic(T value) : m_value(value) {}

	mov	rcx, QWORD PTR blockRows$[rsp]
	mov	QWORD PTR [rbx+8], rcx
	mov	QWORD PTR [rbx+16], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 146  :       eigen_assert( (dataPtr == 0)

	test	r8, r8
	je	SHORT $LN22@BlockImpl_
	test	rcx, rcx
	js	SHORT $LN21@BlockImpl_
	test	rax, rax
	jns	SHORT $LN22@BlockImpl_
$LN21@BlockImpl_:
	lea	rdx, OFFSET FLAT:??_C@_1LA@MIDGNIKC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1BGE@MDFDAGNB@?$AA?$CI?$AAd?$AAa?$AAt?$AAa?$AAP?$AAt?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$CJ?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AA?$CI?$AA?5?$AAn?$AAb?$AAR?$AAo?$AAw?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5@
	mov	r8d, 148				; 00000094H
	call	QWORD PTR __imp__wassert
$LN22@BlockImpl_:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h

; 351  :     {

	mov	QWORD PTR [rbx+24], rdi

; 354  : 
; 355  :     const typename internal::remove_all<typename XprType::Nested>::type& nestedExpression() const 
; 356  :     { 
; 357  :       return m_xpr; 
; 358  :     }
; 359  :       
; 360  :     /** \sa MapBase::innerStride() */
; 361  :     inline Index innerStride() const
; 362  :     {
; 363  :       return internal::traits<BlockType>::HasSameStorageOrderAsXprType
; 364  :              ? m_xpr.innerStride()
; 365  :              : m_xpr.outerStride();
; 366  :     }
; 367  : 
; 368  :     /** \sa MapBase::outerStride() */
; 369  :     inline Index outerStride() const
; 370  :     {
; 371  :       return m_outerStride;
; 372  :     }
; 373  : 
; 374  :   #ifndef __SUNPRO_CC
; 375  :   // FIXME sunstudio is not friendly with the above friend...
; 376  :   // META-FIXME there is no 'friend' keyword around here. Is this obsolete?
; 377  :   protected:
; 378  :   #endif
; 379  : 
; 380  :     #ifndef EIGEN_PARSED_BY_DOXYGEN
; 381  :     /** \internal used by allowAligned() */
; 382  :     inline BlockImpl_dense(XprType& xpr, const Scalar* data, Index blockRows, Index blockCols)
; 383  :       : Base(data, blockRows, blockCols), m_xpr(xpr)
; 384  :     {
; 385  :       init();
; 386  :     }
; 387  :     #endif
; 388  : 
; 389  :   protected:
; 390  :     void init()
; 391  :     {
; 392  :       m_outerStride = internal::traits<BlockType>::HasSameStorageOrderAsXprType
; 393  :                     ? m_xpr.outerStride()
; 394  :                     : m_xpr.innerStride();

	mov	rax, QWORD PTR [rdi+8]
	mov	QWORD PTR [rbx+32], rax

; 352  :       init();
; 353  :     }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0?$BlockImpl_dense@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@$00@internal@Eigen@@QEAA@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@_J111@Z ENDP ; Eigen::internal::BlockImpl_dense<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0,1>::BlockImpl_dense<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h
;	COMDAT ?init@?$BlockImpl_dense@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@$00@internal@Eigen@@IEAAXXZ
_TEXT	SEGMENT
this$ = 8
?init@?$BlockImpl_dense@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@$00@internal@Eigen@@IEAAXXZ PROC ; Eigen::internal::BlockImpl_dense<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0,1>::init, COMDAT

; 392  :       m_outerStride = internal::traits<BlockType>::HasSameStorageOrderAsXprType
; 393  :                     ? m_xpr.outerStride()
; 394  :                     : m_xpr.innerStride();

	mov	rax, QWORD PTR [rcx+24]
	mov	rdx, QWORD PTR [rax+8]
	mov	QWORD PTR [rcx+32], rdx

; 395  :     }

	ret	0
?init@?$BlockImpl_dense@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@$00@internal@Eigen@@IEAAXXZ ENDP ; Eigen::internal::BlockImpl_dense<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0,1>::init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
;	COMDAT ??0?$MapBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAA@PEAN_J1@Z
_TEXT	SEGMENT
this$ = 48
dataPtr$ = 56
nbRows$ = 64
nbCols$dead$ = 72
??0?$MapBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAA@PEAN_J1@Z PROC ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,1>::MapBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,1>, COMDAT

; 230  :     inline MapBase(PointerType dataPtr, Index nbRows, Index nbCols) : Base(dataPtr, nbRows, nbCols) {}

$LN18:
	push	rbx
	sub	rsp, 32					; 00000020H

; 145  :     {

	mov	QWORD PTR [rcx], rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h

; 63   :     explicit variable_if_dynamic(T value) : m_value(value) {}

	mov	QWORD PTR [rcx+8], r8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 230  :     inline MapBase(PointerType dataPtr, Index nbRows, Index nbCols) : Base(dataPtr, nbRows, nbCols) {}

	mov	rbx, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h

; 63   :     explicit variable_if_dynamic(T value) : m_value(value) {}

	mov	QWORD PTR [rcx+16], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 146  :       eigen_assert( (dataPtr == 0)

	test	rdx, rdx
	je	SHORT $LN15@MapBase
	test	r8, r8
	jns	SHORT $LN15@MapBase
	lea	rdx, OFFSET FLAT:??_C@_1LA@MIDGNIKC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1BGE@MDFDAGNB@?$AA?$CI?$AAd?$AAa?$AAt?$AAa?$AAP?$AAt?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$CJ?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AA?$CI?$AA?5?$AAn?$AAb?$AAR?$AAo?$AAw?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5@
	mov	r8d, 148				; 00000094H
	call	QWORD PTR __imp__wassert
$LN15@MapBase:

; 230  :     inline MapBase(PointerType dataPtr, Index nbRows, Index nbCols) : Base(dataPtr, nbRows, nbCols) {}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$MapBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAA@PEAN_J1@Z ENDP ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,1>::MapBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h
;	COMDAT ?init@?$BlockImpl_dense@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@$00@internal@Eigen@@IEAAXXZ
_TEXT	SEGMENT
this$ = 8
?init@?$BlockImpl_dense@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@$00@internal@Eigen@@IEAAXXZ PROC ; Eigen::internal::BlockImpl_dense<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0,1>::init, COMDAT

; 392  :       m_outerStride = internal::traits<BlockType>::HasSameStorageOrderAsXprType
; 393  :                     ? m_xpr.outerStride()
; 394  :                     : m_xpr.innerStride();

	mov	rax, QWORD PTR [rcx+24]
	mov	rdx, QWORD PTR [rax+8]
	mov	QWORD PTR [rcx+32], rdx

; 395  :     }

	ret	0
?init@?$BlockImpl_dense@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@$00@internal@Eigen@@IEAAXXZ ENDP ; Eigen::internal::BlockImpl_dense<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0,1>::init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
;	COMDAT ??0?$MapBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAA@PEAN_J1@Z
_TEXT	SEGMENT
this$ = 48
dataPtr$ = 56
nbRows$ = 64
nbCols$ = 72
??0?$MapBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAA@PEAN_J1@Z PROC ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,1>::MapBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,1>, COMDAT

; 230  :     inline MapBase(PointerType dataPtr, Index nbRows, Index nbCols) : Base(dataPtr, nbRows, nbCols) {}

$LN18:
	push	rbx
	sub	rsp, 32					; 00000020H

; 145  :     {

	mov	QWORD PTR [rcx], rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h

; 63   :     explicit variable_if_dynamic(T value) : m_value(value) {}

	mov	QWORD PTR [rcx+8], r8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 230  :     inline MapBase(PointerType dataPtr, Index nbRows, Index nbCols) : Base(dataPtr, nbRows, nbCols) {}

	mov	rbx, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h

; 63   :     explicit variable_if_dynamic(T value) : m_value(value) {}

	mov	QWORD PTR [rcx+16], r9
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 146  :       eigen_assert( (dataPtr == 0)

	test	rdx, rdx
	je	SHORT $LN15@MapBase
	test	r8, r8
	js	SHORT $LN5@MapBase
	test	r9, r9
	jns	SHORT $LN15@MapBase
$LN5@MapBase:
	lea	rdx, OFFSET FLAT:??_C@_1LA@MIDGNIKC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1BGE@MDFDAGNB@?$AA?$CI?$AAd?$AAa?$AAt?$AAa?$AAP?$AAt?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$CJ?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AA?$CI?$AA?5?$AAn?$AAb?$AAR?$AAo?$AAw?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5@
	mov	r8d, 148				; 00000094H
	call	QWORD PTR __imp__wassert
$LN15@MapBase:

; 230  :     inline MapBase(PointerType dataPtr, Index nbRows, Index nbCols) : Base(dataPtr, nbRows, nbCols) {}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$MapBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAA@PEAN_J1@Z ENDP ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,1>::MapBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\matrix.h
;	COMDAT ?innerStride@?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$dead$ = 8
?innerStride@?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEBA_JXZ PROC ; Eigen::Matrix<double,-1,-1,0,-1,-1>::innerStride, COMDAT

; 321  :     inline Index innerStride() const { return 1; }

	mov	eax, 1
	ret	0
?innerStride@?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEBA_JXZ ENDP ; Eigen::Matrix<double,-1,-1,0,-1,-1>::innerStride
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
;	COMDAT ??0?$MapBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEAA@PEAN_J1@Z
_TEXT	SEGMENT
this$ = 48
dataPtr$ = 56
nbRows$ = 64
nbCols$dead$ = 72
??0?$MapBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEAA@PEAN_J1@Z PROC ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,0>::MapBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,0>, COMDAT

; 145  :     {

$LN16:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	QWORD PTR [rcx], rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h

; 63   :     explicit variable_if_dynamic(T value) : m_value(value) {}

	mov	QWORD PTR [rcx+8], r8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 145  :     {

	mov	rbx, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h

; 63   :     explicit variable_if_dynamic(T value) : m_value(value) {}

	mov	QWORD PTR [rcx+16], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 146  :       eigen_assert( (dataPtr == 0)

	test	rdx, rdx
	je	SHORT $LN13@MapBase
	test	r8, r8
	jns	SHORT $LN13@MapBase
	lea	rdx, OFFSET FLAT:??_C@_1LA@MIDGNIKC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1BGE@MDFDAGNB@?$AA?$CI?$AAd?$AAa?$AAt?$AAa?$AAP?$AAt?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$CJ?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AA?$CI?$AA?5?$AAn?$AAb?$AAR?$AAo?$AAw?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5@
	mov	r8d, 148				; 00000094H
	call	QWORD PTR __imp__wassert
$LN13@MapBase:

; 147  :               || (   nbRows >= 0 && (RowsAtCompileTime == Dynamic || RowsAtCompileTime == nbRows)
; 148  :                   && nbCols >= 0 && (ColsAtCompileTime == Dynamic || ColsAtCompileTime == nbCols)));
; 149  :       checkSanity();
; 150  :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$MapBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEAA@PEAN_J1@Z ENDP ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,0>::MapBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
;	COMDAT ??0?$MapBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEAA@PEAN_J1@Z
_TEXT	SEGMENT
this$ = 48
dataPtr$ = 56
nbRows$ = 64
nbCols$ = 72
??0?$MapBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEAA@PEAN_J1@Z PROC ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,0>::MapBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,0>, COMDAT

; 145  :     {

$LN16:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	QWORD PTR [rcx], rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h

; 63   :     explicit variable_if_dynamic(T value) : m_value(value) {}

	mov	QWORD PTR [rcx+8], r8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 145  :     {

	mov	rbx, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h

; 63   :     explicit variable_if_dynamic(T value) : m_value(value) {}

	mov	QWORD PTR [rcx+16], r9
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 146  :       eigen_assert( (dataPtr == 0)

	test	rdx, rdx
	je	SHORT $LN13@MapBase
	test	r8, r8
	js	SHORT $LN3@MapBase
	test	r9, r9
	jns	SHORT $LN13@MapBase
$LN3@MapBase:
	lea	rdx, OFFSET FLAT:??_C@_1LA@MIDGNIKC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1BGE@MDFDAGNB@?$AA?$CI?$AAd?$AAa?$AAt?$AAa?$AAP?$AAt?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$CJ?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AA?$CI?$AA?5?$AAn?$AAb?$AAR?$AAo?$AAw?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5@
	mov	r8d, 148				; 00000094H
	call	QWORD PTR __imp__wassert
$LN13@MapBase:

; 147  :               || (   nbRows >= 0 && (RowsAtCompileTime == Dynamic || RowsAtCompileTime == nbRows)
; 148  :                   && nbCols >= 0 && (ColsAtCompileTime == Dynamic || ColsAtCompileTime == nbCols)));
; 149  :       checkSanity();
; 150  :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$MapBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEAA@PEAN_J1@Z ENDP ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,0>::MapBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
;	COMDAT ?checkSanity@?$MapBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@IEBAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?checkSanity@?$MapBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@IEBAXXZ PROC ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,0>::checkSanity, COMDAT

; 156  :       EIGEN_STATIC_ASSERT(EIGEN_IMPLIES(internal::traits<Derived>::Flags&PacketAccessBit,
; 157  :                                         internal::inner_stride_at_compile_time<Derived>::ret==1),
; 158  :                           PACKET_ACCESS_REQUIRES_TO_HAVE_INNER_STRIDE_FIXED_TO_1);
; 159  :       eigen_assert(EIGEN_IMPLIES(internal::traits<Derived>::Flags&AlignedBit, (size_t(m_data) % 16) == 0)
; 160  :                    && "data is not aligned");
; 161  :     }

	ret	0
?checkSanity@?$MapBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@IEBAXXZ ENDP ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,0>::checkSanity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\matrixbase.h
;	COMDAT ??0?$MatrixBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@IEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$MatrixBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@IEAA@XZ PROC ; Eigen::MatrixBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::MatrixBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >, COMDAT

; 494  :     MatrixBase() : Base() {}

	mov	rax, rcx
	ret	0
??0?$MatrixBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@IEAA@XZ ENDP ; Eigen::MatrixBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::MatrixBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
;	COMDAT ?checkSanity@?$MapBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@IEBAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?checkSanity@?$MapBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@IEBAXXZ PROC ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,0>::checkSanity, COMDAT

; 156  :       EIGEN_STATIC_ASSERT(EIGEN_IMPLIES(internal::traits<Derived>::Flags&PacketAccessBit,
; 157  :                                         internal::inner_stride_at_compile_time<Derived>::ret==1),
; 158  :                           PACKET_ACCESS_REQUIRES_TO_HAVE_INNER_STRIDE_FIXED_TO_1);
; 159  :       eigen_assert(EIGEN_IMPLIES(internal::traits<Derived>::Flags&AlignedBit, (size_t(m_data) % 16) == 0)
; 160  :                    && "data is not aligned");
; 161  :     }

	ret	0
?checkSanity@?$MapBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@IEBAXXZ ENDP ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,0>::checkSanity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\matrixbase.h
;	COMDAT ??0?$MatrixBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@IEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$MatrixBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@IEAA@XZ PROC ; Eigen::MatrixBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::MatrixBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >, COMDAT

; 494  :     MatrixBase() : Base() {}

	mov	rax, rcx
	ret	0
??0?$MatrixBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@IEAA@XZ ENDP ; Eigen::MatrixBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::MatrixBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densebase.h
;	COMDAT ??0?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@IEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@IEAA@XZ PROC ; Eigen::DenseBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::DenseBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >, COMDAT

; 504  :     {
; 505  :       /* Just checks for self-consistency of the flags.
; 506  :        * Only do it when debugging Eigen, as this borders on paranoiac and could slow compilation down
; 507  :        */
; 508  : #ifdef EIGEN_INTERNAL_DEBUGGING
; 509  :       EIGEN_STATIC_ASSERT((EIGEN_IMPLIES(MaxRowsAtCompileTime==1 && MaxColsAtCompileTime!=1, int(IsRowMajor))
; 510  :                         && EIGEN_IMPLIES(MaxColsAtCompileTime==1 && MaxRowsAtCompileTime!=1, int(!IsRowMajor))),
; 511  :                           INVALID_STORAGE_ORDER_FOR_THIS_VECTOR_EXPRESSION)
; 512  : #endif
; 513  :     }

	mov	rax, rcx
	ret	0
??0?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@IEAA@XZ ENDP ; Eigen::DenseBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::DenseBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densebase.h
;	COMDAT ??0?$DenseBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@IEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$DenseBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@IEAA@XZ PROC ; Eigen::DenseBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::DenseBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >, COMDAT

; 504  :     {
; 505  :       /* Just checks for self-consistency of the flags.
; 506  :        * Only do it when debugging Eigen, as this borders on paranoiac and could slow compilation down
; 507  :        */
; 508  : #ifdef EIGEN_INTERNAL_DEBUGGING
; 509  :       EIGEN_STATIC_ASSERT((EIGEN_IMPLIES(MaxRowsAtCompileTime==1 && MaxColsAtCompileTime!=1, int(IsRowMajor))
; 510  :                         && EIGEN_IMPLIES(MaxColsAtCompileTime==1 && MaxRowsAtCompileTime!=1, int(!IsRowMajor))),
; 511  :                           INVALID_STORAGE_ORDER_FOR_THIS_VECTOR_EXPRESSION)
; 512  : #endif
; 513  :     }

	mov	rax, rcx
	ret	0
??0?$DenseBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@IEAA@XZ ENDP ; Eigen::DenseBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::DenseBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\matrix.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\matrix.h
;	COMDAT ??$?0V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@AEBV?$MatrixBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
other$ = 72
??$?0V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@AEBV?$MatrixBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z PROC ; Eigen::Matrix<double,-1,1,0,-1,1>::Matrix<double,-1,1,0,-1,1><Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const >,4> >, COMDAT

; 274  :     {

$LN318:
	mov	QWORD PTR [rsp+8], rcx
	push	r14
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+72], rbx
	mov	QWORD PTR [rsp+80], rsi
	mov	QWORD PTR [rsp+88], rdi
	mov	r14, rdx
	mov	rbx, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rax, QWORD PTR [rdx]
	mov	rdi, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 420  :   if(size==0)

	test	rdi, rdi
	jne	SHORT $LN62@Matrix

; 421  :     return 0; // short-cut. Also fixes Bug 884

	xor	eax, eax
	jmp	SHORT $LN63@Matrix
$LN62@Matrix:

; 244  :   #elif EIGEN_HAS_POSIX_MEMALIGN
; 245  :     std::free(ptr);
; 246  :   #elif EIGEN_HAS_MM_MALLOC
; 247  :     _mm_free(ptr);
; 248  :   #elif defined(_MSC_VER) && (!defined(_WIN32_WCE))
; 249  :     _aligned_free(ptr);
; 250  :   #else
; 251  :     handmade_aligned_free(ptr);
; 252  :   #endif
; 253  : }
; 254  : 
; 255  : /**
; 256  : * \internal
; 257  : * \brief Reallocates an aligned block of memory.
; 258  : * \throws std::bad_alloc on allocation failure
; 259  : **/
; 260  : inline void* aligned_realloc(void *ptr, size_t new_size, size_t old_size)
; 261  : {
; 262  :   EIGEN_UNUSED_VARIABLE(old_size);
; 263  : 
; 264  :   void *result;
; 265  : #if !EIGEN_ALIGN
; 266  :   result = std::realloc(ptr,new_size);
; 267  : #elif EIGEN_MALLOC_ALREADY_ALIGNED
; 268  :   result = std::realloc(ptr,new_size);
; 269  : #elif EIGEN_HAS_POSIX_MEMALIGN
; 270  :   result = generic_aligned_realloc(ptr,new_size,old_size);
; 271  : #elif EIGEN_HAS_MM_MALLOC
; 272  :   // The defined(_mm_free) is just here to verify that this MSVC version
; 273  :   // implements _mm_malloc/_mm_free based on the corresponding _aligned_
; 274  :   // functions. This may not always be the case and we just try to be safe.
; 275  :   #if defined(_MSC_VER) && (!defined(_WIN32_WCE)) && defined(_mm_free)
; 276  :     result = _aligned_realloc(ptr,new_size,16);
; 277  :   #else
; 278  :     result = generic_aligned_realloc(ptr,new_size,old_size);
; 279  :   #endif
; 280  : #elif defined(_MSC_VER) && (!defined(_WIN32_WCE))
; 281  :   result = _aligned_realloc(ptr,new_size,16);
; 282  : #else
; 283  :   result = handmade_aligned_realloc(ptr,new_size,old_size);
; 284  : #endif
; 285  : 
; 286  :   if (!result && new_size)
; 287  :     throw_std_bad_alloc();
; 288  : 
; 289  :   return result;
; 290  : }
; 291  : 
; 292  : /*****************************************************************************
; 293  : *** Implementation of conditionally aligned functions                      ***
; 294  : *****************************************************************************/
; 295  : 
; 296  : /** \internal Allocates \a size bytes. If Align is true, then the returned ptr is 16-byte-aligned.
; 297  :   * On allocation error, the returned pointer is null, and a std::bad_alloc is thrown.
; 298  :   */
; 299  : template<bool Align> inline void* conditional_aligned_malloc(size_t size)
; 300  : {
; 301  :   return aligned_malloc(size);
; 302  : }
; 303  : 
; 304  : template<> inline void* conditional_aligned_malloc<false>(size_t size)
; 305  : {
; 306  :   check_that_malloc_is_allowed();
; 307  : 
; 308  :   void *result = std::malloc(size);
; 309  :   if(!result && size)
; 310  :     throw_std_bad_alloc();
; 311  :   return result;
; 312  : }
; 313  : 
; 314  : /** \internal Frees memory allocated with conditional_aligned_malloc */
; 315  : template<bool Align> inline void conditional_aligned_free(void *ptr)
; 316  : {
; 317  :   aligned_free(ptr);
; 318  : }
; 319  : 
; 320  : template<> inline void conditional_aligned_free<false>(void *ptr)
; 321  : {
; 322  :   std::free(ptr);
; 323  : }
; 324  : 
; 325  : template<bool Align> inline void* conditional_aligned_realloc(void* ptr, size_t new_size, size_t old_size)
; 326  : {
; 327  :   return aligned_realloc(ptr, new_size, old_size);
; 328  : }
; 329  : 
; 330  : template<> inline void* conditional_aligned_realloc<false>(void* ptr, size_t new_size, size_t)
; 331  : {
; 332  :   return std::realloc(ptr, new_size);
; 333  : }
; 334  : 
; 335  : /*****************************************************************************
; 336  : *** Construction/destruction of array elements                             ***
; 337  : *****************************************************************************/
; 338  : 
; 339  : /** \internal Constructs the elements of an array.
; 340  :   * The \a size parameter tells on how many objects to call the constructor of T.
; 341  :   */
; 342  : template<typename T> inline T* construct_elements_of_array(T *ptr, size_t size)
; 343  : {
; 344  :   for (size_t i=0; i < size; ++i) ::new (ptr + i) T;
; 345  :   return ptr;
; 346  : }
; 347  : 
; 348  : /** \internal Destructs the elements of an array.
; 349  :   * The \a size parameters tells on how many objects to call the destructor of T.
; 350  :   */
; 351  : template<typename T> inline void destruct_elements_of_array(T *ptr, size_t size)
; 352  : {
; 353  :   // always destruct an array starting from the end.
; 354  :   if(ptr)
; 355  :     while(size) ptr[--size].~T();
; 356  : }
; 357  : 
; 358  : /*****************************************************************************
; 359  : *** Implementation of aligned new/delete-like functions                    ***
; 360  : *****************************************************************************/
; 361  : 
; 362  : template<typename T>
; 363  : EIGEN_ALWAYS_INLINE void check_size_for_overflow(size_t size)
; 364  : {
; 365  :   if(size > size_t(-1) / sizeof(T))

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdi, rax
	jbe	SHORT $LN65@Matrix

; 366  :     throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN65@Matrix:

; 422  :   check_size_for_overflow<T>(size);
; 423  :   T *result = reinterpret_cast<T*>(conditional_aligned_malloc<Align>(sizeof(T)*size));

	lea	rsi, QWORD PTR [rdi*8]

; 220  :     result = std::malloc(size);

	mov	rcx, rsi
	call	QWORD PTR __imp_malloc

; 221  :   #elif EIGEN_HAS_POSIX_MEMALIGN
; 222  :     if(posix_memalign(&result, 16, size)) result = 0;
; 223  :   #elif EIGEN_HAS_MM_MALLOC
; 224  :     result = _mm_malloc(size, 16);
; 225  :   #elif defined(_MSC_VER) && (!defined(_WIN32_WCE))
; 226  :     result = _aligned_malloc(size, 16);
; 227  :   #else
; 228  :     result = handmade_aligned_malloc(size);
; 229  :   #endif
; 230  : 
; 231  :   if(!result && size)

	test	rax, rax
	jne	SHORT $LN63@Matrix
	test	rsi, rsi
	je	SHORT $LN63@Matrix

; 232  :     throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN63@Matrix:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 310  :     { EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN }

	mov	QWORD PTR [rbx], rax
	mov	QWORD PTR [rbx+8], rdi

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rax, QWORD PTR [r14]
	mov	rdi, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	mov	rsi, 9223372036854775807		; 7fffffffffffffffH
	test	rdi, rdi
	je	SHORT $LN316@Matrix
	cmp	rdi, rsi
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN124@Matrix

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN124@Matrix:

; 47   :   }
; 48   : };
; 49   : 
; 50   : template <typename Derived,
; 51   :           typename OtherDerived = Derived,
; 52   :           bool IsVector = bool(Derived::IsVectorAtCompileTime) && bool(OtherDerived::IsVectorAtCompileTime)>
; 53   : struct conservative_resize_like_impl;
; 54   : 
; 55   : template<typename MatrixTypeA, typename MatrixTypeB, bool SwapPointers> struct matrix_swap_impl;
; 56   : 
; 57   : } // end namespace internal
; 58   : 
; 59   : /** \class PlainObjectBase
; 60   :   * \brief %Dense storage base class for matrices and arrays.
; 61   :   *
; 62   :   * This class can be extended with the help of the plugin mechanism described on the page
; 63   :   * \ref TopicCustomizingEigen by defining the preprocessor symbol \c EIGEN_PLAINOBJECTBASE_PLUGIN.
; 64   :   *
; 65   :   * \sa \ref TopicClassHierarchy
; 66   :   */
; 67   : #ifdef EIGEN_PARSED_BY_DOXYGEN
; 68   : namespace internal {
; 69   : 
; 70   : // this is a warkaround to doxygen not being able to understand the inheritence logic
; 71   : // when it is hidden by the dense_xpr_base helper struct.
; 72   : template<typename Derived> struct dense_xpr_base_dispatcher_for_doxygen;// : public MatrixBase<Derived> {};
; 73   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 74   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 75   : struct dense_xpr_base_dispatcher_for_doxygen<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 76   :     : public MatrixBase<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 77   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 78   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 79   : struct dense_xpr_base_dispatcher_for_doxygen<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 80   :     : public ArrayBase<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 81   : 
; 82   : } // namespace internal
; 83   : 
; 84   : template<typename Derived>
; 85   : class PlainObjectBase : public internal::dense_xpr_base_dispatcher_for_doxygen<Derived>
; 86   : #else
; 87   : template<typename Derived>
; 88   : class PlainObjectBase : public internal::dense_xpr_base<Derived>::type
; 89   : #endif
; 90   : {
; 91   :   public:
; 92   :     enum { Options = internal::traits<Derived>::Options };
; 93   :     typedef typename internal::dense_xpr_base<Derived>::type Base;
; 94   : 
; 95   :     typedef typename internal::traits<Derived>::StorageKind StorageKind;
; 96   :     typedef typename internal::traits<Derived>::Index Index;
; 97   :     typedef typename internal::traits<Derived>::Scalar Scalar;
; 98   :     typedef typename internal::packet_traits<Scalar>::type PacketScalar;
; 99   :     typedef typename NumTraits<Scalar>::Real RealScalar;
; 100  :     typedef Derived DenseType;
; 101  : 
; 102  :     using Base::RowsAtCompileTime;
; 103  :     using Base::ColsAtCompileTime;
; 104  :     using Base::SizeAtCompileTime;
; 105  :     using Base::MaxRowsAtCompileTime;
; 106  :     using Base::MaxColsAtCompileTime;
; 107  :     using Base::MaxSizeAtCompileTime;
; 108  :     using Base::IsVectorAtCompileTime;
; 109  :     using Base::Flags;
; 110  : 
; 111  :     template<typename PlainObjectType, int MapOptions, typename StrideType> friend class Eigen::Map;
; 112  :     friend  class Eigen::Map<Derived, Unaligned>;
; 113  :     typedef Eigen::Map<Derived, Unaligned>  MapType;
; 114  :     friend  class Eigen::Map<const Derived, Unaligned>;
; 115  :     typedef const Eigen::Map<const Derived, Unaligned> ConstMapType;
; 116  :     friend  class Eigen::Map<Derived, Aligned>;
; 117  :     typedef Eigen::Map<Derived, Aligned> AlignedMapType;
; 118  :     friend  class Eigen::Map<const Derived, Aligned>;
; 119  :     typedef const Eigen::Map<const Derived, Aligned> ConstAlignedMapType;
; 120  :     template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };
; 121  :     template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };
; 122  :     template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, Aligned, StrideType> type; };
; 123  :     template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, Aligned, StrideType> type; };
; 124  : 
; 125  :   protected:
; 126  :     DenseStorage<Scalar, Base::MaxSizeAtCompileTime, Base::RowsAtCompileTime, Base::ColsAtCompileTime, Options> m_storage;
; 127  : 
; 128  :   public:
; 129  :     enum { NeedsToAlign = SizeAtCompileTime != Dynamic && (internal::traits<Derived>::Flags & AlignedBit) != 0 };
; 130  :     EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(NeedsToAlign)
; 131  : 
; 132  :     Base& base() { return *static_cast<Base*>(this); }
; 133  :     const Base& base() const { return *static_cast<const Base*>(this); }
; 134  : 
; 135  :     EIGEN_STRONG_INLINE Index rows() const { return m_storage.rows(); }
; 136  :     EIGEN_STRONG_INLINE Index cols() const { return m_storage.cols(); }
; 137  : 
; 138  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index rowId, Index colId) const
; 139  :     {
; 140  :       if(Flags & RowMajorBit)
; 141  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 142  :       else // column-major
; 143  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 144  :     }
; 145  : 
; 146  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index index) const
; 147  :     {
; 148  :       return m_storage.data()[index];
; 149  :     }
; 150  : 
; 151  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index rowId, Index colId)
; 152  :     {
; 153  :       if(Flags & RowMajorBit)
; 154  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 155  :       else // column-major
; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 157  :     }
; 158  : 
; 159  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
; 160  :     {
; 161  :       return m_storage.data()[index];
; 162  :     }
; 163  : 
; 164  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
; 165  :     {
; 166  :       if(Flags & RowMajorBit)
; 167  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 168  :       else // column-major
; 169  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 170  :     }
; 171  : 
; 172  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
; 173  :     {
; 174  :       return m_storage.data()[index];
; 175  :     }
; 176  : 
; 177  :     /** \internal */
; 178  :     template<int LoadMode>
; 179  :     EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const
; 180  :     {
; 181  :       return internal::ploadt<PacketScalar, LoadMode>
; 182  :                (m_storage.data() + (Flags & RowMajorBit
; 183  :                                    ? colId + rowId * m_storage.cols()
; 184  :                                    : rowId + colId * m_storage.rows()));
; 185  :     }
; 186  : 
; 187  :     /** \internal */
; 188  :     template<int LoadMode>
; 189  :     EIGEN_STRONG_INLINE PacketScalar packet(Index index) const
; 190  :     {
; 191  :       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);
; 192  :     }
; 193  : 
; 194  :     /** \internal */
; 195  :     template<int StoreMode>
; 196  :     EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)
; 197  :     {
; 198  :       internal::pstoret<Scalar, PacketScalar, StoreMode>
; 199  :               (m_storage.data() + (Flags & RowMajorBit
; 200  :                                    ? colId + rowId * m_storage.cols()
; 201  :                                    : rowId + colId * m_storage.rows()), val);
; 202  :     }
; 203  : 
; 204  :     /** \internal */
; 205  :     template<int StoreMode>
; 206  :     EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
; 207  :     {
; 208  :       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
; 209  :     }
; 210  : 
; 211  :     /** \returns a const pointer to the data array of this matrix */
; 212  :     EIGEN_STRONG_INLINE const Scalar *data() const
; 213  :     { return m_storage.data(); }
; 214  : 
; 215  :     /** \returns a pointer to the data array of this matrix */
; 216  :     EIGEN_STRONG_INLINE Scalar *data()
; 217  :     { return m_storage.data(); }
; 218  : 
; 219  :     /** Resizes \c *this to a \a rows x \a cols matrix.
; 220  :       *
; 221  :       * This method is intended for dynamic-size matrices, although it is legal to call it on any
; 222  :       * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
; 223  :       * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
; 224  :       *
; 225  :       * If the current number of coefficients of \c *this exactly matches the
; 226  :       * product \a rows * \a cols, then no memory allocation is performed and
; 227  :       * the current values are left unchanged. In all other cases, including
; 228  :       * shrinking, the data is reallocated and all previous values are lost.
; 229  :       *
; 230  :       * Example: \include Matrix_resize_int_int.cpp
; 231  :       * Output: \verbinclude Matrix_resize_int_int.out
; 232  :       *
; 233  :       * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
; 234  :       */
; 235  :     EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)
; 236  :     {
; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rdi, rdi
$LN316@Matrix:
	jns	SHORT $LN221@Matrix
	mov	r8d, 241				; 000000f1H
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	call	QWORD PTR __imp__wassert
$LN221@Matrix:

; 44   :                : (rows > max_index / cols);

	test	rdi, rdi
	je	SHORT $LN228@Matrix
	cmp	rdi, rsi
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN228@Matrix

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN228@Matrix:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 322  :       if(size != m_rows*_Cols)

	cmp	rdi, QWORD PTR [rbx+8]
	je	SHORT $LN233@Matrix
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR [rbx]
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 325  :         if (size)

	test	rdi, rdi
	je	SHORT $LN234@Matrix

; 326  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

	mov	rcx, rdi
	call	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
	mov	QWORD PTR [rbx], rax

; 327  :         else

	jmp	SHORT $LN233@Matrix
$LN234@Matrix:

; 328  :           m_data = 0;

	mov	QWORD PTR [rbx], 0
$LN233@Matrix:

; 329  :         EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN
; 330  :       }
; 331  :       m_rows = nbRows;

	mov	QWORD PTR [rbx+8], rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h

; 284  :   other.derived().evalTo(derived());

	mov	rdx, rbx
	mov	rcx, r14
	call	??$evalTo@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEBAXAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@@Z ; Eigen::ProductBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const > >::evalTo<Eigen::Matrix<double,-1,1,0,-1,1> >
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\matrix.h

; 282  :     }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	r14
	ret	0
$LN315@Matrix:
??$?0V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@AEBV?$MatrixBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z ENDP ; Eigen::Matrix<double,-1,1,0,-1,1>::Matrix<double,-1,1,0,-1,1><Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const >,4> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
other$ = 72
?dtor$0@?0???$?0V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@AEBV?$MatrixBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z@4HA PROC ; `Eigen::Matrix<double,-1,1,0,-1,1>::Matrix<double,-1,1,0,-1,1><Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const >,4> >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAA@XZ
?dtor$0@?0???$?0V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@AEBV?$MatrixBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z@4HA ENDP ; `Eigen::Matrix<double,-1,1,0,-1,1>::Matrix<double,-1,1,0,-1,1><Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const >,4> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\igor\igoritx.hpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\igor\igoritx.hpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\igor\igoritx.hpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\igor\igoritx.hpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\igor\igoritx.hpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\igor\igoritx.hpp
;	COMDAT ??$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 64
wavename$GSCopy$ = 72
filename$GSCopy$ = 80
ofs$ = 96
__$ArrayPad$ = 368
data$ = 432
filename$ = 440
wavename$ = 448
precision$dead$ = 456
open_condition$dead$ = 464
??$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z PROC ; IGORdata::write_itx<double,-1,1,0,-1,1>, COMDAT

; 616  : 	{

	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 384				; 00000180H
	mov	QWORD PTR $T2[rsp], -2
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbp, rcx
	mov	QWORD PTR filename$GSCopy$[rsp], rdx
	mov	QWORD PTR wavename$GSCopy$[rsp], r8
	xor	edx, edx
	mov	r8d, 264				; 00000108H
	lea	rcx, QWORD PTR ofs$[rsp]
	call	memset

; 617  : 		std::ofstream ofs;

	lea	rcx, QWORD PTR ofs$[rsp]
	call	??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T1[rsp+24], 15

; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	xor	r14d, r14d
	mov	QWORD PTR $T1[rsp+16], r14
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T1[rsp], r14b
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 726  : 		assign(_Right, 0, npos);

	or	r9, -1
	xor	r8d, r8d
	mov	rdx, rsi
	lea	rcx, QWORD PTR $T1[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\igor\igoritx.hpp

; 619  : 		if (!open(ofs, filename, open_condition)) return false;

	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR ofs$[rsp]
	call	?open@IGORdata@@YA_NAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@W4OpenCondition@1@@Z ; IGORdata::open
	test	al, al
	jne	SHORT $LN3@write_itx
	lea	rcx, QWORD PTR ofs$[rsp+168]
	call	??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_ofstream<char,std::char_traits<char> >::~basic_ofstream<char,std::char_traits<char> >
	lea	rcx, QWORD PTR ofs$[rsp+168]
	call	QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR [rsi+24], 16
	jb	SHORT $LN76@write_itx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR [rsi]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN76@write_itx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rsi+24], 15

; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rsi+16], r14
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rsi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR [rdi+24], 16
	jb	SHORT $LN108@write_itx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR [rdi]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN108@write_itx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\igor\igoritx.hpp

; 619  : 		if (!open(ofs, filename, open_condition)) return false;

	xor	al, al
	jmp	$LN205@write_itx
$LN3@write_itx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 313  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rbx, QWORD PTR [rbp+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\igor\igoritx.hpp

; 623  : 			ofs << "IGOR\nWAVES/D/O/N=(" << data.rows()  << ")\t" << wavename << "\nBEGIN\n";

	lea	rdx, OFFSET FLAT:??_C@_0BD@CEFKJKDD@IGOR?6WAVES?1D?1O?1N?$DN?$CI?$AA@
	lea	rcx, QWORD PTR ofs$[rsp]
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	mov	rdx, rbx
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@_J@Z
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??_C@_02OGOAOAML@?$CJ?7?$AA@
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rcx, rax
	mov	rdx, rdi
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??_C@_07LDIBIHP@?6BEGIN?6?$AA@
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 624  : 		//	matrix case
; 625  : 		else
; 626  : 			ofs << "IGOR\nWAVES/D/O/N=(" << data.rows() << ", " << data.cols() << ")\t" << wavename << "\nBEGIN\n";
; 627  : 
; 628  : 		ofs << data << std::endl;

	mov	rdx, rbp
	lea	rcx, QWORD PTR ofs$[rsp]
	call	??$?6V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV12@AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@0@@Z ; Eigen::operator<<<Eigen::Matrix<double,-1,1,0,-1,1> >
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 629  : 		ofs << "END\n";

	lea	rdx, OFFSET FLAT:??_C@_04FPHJDNED@END?6?$AA@
	lea	rcx, QWORD PTR ofs$[rsp]
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\fstream

; 1097 : 		if (_Filebuffer.close() == 0)

	lea	rcx, QWORD PTR ofs$[rsp+8]
	call	?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
	test	rax, rax
	jne	SHORT $LN136@write_itx

; 1098 : 			_Myios::setstate(ios_base::failbit);

	mov	rax, QWORD PTR ofs$[rsp]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	rcx, QWORD PTR ofs$[rsp+rcx]
	xor	r8d, r8d
	lea	edx, QWORD PTR [r8+2]
	call	QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
	npad	1
$LN136@write_itx:
	lea	rcx, QWORD PTR ofs$[rsp+168]
	call	??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_ofstream<char,std::char_traits<char> >::~basic_ofstream<char,std::char_traits<char> >
	lea	rcx, QWORD PTR ofs$[rsp+168]
	call	QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR [rsi+24], 16
	jb	SHORT $LN161@write_itx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR [rsi]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN161@write_itx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rsi+24], 15

; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rsi+16], r14
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rsi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR [rdi+24], 16
	jb	SHORT $LN193@write_itx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	mov	rcx, QWORD PTR [rdi]
	call	QWORD PTR __imp_??3@YAXPEAX@Z
$LN193@write_itx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\igor\igoritx.hpp

; 631  : 		return true;

	mov	al, 1
$LN205@write_itx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rdi+24], 15

; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rdi+16], r14
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rdi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\igor\igoritx.hpp

; 632  : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 384				; 00000180H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
??$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z ENDP ; IGORdata::write_itx<double,-1,1,0,-1,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 64
wavename$GSCopy$ = 72
filename$GSCopy$ = 80
ofs$ = 96
__$ArrayPad$ = 368
data$ = 432
filename$ = 440
wavename$ = 448
precision$dead$ = 456
open_condition$dead$ = 464
?dtor$0@?0???$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z@4HA PROC ; `IGORdata::write_itx<double,-1,1,0,-1,1>'::`1'::dtor$0
	mov	rcx, QWORD PTR wavename$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z@4HA ENDP ; `IGORdata::write_itx<double,-1,1,0,-1,1>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 64
wavename$GSCopy$ = 72
filename$GSCopy$ = 80
ofs$ = 96
__$ArrayPad$ = 368
data$ = 432
filename$ = 440
wavename$ = 448
precision$dead$ = 456
open_condition$dead$ = 464
?dtor$1@?0???$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z@4HA PROC ; `IGORdata::write_itx<double,-1,1,0,-1,1>'::`1'::dtor$1
	mov	rcx, QWORD PTR filename$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0???$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z@4HA ENDP ; `IGORdata::write_itx<double,-1,1,0,-1,1>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 64
wavename$GSCopy$ = 72
filename$GSCopy$ = 80
ofs$ = 96
__$ArrayPad$ = 368
data$ = 432
filename$ = 440
wavename$ = 448
precision$dead$ = 456
open_condition$dead$ = 464
?dtor$2@?0???$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z@4HA PROC ; `IGORdata::write_itx<double,-1,1,0,-1,1>'::`1'::dtor$2
	lea	rcx, QWORD PTR ofs$[rdx]
	jmp	??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
?dtor$2@?0???$write_itx@N$0?0$00$0A@$0?0$00@IGORdata@@YA_NAEBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1HW4OpenCondition@0@@Z@4HA ENDP ; `IGORdata::write_itx<double,-1,1,0,-1,1>'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\generalproduct.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\generalproduct.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\generalproduct.h
;	COMDAT ??$?DV?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@Eigen@@@?$MatrixBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA?BV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@1@AEBV?$MatrixBase@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
other$ = 64
??$?DV?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@Eigen@@@?$MatrixBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA?BV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@1@AEBV?$MatrixBase@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@Eigen@@@1@@Z PROC ; Eigen::MatrixBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::operator*<Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >, COMDAT

; 572  : {

$LN37:
	push	rbx
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h

; 99   :     {

	mov	QWORD PTR [rdx], rcx
	movups	xmm0, XMMWORD PTR [r8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 307  :     inline DenseStorage() : m_data(0), m_rows(0) {}

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\generalproduct.h

; 572  : {

	mov	rbx, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h

; 99   :     {

	movups	XMMWORD PTR [rdx+8], xmm0
	movsdx	xmm1, QWORD PTR [r8+16]
	movsdx	QWORD PTR [rdx+24], xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 307  :     inline DenseStorage() : m_data(0), m_rows(0) {}

	mov	QWORD PTR [rdx+32], rax
	mov	QWORD PTR [rdx+40], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h

; 100  :       eigen_assert(a_lhs.cols() == a_rhs.rows()

	mov	rax, QWORD PTR [r8+8]
	mov	rdx, QWORD PTR [rax+8]
	cmp	QWORD PTR [rcx+16], rdx
	je	SHORT $LN35@operator
	lea	rdx, OFFSET FLAT:??_C@_1LI@OBICGMAP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1BCA@DNDIGDNN@?$AAa?$AA_?$AAl?$AAh?$AAs?$AA?4?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAa?$AA_?$AAr?$AAh?$AAs?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5@
	mov	r8d, 102				; 00000066H
	call	QWORD PTR __imp__wassert
$LN35@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\generalproduct.h

; 595  :   return typename ProductReturnType<Derived,OtherDerived>::Type(derived(), other.derived());

	mov	rax, rbx

; 596  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$?DV?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@Eigen@@@?$MatrixBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA?BV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@1@AEBV?$MatrixBase@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@Eigen@@@1@@Z ENDP ; Eigen::MatrixBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::operator*<Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\matrix.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\matrix.h
;	COMDAT ??$?0V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@AEBV?$MatrixBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
other$ = 72
??$?0V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@AEBV?$MatrixBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z PROC ; Eigen::Matrix<double,-1,1,0,-1,1>::Matrix<double,-1,1,0,-1,1><Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4> >, COMDAT

; 274  :     {

$LN318:
	mov	QWORD PTR [rsp+8], rcx
	push	r14
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+72], rbx
	mov	QWORD PTR [rsp+80], rsi
	mov	QWORD PTR [rsp+88], rdi
	mov	r14, rdx
	mov	rbx, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rax, QWORD PTR [rdx]
	mov	rdi, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 420  :   if(size==0)

	test	rdi, rdi
	jne	SHORT $LN62@Matrix

; 421  :     return 0; // short-cut. Also fixes Bug 884

	xor	eax, eax
	jmp	SHORT $LN63@Matrix
$LN62@Matrix:

; 244  :   #elif EIGEN_HAS_POSIX_MEMALIGN
; 245  :     std::free(ptr);
; 246  :   #elif EIGEN_HAS_MM_MALLOC
; 247  :     _mm_free(ptr);
; 248  :   #elif defined(_MSC_VER) && (!defined(_WIN32_WCE))
; 249  :     _aligned_free(ptr);
; 250  :   #else
; 251  :     handmade_aligned_free(ptr);
; 252  :   #endif
; 253  : }
; 254  : 
; 255  : /**
; 256  : * \internal
; 257  : * \brief Reallocates an aligned block of memory.
; 258  : * \throws std::bad_alloc on allocation failure
; 259  : **/
; 260  : inline void* aligned_realloc(void *ptr, size_t new_size, size_t old_size)
; 261  : {
; 262  :   EIGEN_UNUSED_VARIABLE(old_size);
; 263  : 
; 264  :   void *result;
; 265  : #if !EIGEN_ALIGN
; 266  :   result = std::realloc(ptr,new_size);
; 267  : #elif EIGEN_MALLOC_ALREADY_ALIGNED
; 268  :   result = std::realloc(ptr,new_size);
; 269  : #elif EIGEN_HAS_POSIX_MEMALIGN
; 270  :   result = generic_aligned_realloc(ptr,new_size,old_size);
; 271  : #elif EIGEN_HAS_MM_MALLOC
; 272  :   // The defined(_mm_free) is just here to verify that this MSVC version
; 273  :   // implements _mm_malloc/_mm_free based on the corresponding _aligned_
; 274  :   // functions. This may not always be the case and we just try to be safe.
; 275  :   #if defined(_MSC_VER) && (!defined(_WIN32_WCE)) && defined(_mm_free)
; 276  :     result = _aligned_realloc(ptr,new_size,16);
; 277  :   #else
; 278  :     result = generic_aligned_realloc(ptr,new_size,old_size);
; 279  :   #endif
; 280  : #elif defined(_MSC_VER) && (!defined(_WIN32_WCE))
; 281  :   result = _aligned_realloc(ptr,new_size,16);
; 282  : #else
; 283  :   result = handmade_aligned_realloc(ptr,new_size,old_size);
; 284  : #endif
; 285  : 
; 286  :   if (!result && new_size)
; 287  :     throw_std_bad_alloc();
; 288  : 
; 289  :   return result;
; 290  : }
; 291  : 
; 292  : /*****************************************************************************
; 293  : *** Implementation of conditionally aligned functions                      ***
; 294  : *****************************************************************************/
; 295  : 
; 296  : /** \internal Allocates \a size bytes. If Align is true, then the returned ptr is 16-byte-aligned.
; 297  :   * On allocation error, the returned pointer is null, and a std::bad_alloc is thrown.
; 298  :   */
; 299  : template<bool Align> inline void* conditional_aligned_malloc(size_t size)
; 300  : {
; 301  :   return aligned_malloc(size);
; 302  : }
; 303  : 
; 304  : template<> inline void* conditional_aligned_malloc<false>(size_t size)
; 305  : {
; 306  :   check_that_malloc_is_allowed();
; 307  : 
; 308  :   void *result = std::malloc(size);
; 309  :   if(!result && size)
; 310  :     throw_std_bad_alloc();
; 311  :   return result;
; 312  : }
; 313  : 
; 314  : /** \internal Frees memory allocated with conditional_aligned_malloc */
; 315  : template<bool Align> inline void conditional_aligned_free(void *ptr)
; 316  : {
; 317  :   aligned_free(ptr);
; 318  : }
; 319  : 
; 320  : template<> inline void conditional_aligned_free<false>(void *ptr)
; 321  : {
; 322  :   std::free(ptr);
; 323  : }
; 324  : 
; 325  : template<bool Align> inline void* conditional_aligned_realloc(void* ptr, size_t new_size, size_t old_size)
; 326  : {
; 327  :   return aligned_realloc(ptr, new_size, old_size);
; 328  : }
; 329  : 
; 330  : template<> inline void* conditional_aligned_realloc<false>(void* ptr, size_t new_size, size_t)
; 331  : {
; 332  :   return std::realloc(ptr, new_size);
; 333  : }
; 334  : 
; 335  : /*****************************************************************************
; 336  : *** Construction/destruction of array elements                             ***
; 337  : *****************************************************************************/
; 338  : 
; 339  : /** \internal Constructs the elements of an array.
; 340  :   * The \a size parameter tells on how many objects to call the constructor of T.
; 341  :   */
; 342  : template<typename T> inline T* construct_elements_of_array(T *ptr, size_t size)
; 343  : {
; 344  :   for (size_t i=0; i < size; ++i) ::new (ptr + i) T;
; 345  :   return ptr;
; 346  : }
; 347  : 
; 348  : /** \internal Destructs the elements of an array.
; 349  :   * The \a size parameters tells on how many objects to call the destructor of T.
; 350  :   */
; 351  : template<typename T> inline void destruct_elements_of_array(T *ptr, size_t size)
; 352  : {
; 353  :   // always destruct an array starting from the end.
; 354  :   if(ptr)
; 355  :     while(size) ptr[--size].~T();
; 356  : }
; 357  : 
; 358  : /*****************************************************************************
; 359  : *** Implementation of aligned new/delete-like functions                    ***
; 360  : *****************************************************************************/
; 361  : 
; 362  : template<typename T>
; 363  : EIGEN_ALWAYS_INLINE void check_size_for_overflow(size_t size)
; 364  : {
; 365  :   if(size > size_t(-1) / sizeof(T))

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdi, rax
	jbe	SHORT $LN65@Matrix

; 366  :     throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN65@Matrix:

; 422  :   check_size_for_overflow<T>(size);
; 423  :   T *result = reinterpret_cast<T*>(conditional_aligned_malloc<Align>(sizeof(T)*size));

	lea	rsi, QWORD PTR [rdi*8]

; 220  :     result = std::malloc(size);

	mov	rcx, rsi
	call	QWORD PTR __imp_malloc

; 221  :   #elif EIGEN_HAS_POSIX_MEMALIGN
; 222  :     if(posix_memalign(&result, 16, size)) result = 0;
; 223  :   #elif EIGEN_HAS_MM_MALLOC
; 224  :     result = _mm_malloc(size, 16);
; 225  :   #elif defined(_MSC_VER) && (!defined(_WIN32_WCE))
; 226  :     result = _aligned_malloc(size, 16);
; 227  :   #else
; 228  :     result = handmade_aligned_malloc(size);
; 229  :   #endif
; 230  : 
; 231  :   if(!result && size)

	test	rax, rax
	jne	SHORT $LN63@Matrix
	test	rsi, rsi
	je	SHORT $LN63@Matrix

; 232  :     throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN63@Matrix:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 310  :     { EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN }

	mov	QWORD PTR [rbx], rax
	mov	QWORD PTR [rbx+8], rdi

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rax, QWORD PTR [r14]
	mov	rdi, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	mov	rsi, 9223372036854775807		; 7fffffffffffffffH
	test	rdi, rdi
	je	SHORT $LN316@Matrix
	cmp	rdi, rsi
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN124@Matrix

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN124@Matrix:

; 47   :   }
; 48   : };
; 49   : 
; 50   : template <typename Derived,
; 51   :           typename OtherDerived = Derived,
; 52   :           bool IsVector = bool(Derived::IsVectorAtCompileTime) && bool(OtherDerived::IsVectorAtCompileTime)>
; 53   : struct conservative_resize_like_impl;
; 54   : 
; 55   : template<typename MatrixTypeA, typename MatrixTypeB, bool SwapPointers> struct matrix_swap_impl;
; 56   : 
; 57   : } // end namespace internal
; 58   : 
; 59   : /** \class PlainObjectBase
; 60   :   * \brief %Dense storage base class for matrices and arrays.
; 61   :   *
; 62   :   * This class can be extended with the help of the plugin mechanism described on the page
; 63   :   * \ref TopicCustomizingEigen by defining the preprocessor symbol \c EIGEN_PLAINOBJECTBASE_PLUGIN.
; 64   :   *
; 65   :   * \sa \ref TopicClassHierarchy
; 66   :   */
; 67   : #ifdef EIGEN_PARSED_BY_DOXYGEN
; 68   : namespace internal {
; 69   : 
; 70   : // this is a warkaround to doxygen not being able to understand the inheritence logic
; 71   : // when it is hidden by the dense_xpr_base helper struct.
; 72   : template<typename Derived> struct dense_xpr_base_dispatcher_for_doxygen;// : public MatrixBase<Derived> {};
; 73   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 74   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 75   : struct dense_xpr_base_dispatcher_for_doxygen<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 76   :     : public MatrixBase<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 77   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 78   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 79   : struct dense_xpr_base_dispatcher_for_doxygen<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 80   :     : public ArrayBase<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 81   : 
; 82   : } // namespace internal
; 83   : 
; 84   : template<typename Derived>
; 85   : class PlainObjectBase : public internal::dense_xpr_base_dispatcher_for_doxygen<Derived>
; 86   : #else
; 87   : template<typename Derived>
; 88   : class PlainObjectBase : public internal::dense_xpr_base<Derived>::type
; 89   : #endif
; 90   : {
; 91   :   public:
; 92   :     enum { Options = internal::traits<Derived>::Options };
; 93   :     typedef typename internal::dense_xpr_base<Derived>::type Base;
; 94   : 
; 95   :     typedef typename internal::traits<Derived>::StorageKind StorageKind;
; 96   :     typedef typename internal::traits<Derived>::Index Index;
; 97   :     typedef typename internal::traits<Derived>::Scalar Scalar;
; 98   :     typedef typename internal::packet_traits<Scalar>::type PacketScalar;
; 99   :     typedef typename NumTraits<Scalar>::Real RealScalar;
; 100  :     typedef Derived DenseType;
; 101  : 
; 102  :     using Base::RowsAtCompileTime;
; 103  :     using Base::ColsAtCompileTime;
; 104  :     using Base::SizeAtCompileTime;
; 105  :     using Base::MaxRowsAtCompileTime;
; 106  :     using Base::MaxColsAtCompileTime;
; 107  :     using Base::MaxSizeAtCompileTime;
; 108  :     using Base::IsVectorAtCompileTime;
; 109  :     using Base::Flags;
; 110  : 
; 111  :     template<typename PlainObjectType, int MapOptions, typename StrideType> friend class Eigen::Map;
; 112  :     friend  class Eigen::Map<Derived, Unaligned>;
; 113  :     typedef Eigen::Map<Derived, Unaligned>  MapType;
; 114  :     friend  class Eigen::Map<const Derived, Unaligned>;
; 115  :     typedef const Eigen::Map<const Derived, Unaligned> ConstMapType;
; 116  :     friend  class Eigen::Map<Derived, Aligned>;
; 117  :     typedef Eigen::Map<Derived, Aligned> AlignedMapType;
; 118  :     friend  class Eigen::Map<const Derived, Aligned>;
; 119  :     typedef const Eigen::Map<const Derived, Aligned> ConstAlignedMapType;
; 120  :     template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };
; 121  :     template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };
; 122  :     template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, Aligned, StrideType> type; };
; 123  :     template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, Aligned, StrideType> type; };
; 124  : 
; 125  :   protected:
; 126  :     DenseStorage<Scalar, Base::MaxSizeAtCompileTime, Base::RowsAtCompileTime, Base::ColsAtCompileTime, Options> m_storage;
; 127  : 
; 128  :   public:
; 129  :     enum { NeedsToAlign = SizeAtCompileTime != Dynamic && (internal::traits<Derived>::Flags & AlignedBit) != 0 };
; 130  :     EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(NeedsToAlign)
; 131  : 
; 132  :     Base& base() { return *static_cast<Base*>(this); }
; 133  :     const Base& base() const { return *static_cast<const Base*>(this); }
; 134  : 
; 135  :     EIGEN_STRONG_INLINE Index rows() const { return m_storage.rows(); }
; 136  :     EIGEN_STRONG_INLINE Index cols() const { return m_storage.cols(); }
; 137  : 
; 138  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index rowId, Index colId) const
; 139  :     {
; 140  :       if(Flags & RowMajorBit)
; 141  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 142  :       else // column-major
; 143  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 144  :     }
; 145  : 
; 146  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index index) const
; 147  :     {
; 148  :       return m_storage.data()[index];
; 149  :     }
; 150  : 
; 151  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index rowId, Index colId)
; 152  :     {
; 153  :       if(Flags & RowMajorBit)
; 154  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 155  :       else // column-major
; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 157  :     }
; 158  : 
; 159  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
; 160  :     {
; 161  :       return m_storage.data()[index];
; 162  :     }
; 163  : 
; 164  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
; 165  :     {
; 166  :       if(Flags & RowMajorBit)
; 167  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 168  :       else // column-major
; 169  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 170  :     }
; 171  : 
; 172  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
; 173  :     {
; 174  :       return m_storage.data()[index];
; 175  :     }
; 176  : 
; 177  :     /** \internal */
; 178  :     template<int LoadMode>
; 179  :     EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const
; 180  :     {
; 181  :       return internal::ploadt<PacketScalar, LoadMode>
; 182  :                (m_storage.data() + (Flags & RowMajorBit
; 183  :                                    ? colId + rowId * m_storage.cols()
; 184  :                                    : rowId + colId * m_storage.rows()));
; 185  :     }
; 186  : 
; 187  :     /** \internal */
; 188  :     template<int LoadMode>
; 189  :     EIGEN_STRONG_INLINE PacketScalar packet(Index index) const
; 190  :     {
; 191  :       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);
; 192  :     }
; 193  : 
; 194  :     /** \internal */
; 195  :     template<int StoreMode>
; 196  :     EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)
; 197  :     {
; 198  :       internal::pstoret<Scalar, PacketScalar, StoreMode>
; 199  :               (m_storage.data() + (Flags & RowMajorBit
; 200  :                                    ? colId + rowId * m_storage.cols()
; 201  :                                    : rowId + colId * m_storage.rows()), val);
; 202  :     }
; 203  : 
; 204  :     /** \internal */
; 205  :     template<int StoreMode>
; 206  :     EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
; 207  :     {
; 208  :       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
; 209  :     }
; 210  : 
; 211  :     /** \returns a const pointer to the data array of this matrix */
; 212  :     EIGEN_STRONG_INLINE const Scalar *data() const
; 213  :     { return m_storage.data(); }
; 214  : 
; 215  :     /** \returns a pointer to the data array of this matrix */
; 216  :     EIGEN_STRONG_INLINE Scalar *data()
; 217  :     { return m_storage.data(); }
; 218  : 
; 219  :     /** Resizes \c *this to a \a rows x \a cols matrix.
; 220  :       *
; 221  :       * This method is intended for dynamic-size matrices, although it is legal to call it on any
; 222  :       * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
; 223  :       * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
; 224  :       *
; 225  :       * If the current number of coefficients of \c *this exactly matches the
; 226  :       * product \a rows * \a cols, then no memory allocation is performed and
; 227  :       * the current values are left unchanged. In all other cases, including
; 228  :       * shrinking, the data is reallocated and all previous values are lost.
; 229  :       *
; 230  :       * Example: \include Matrix_resize_int_int.cpp
; 231  :       * Output: \verbinclude Matrix_resize_int_int.out
; 232  :       *
; 233  :       * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
; 234  :       */
; 235  :     EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)
; 236  :     {
; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rdi, rdi
$LN316@Matrix:
	jns	SHORT $LN221@Matrix
	mov	r8d, 241				; 000000f1H
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	call	QWORD PTR __imp__wassert
$LN221@Matrix:

; 44   :                : (rows > max_index / cols);

	test	rdi, rdi
	je	SHORT $LN228@Matrix
	cmp	rdi, rsi
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN228@Matrix

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN228@Matrix:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 322  :       if(size != m_rows*_Cols)

	cmp	rdi, QWORD PTR [rbx+8]
	je	SHORT $LN233@Matrix
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR [rbx]
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 325  :         if (size)

	test	rdi, rdi
	je	SHORT $LN234@Matrix

; 326  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

	mov	rcx, rdi
	call	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
	mov	QWORD PTR [rbx], rax

; 327  :         else

	jmp	SHORT $LN233@Matrix
$LN234@Matrix:

; 328  :           m_data = 0;

	mov	QWORD PTR [rbx], 0
$LN233@Matrix:

; 329  :         EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN
; 330  :       }
; 331  :       m_rows = nbRows;

	mov	QWORD PTR [rbx+8], rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h

; 284  :   other.derived().evalTo(derived());

	mov	rdx, rbx
	mov	rcx, r14
	call	??$evalTo@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEBAXAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@@Z ; Eigen::ProductBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >::evalTo<Eigen::Matrix<double,-1,1,0,-1,1> >
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\matrix.h

; 282  :     }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	r14
	ret	0
$LN315@Matrix:
??$?0V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@AEBV?$MatrixBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z ENDP ; Eigen::Matrix<double,-1,1,0,-1,1>::Matrix<double,-1,1,0,-1,1><Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
other$ = 72
?dtor$0@?0???$?0V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@AEBV?$MatrixBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z@4HA PROC ; `Eigen::Matrix<double,-1,1,0,-1,1>::Matrix<double,-1,1,0,-1,1><Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4> >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAA@XZ
?dtor$0@?0???$?0V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@AEBV?$MatrixBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z@4HA ENDP ; `Eigen::Matrix<double,-1,1,0,-1,1>::Matrix<double,-1,1,0,-1,1><Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\matrix.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\matrix.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\matrix.h
;	COMDAT ??$?4V?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAAAEAV01@AEBV?$MatrixBase@V?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 64
other$ = 72
??$?4V?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAAAEAV01@AEBV?$MatrixBase@V?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@@1@@Z PROC ; Eigen::Matrix<double,-1,1,0,-1,1>::operator=<Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>,Eigen::ReturnByValue<Eigen::internal::solve_retval_base<Eigen::PartialPivLU<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::Matrix<double,-1,1,0,-1,1> > > const > >, COMDAT

; 170  :     EIGEN_STRONG_INLINE Matrix& operator=(const MatrixBase<OtherDerived>& other)

$LN382:
	push	rbx
	push	rbp
	push	rsi
	sub	rsp, 32					; 00000020H
	mov	rsi, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	test	rdx, rdx
	je	SHORT $LN17@operator
	lea	rax, QWORD PTR [rdx-1]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 606  :     EIGEN_STRONG_INLINE void _set_selector(const OtherDerived& other, const internal::false_type&) { _set_noalias(other); }

	test	rax, rax
	je	SHORT $LN17@operator
	inc	rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	je	SHORT $LN17@operator
	dec	rax
	jmp	SHORT $LN18@operator
$LN17@operator:
	xor	eax, eax
$LN18@operator:
	mov	QWORD PTR [rsp+80], rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 520  :   static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }

	inc	rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	je	SHORT $LN23@operator
	lea	rdi, QWORD PTR [rax-1]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 520  :   static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }

	test	rdi, rdi
	je	SHORT $LN23@operator
	inc	rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	je	SHORT $LN45@operator
	lea	rbx, QWORD PTR [rdi-1]
	jmp	SHORT $LN46@operator
$LN23@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 520  :   static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }

	xor	edi, edi
$LN45@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	xor	ebx, ebx
$LN46@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 313  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rbx, QWORD PTR [rbx+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	mov	rbp, 9223372036854775807		; 7fffffffffffffffH
	test	rbx, rbx
	je	SHORT $LN377@operator
	cmp	rbx, rbp
	setg	al

; 45   :     if (error)

	test	al, al
	jne	$LN379@operator

; 47   :   }
; 48   : };
; 49   : 
; 50   : template <typename Derived,
; 51   :           typename OtherDerived = Derived,
; 52   :           bool IsVector = bool(Derived::IsVectorAtCompileTime) && bool(OtherDerived::IsVectorAtCompileTime)>
; 53   : struct conservative_resize_like_impl;
; 54   : 
; 55   : template<typename MatrixTypeA, typename MatrixTypeB, bool SwapPointers> struct matrix_swap_impl;
; 56   : 
; 57   : } // end namespace internal
; 58   : 
; 59   : /** \class PlainObjectBase
; 60   :   * \brief %Dense storage base class for matrices and arrays.
; 61   :   *
; 62   :   * This class can be extended with the help of the plugin mechanism described on the page
; 63   :   * \ref TopicCustomizingEigen by defining the preprocessor symbol \c EIGEN_PLAINOBJECTBASE_PLUGIN.
; 64   :   *
; 65   :   * \sa \ref TopicClassHierarchy
; 66   :   */
; 67   : #ifdef EIGEN_PARSED_BY_DOXYGEN
; 68   : namespace internal {
; 69   : 
; 70   : // this is a warkaround to doxygen not being able to understand the inheritence logic
; 71   : // when it is hidden by the dense_xpr_base helper struct.
; 72   : template<typename Derived> struct dense_xpr_base_dispatcher_for_doxygen;// : public MatrixBase<Derived> {};
; 73   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 74   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 75   : struct dense_xpr_base_dispatcher_for_doxygen<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 76   :     : public MatrixBase<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 77   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 78   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 79   : struct dense_xpr_base_dispatcher_for_doxygen<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 80   :     : public ArrayBase<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 81   : 
; 82   : } // namespace internal
; 83   : 
; 84   : template<typename Derived>
; 85   : class PlainObjectBase : public internal::dense_xpr_base_dispatcher_for_doxygen<Derived>
; 86   : #else
; 87   : template<typename Derived>
; 88   : class PlainObjectBase : public internal::dense_xpr_base<Derived>::type
; 89   : #endif
; 90   : {
; 91   :   public:
; 92   :     enum { Options = internal::traits<Derived>::Options };
; 93   :     typedef typename internal::dense_xpr_base<Derived>::type Base;
; 94   : 
; 95   :     typedef typename internal::traits<Derived>::StorageKind StorageKind;
; 96   :     typedef typename internal::traits<Derived>::Index Index;
; 97   :     typedef typename internal::traits<Derived>::Scalar Scalar;
; 98   :     typedef typename internal::packet_traits<Scalar>::type PacketScalar;
; 99   :     typedef typename NumTraits<Scalar>::Real RealScalar;
; 100  :     typedef Derived DenseType;
; 101  : 
; 102  :     using Base::RowsAtCompileTime;
; 103  :     using Base::ColsAtCompileTime;
; 104  :     using Base::SizeAtCompileTime;
; 105  :     using Base::MaxRowsAtCompileTime;
; 106  :     using Base::MaxColsAtCompileTime;
; 107  :     using Base::MaxSizeAtCompileTime;
; 108  :     using Base::IsVectorAtCompileTime;
; 109  :     using Base::Flags;
; 110  : 
; 111  :     template<typename PlainObjectType, int MapOptions, typename StrideType> friend class Eigen::Map;
; 112  :     friend  class Eigen::Map<Derived, Unaligned>;
; 113  :     typedef Eigen::Map<Derived, Unaligned>  MapType;
; 114  :     friend  class Eigen::Map<const Derived, Unaligned>;
; 115  :     typedef const Eigen::Map<const Derived, Unaligned> ConstMapType;
; 116  :     friend  class Eigen::Map<Derived, Aligned>;
; 117  :     typedef Eigen::Map<Derived, Aligned> AlignedMapType;
; 118  :     friend  class Eigen::Map<const Derived, Aligned>;
; 119  :     typedef const Eigen::Map<const Derived, Aligned> ConstAlignedMapType;
; 120  :     template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };
; 121  :     template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };
; 122  :     template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, Aligned, StrideType> type; };
; 123  :     template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, Aligned, StrideType> type; };
; 124  : 
; 125  :   protected:
; 126  :     DenseStorage<Scalar, Base::MaxSizeAtCompileTime, Base::RowsAtCompileTime, Base::ColsAtCompileTime, Options> m_storage;
; 127  : 
; 128  :   public:
; 129  :     enum { NeedsToAlign = SizeAtCompileTime != Dynamic && (internal::traits<Derived>::Flags & AlignedBit) != 0 };
; 130  :     EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(NeedsToAlign)
; 131  : 
; 132  :     Base& base() { return *static_cast<Base*>(this); }
; 133  :     const Base& base() const { return *static_cast<const Base*>(this); }
; 134  : 
; 135  :     EIGEN_STRONG_INLINE Index rows() const { return m_storage.rows(); }
; 136  :     EIGEN_STRONG_INLINE Index cols() const { return m_storage.cols(); }
; 137  : 
; 138  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index rowId, Index colId) const
; 139  :     {
; 140  :       if(Flags & RowMajorBit)
; 141  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 142  :       else // column-major
; 143  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 144  :     }
; 145  : 
; 146  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index index) const
; 147  :     {
; 148  :       return m_storage.data()[index];
; 149  :     }
; 150  : 
; 151  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index rowId, Index colId)
; 152  :     {
; 153  :       if(Flags & RowMajorBit)
; 154  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 155  :       else // column-major
; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 157  :     }
; 158  : 
; 159  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
; 160  :     {
; 161  :       return m_storage.data()[index];
; 162  :     }
; 163  : 
; 164  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
; 165  :     {
; 166  :       if(Flags & RowMajorBit)
; 167  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 168  :       else // column-major
; 169  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 170  :     }
; 171  : 
; 172  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
; 173  :     {
; 174  :       return m_storage.data()[index];
; 175  :     }
; 176  : 
; 177  :     /** \internal */
; 178  :     template<int LoadMode>
; 179  :     EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const
; 180  :     {
; 181  :       return internal::ploadt<PacketScalar, LoadMode>
; 182  :                (m_storage.data() + (Flags & RowMajorBit
; 183  :                                    ? colId + rowId * m_storage.cols()
; 184  :                                    : rowId + colId * m_storage.rows()));
; 185  :     }
; 186  : 
; 187  :     /** \internal */
; 188  :     template<int LoadMode>
; 189  :     EIGEN_STRONG_INLINE PacketScalar packet(Index index) const
; 190  :     {
; 191  :       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);
; 192  :     }
; 193  : 
; 194  :     /** \internal */
; 195  :     template<int StoreMode>
; 196  :     EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)
; 197  :     {
; 198  :       internal::pstoret<Scalar, PacketScalar, StoreMode>
; 199  :               (m_storage.data() + (Flags & RowMajorBit
; 200  :                                    ? colId + rowId * m_storage.cols()
; 201  :                                    : rowId + colId * m_storage.rows()), val);
; 202  :     }
; 203  : 
; 204  :     /** \internal */
; 205  :     template<int StoreMode>
; 206  :     EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
; 207  :     {
; 208  :       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
; 209  :     }
; 210  : 
; 211  :     /** \returns a const pointer to the data array of this matrix */
; 212  :     EIGEN_STRONG_INLINE const Scalar *data() const
; 213  :     { return m_storage.data(); }
; 214  : 
; 215  :     /** \returns a pointer to the data array of this matrix */
; 216  :     EIGEN_STRONG_INLINE Scalar *data()
; 217  :     { return m_storage.data(); }
; 218  : 
; 219  :     /** Resizes \c *this to a \a rows x \a cols matrix.
; 220  :       *
; 221  :       * This method is intended for dynamic-size matrices, although it is legal to call it on any
; 222  :       * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
; 223  :       * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
; 224  :       *
; 225  :       * If the current number of coefficients of \c *this exactly matches the
; 226  :       * product \a rows * \a cols, then no memory allocation is performed and
; 227  :       * the current values are left unchanged. In all other cases, including
; 228  :       * shrinking, the data is reallocated and all previous values are lost.
; 229  :       *
; 230  :       * Example: \include Matrix_resize_int_int.cpp
; 231  :       * Output: \verbinclude Matrix_resize_int_int.out
; 232  :       *
; 233  :       * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
; 234  :       */
; 235  :     EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)
; 236  :     {
; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rbx, rbx
$LN377@operator:
	jns	SHORT $LN138@operator
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	mov	r8d, 241				; 000000f1H
	call	QWORD PTR __imp__wassert
$LN138@operator:

; 44   :                : (rows > max_index / cols);

	test	rbx, rbx
	je	SHORT $LN145@operator
	cmp	rbx, rbp
	setg	al

; 45   :     if (error)

	test	al, al
	jne	$LN381@operator
$LN145@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 322  :       if(size != m_rows*_Cols)

	cmp	rbx, QWORD PTR [rsi+8]
	je	SHORT $LN150@operator
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR [rsi]
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 325  :         if (size)

	test	rbx, rbx
	je	SHORT $LN151@operator

; 326  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

	mov	rcx, rbx
	call	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
	mov	QWORD PTR [rsi], rax

; 327  :         else

	jmp	SHORT $LN150@operator
$LN151@operator:

; 328  :           m_data = 0;

	mov	QWORD PTR [rsi], 0
$LN150@operator:

; 329  :         EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN
; 330  :       }
; 331  :       m_rows = nbRows;

	mov	QWORD PTR [rsi+8], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	test	rdi, rdi
	je	SHORT $LN31@operator
	dec	rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 414  :       return Base::lazyAssign(other.derived());

	je	SHORT $LN31@operator
	inc	rdi
	jmp	SHORT $LN32@operator
$LN31@operator:
	xor	edi, edi
$LN32@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	test	rdi, rdi
	je	SHORT $LN234@operator
	lea	rax, QWORD PTR [rdi-1]
	jmp	SHORT $LN235@operator
$LN234@operator:
	xor	eax, eax
$LN235@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	cmp	rbx, QWORD PTR [rax+16]
	je	SHORT $LN221@operator
	lea	rdx, OFFSET FLAT:??_C@_1KO@HDGCFKMN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GC@PBCDNLIH@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ@
	mov	r8d, 498				; 000001f2H
	call	QWORD PTR __imp__wassert
$LN221@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	test	rdi, rdi
	je	SHORT $LN264@operator
	lea	rcx, QWORD PTR [rdi-1]
	jmp	SHORT $LN265@operator
$LN264@operator:
	xor	ecx, ecx
$LN265@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 395  :     const Index size = dst.size();

	mov	r11, QWORD PTR [rsi+8]

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	xor	r9d, r9d
	mov	rax, r11
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r10, rax
	add	r10, r10
	test	r10, r10
	jle	SHORT $LN268@operator
	movdqa	xmm1, XMMWORD PTR __xmm@80000000000000008000000000000000
$LL270@operator:

; 409  :     {
; 410  :       dst.template copyPacket<Derived2, dstAlignment, srcAlignment>(index, src);

	test	rcx, rcx
	je	SHORT $LN313@operator
	lea	rax, QWORD PTR [rcx+1]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	test	rax, rax
	je	SHORT $LN313@operator
	dec	rax
	jmp	SHORT $LN314@operator
$LN313@operator:
	xor	eax, eax
$LN314@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 538  :         other.derived().template packet<LoadMode>(index));

	inc	rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	je	SHORT $LN319@operator
	lea	r8, QWORD PTR [rax-1]
	jmp	SHORT $LN320@operator
$LN319@operator:
	xor	r8d, r8d
$LN320@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	mov	rax, QWORD PTR [rsi]
	lea	rdx, QWORD PTR [rax+r9*8]
	mov	rax, QWORD PTR [r8+8]
	add	r9, 2
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 220  : template<> EIGEN_STRONG_INLINE Packet2d pload<Packet2d>(const double*  from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_pd(from); }

	movaps	xmm0, XMMWORD PTR [rax+r9*8-16]

; 138  :   return _mm_xor_pd(a,mask);

	xorps	xmm0, xmm1

; 221  : template<> EIGEN_STRONG_INLINE Packet4i pload<Packet4i>(const int*     from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_si128(reinterpret_cast<const Packet4i*>(from)); }
; 222  : 
; 223  : #if defined(_MSC_VER)
; 224  :   template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float*  from) {
; 225  :     EIGEN_DEBUG_UNALIGNED_LOAD
; 226  :     #if (_MSC_VER==1600)
; 227  :     // NOTE Some version of MSVC10 generates bad code when using _mm_loadu_ps
; 228  :     // (i.e., it does not generate an unaligned load!!
; 229  :     // TODO On most architectures this version should also be faster than a single _mm_loadu_ps
; 230  :     // so we could also enable it for MSVC08 but first we have to make this later does not generate crap when doing so...
; 231  :     __m128 res = _mm_loadl_pi(_mm_set1_ps(0.0f), (const __m64*)(from));
; 232  :     res = _mm_loadh_pi(res, (const __m64*)(from+2));
; 233  :     return res;
; 234  :     #else
; 235  :     return _mm_loadu_ps(from);
; 236  :     #endif
; 237  :   }
; 238  :   template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm_loadu_pd(from); }
; 239  :   template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int*    from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm_loadu_si128(reinterpret_cast<const Packet4i*>(from)); }
; 240  : #else
; 241  : // Fast unaligned loads. Note that here we cannot directly use intrinsics: this would
; 242  : // require pointer casting to incompatible pointer types and leads to invalid code
; 243  : // because of the strict aliasing rule. The "dummy" stuff are required to enforce
; 244  : // a correct instruction dependency.
; 245  : // TODO: do the same for MSVC (ICC is compatible)
; 246  : // NOTE: with the code below, MSVC's compiler crashes!
; 247  : 
; 248  : #if defined(__GNUC__) && defined(__i386__)
; 249  :   // bug 195: gcc/i386 emits weird x87 fldl/fstpl instructions for _mm_load_sd
; 250  :   #define EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS 1
; 251  : #elif defined(__clang__)
; 252  :   // bug 201: Segfaults in __mm_loadh_pd with clang 2.8
; 253  :   #define EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS 1
; 254  : #else
; 255  :   #define EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS 0
; 256  : #endif
; 257  : 
; 258  : template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float* from)
; 259  : {
; 260  :   EIGEN_DEBUG_UNALIGNED_LOAD
; 261  : #if EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS
; 262  :   return _mm_loadu_ps(from);
; 263  : #else
; 264  :   __m128d res;
; 265  :   res =  _mm_load_sd((const double*)(from)) ;
; 266  :   res =  _mm_loadh_pd(res, (const double*)(from+2)) ;
; 267  :   return _mm_castpd_ps(res);
; 268  : #endif
; 269  : }
; 270  : template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from)
; 271  : {
; 272  :   EIGEN_DEBUG_UNALIGNED_LOAD
; 273  : #if EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS
; 274  :   return _mm_loadu_pd(from);
; 275  : #else
; 276  :   __m128d res;
; 277  :   res = _mm_load_sd(from) ;
; 278  :   res = _mm_loadh_pd(res,from+1);
; 279  :   return res;
; 280  : #endif
; 281  : }
; 282  : template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int* from)
; 283  : {
; 284  :   EIGEN_DEBUG_UNALIGNED_LOAD
; 285  : #if EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS
; 286  :   return _mm_loadu_si128(reinterpret_cast<const Packet4i*>(from));
; 287  : #else
; 288  :   __m128d res;
; 289  :   res =  _mm_load_sd((const double*)(from)) ;
; 290  :   res =  _mm_loadh_pd(res, (const double*)(from+2)) ;
; 291  :   return _mm_castpd_si128(res);
; 292  : #endif
; 293  : }
; 294  : #endif
; 295  : 
; 296  : template<> EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float*   from)
; 297  : {
; 298  :   return vec4f_swizzle1(_mm_castpd_ps(_mm_load_sd(reinterpret_cast<const double*>(from))), 0, 0, 1, 1);
; 299  : }
; 300  : template<> EIGEN_STRONG_INLINE Packet2d ploaddup<Packet2d>(const double*  from)
; 301  : { return pset1<Packet2d>(from[0]); }
; 302  : template<> EIGEN_STRONG_INLINE Packet4i ploaddup<Packet4i>(const int*     from)
; 303  : {
; 304  :   Packet4i tmp;
; 305  :   tmp = _mm_loadl_epi64(reinterpret_cast<const Packet4i*>(from));
; 306  :   return vec4i_swizzle1(tmp, 0, 0, 1, 1);
; 307  : }
; 308  : 
; 309  : template<> EIGEN_STRONG_INLINE void pstore<float>(float*   to, const Packet4f& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_ps(to, from); }
; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [rdx], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	cmp	r9, r10
	jl	SHORT $LL270@operator
$LN268@operator:

; 411  :     }
; 412  : 
; 413  :     unaligned_assign_impl<>::run(src,dst,alignedEnd,size);

	mov	r9, r11
	mov	r8, r10
	mov	rdx, rsi
	call	??$run@V?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@?$unaligned_assign_impl@$0A@@internal@Eigen@@SAXAEBV?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@2@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@_J2@Z ; Eigen::internal::unaligned_assign_impl<0>::run<Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>,Eigen::ReturnByValue<Eigen::internal::solve_retval_base<Eigen::PartialPivLU<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::Matrix<double,-1,1,0,-1,1> > > const >,Eigen::Matrix<double,-1,1,0,-1,1> >
	mov	rdi, QWORD PTR [rsp+80]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\matrix.h

; 172  :       return Base::_set(other);

	mov	rax, rsi

; 173  :     }

	add	rsp, 32					; 00000020H
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN379@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN381@operator:
	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN376@operator:
??$?4V?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@@?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAAAEAV01@AEBV?$MatrixBase@V?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@@1@@Z ENDP ; Eigen::Matrix<double,-1,1,0,-1,1>::operator=<Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>,Eigen::ReturnByValue<Eigen::internal::solve_retval_base<Eigen::PartialPivLU<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::Matrix<double,-1,1,0,-1,1> > > const > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwisebinaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwisebinaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwisebinaryop.h
;	COMDAT ??$?YV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@?$MatrixBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$MatrixBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@1@@Z
_TEXT	SEGMENT
$T1 = 32
tmp$ = 40
rhs$2 = 56
__$ArrayPad$ = 96
this$ = 128
other$ = 136
??$?YV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@?$MatrixBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$MatrixBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@1@@Z PROC ; Eigen::MatrixBase<Eigen::Matrix<double,-1,1,0,-1,1> >::operator+=<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >, COMDAT

; 221  : {

$LN62:
	push	rbx
	sub	rsp, 112				; 00000070H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h

; 149  :       typename internal::nested<Rhs>::type rhs(_rhs);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	xmm1, XMMWORD PTR [rdx+16]

; 55   :     inline SelfCwiseBinaryOp(Lhs& xpr, const BinaryOp& func = BinaryOp()) : m_matrix(xpr), m_functor(func) {}

	lea	rax, QWORD PTR $T1[rsp]
	mov	QWORD PTR tmp$[rsp+8], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwisebinaryop.h

; 221  : {

	mov	rbx, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h

; 55   :     inline SelfCwiseBinaryOp(Lhs& xpr, const BinaryOp& func = BinaryOp()) : m_matrix(xpr), m_functor(func) {}

	mov	QWORD PTR tmp$[rsp], rcx

; 149  :       typename internal::nested<Rhs>::type rhs(_rhs);

	movups	xmm2, xmm0
	movups	XMMWORD PTR rhs$2[rsp], xmm0
	movsdx	xmm0, QWORD PTR [rdx+32]

; 56   : 
; 57   :     inline Index rows() const { return m_matrix.rows(); }
; 58   :     inline Index cols() const { return m_matrix.cols(); }
; 59   :     inline Index outerStride() const { return m_matrix.outerStride(); }
; 60   :     inline Index innerStride() const { return m_matrix.innerStride(); }
; 61   :     inline const Scalar* data() const { return m_matrix.data(); }
; 62   : 
; 63   :     // note that this function is needed by assign to correctly align loads/stores
; 64   :     // TODO make Assign use .data()
; 65   :     inline Scalar& coeffRef(Index row, Index col)
; 66   :     {
; 67   :       EIGEN_STATIC_ASSERT_LVALUE(Lhs)
; 68   :       return m_matrix.const_cast_derived().coeffRef(row, col);
; 69   :     }
; 70   :     inline const Scalar& coeffRef(Index row, Index col) const
; 71   :     {
; 72   :       return m_matrix.coeffRef(row, col);
; 73   :     }
; 74   : 
; 75   :     // note that this function is needed by assign to correctly align loads/stores
; 76   :     // TODO make Assign use .data()
; 77   :     inline Scalar& coeffRef(Index index)
; 78   :     {
; 79   :       EIGEN_STATIC_ASSERT_LVALUE(Lhs)
; 80   :       return m_matrix.const_cast_derived().coeffRef(index);
; 81   :     }
; 82   :     inline const Scalar& coeffRef(Index index) const
; 83   :     {
; 84   :       return m_matrix.const_cast_derived().coeffRef(index);
; 85   :     }
; 86   : 
; 87   :     template<typename OtherDerived>
; 88   :     void copyCoeff(Index row, Index col, const DenseBase<OtherDerived>& other)
; 89   :     {
; 90   :       OtherDerived& _other = other.const_cast_derived();
; 91   :       eigen_internal_assert(row >= 0 && row < rows()
; 92   :                          && col >= 0 && col < cols());
; 93   :       Scalar& tmp = m_matrix.coeffRef(row,col);
; 94   :       tmp = m_functor(tmp, _other.coeff(row,col));
; 95   :     }
; 96   : 
; 97   :     template<typename OtherDerived>
; 98   :     void copyCoeff(Index index, const DenseBase<OtherDerived>& other)
; 99   :     {
; 100  :       OtherDerived& _other = other.const_cast_derived();
; 101  :       eigen_internal_assert(index >= 0 && index < m_matrix.size());
; 102  :       Scalar& tmp = m_matrix.coeffRef(index);
; 103  :       tmp = m_functor(tmp, _other.coeff(index));
; 104  :     }
; 105  : 
; 106  :     template<typename OtherDerived, int StoreMode, int LoadMode>
; 107  :     void copyPacket(Index row, Index col, const DenseBase<OtherDerived>& other)
; 108  :     {
; 109  :       OtherDerived& _other = other.const_cast_derived();
; 110  :       eigen_internal_assert(row >= 0 && row < rows()
; 111  :                         && col >= 0 && col < cols());
; 112  :       m_matrix.template writePacket<StoreMode>(row, col,
; 113  :         m_functor.packetOp(m_matrix.template packet<StoreMode>(row, col),_other.template packet<LoadMode>(row, col)) );
; 114  :     }
; 115  : 
; 116  :     template<typename OtherDerived, int StoreMode, int LoadMode>
; 117  :     void copyPacket(Index index, const DenseBase<OtherDerived>& other)
; 118  :     {
; 119  :       OtherDerived& _other = other.const_cast_derived();
; 120  :       eigen_internal_assert(index >= 0 && index < m_matrix.size());
; 121  :       m_matrix.template writePacket<StoreMode>(index,
; 122  :         m_functor.packetOp(m_matrix.template packet<StoreMode>(index),_other.template packet<LoadMode>(index)) );
; 123  :     }
; 124  : 
; 125  :     // reimplement lazyAssign to handle complex *= real
; 126  :     // see CwiseBinaryOp ctor for details
; 127  :     template<typename RhsDerived>
; 128  :     EIGEN_STRONG_INLINE SelfCwiseBinaryOp& lazyAssign(const DenseBase<RhsDerived>& rhs)
; 129  :     {
; 130  :       EIGEN_STATIC_ASSERT_SAME_MATRIX_SIZE(Lhs,RhsDerived)
; 131  :       EIGEN_CHECK_BINARY_COMPATIBILIY(BinaryOp,typename Lhs::Scalar,typename RhsDerived::Scalar);
; 132  :       
; 133  :     #ifdef EIGEN_DEBUG_ASSIGN
; 134  :       internal::assign_traits<SelfCwiseBinaryOp, RhsDerived>::debug();
; 135  :     #endif
; 136  :       eigen_assert(rows() == rhs.rows() && cols() == rhs.cols());

	psrldq	xmm2, 8

; 149  :       typename internal::nested<Rhs>::type rhs(_rhs);

	movsdx	QWORD PTR rhs$2[rsp+32], xmm0
	movups	XMMWORD PTR rhs$2[rsp+16], xmm1

; 56   : 
; 57   :     inline Index rows() const { return m_matrix.rows(); }
; 58   :     inline Index cols() const { return m_matrix.cols(); }
; 59   :     inline Index outerStride() const { return m_matrix.outerStride(); }
; 60   :     inline Index innerStride() const { return m_matrix.innerStride(); }
; 61   :     inline const Scalar* data() const { return m_matrix.data(); }
; 62   : 
; 63   :     // note that this function is needed by assign to correctly align loads/stores
; 64   :     // TODO make Assign use .data()
; 65   :     inline Scalar& coeffRef(Index row, Index col)
; 66   :     {
; 67   :       EIGEN_STATIC_ASSERT_LVALUE(Lhs)
; 68   :       return m_matrix.const_cast_derived().coeffRef(row, col);
; 69   :     }
; 70   :     inline const Scalar& coeffRef(Index row, Index col) const
; 71   :     {
; 72   :       return m_matrix.coeffRef(row, col);
; 73   :     }
; 74   : 
; 75   :     // note that this function is needed by assign to correctly align loads/stores
; 76   :     // TODO make Assign use .data()
; 77   :     inline Scalar& coeffRef(Index index)
; 78   :     {
; 79   :       EIGEN_STATIC_ASSERT_LVALUE(Lhs)
; 80   :       return m_matrix.const_cast_derived().coeffRef(index);
; 81   :     }
; 82   :     inline const Scalar& coeffRef(Index index) const
; 83   :     {
; 84   :       return m_matrix.const_cast_derived().coeffRef(index);
; 85   :     }
; 86   : 
; 87   :     template<typename OtherDerived>
; 88   :     void copyCoeff(Index row, Index col, const DenseBase<OtherDerived>& other)
; 89   :     {
; 90   :       OtherDerived& _other = other.const_cast_derived();
; 91   :       eigen_internal_assert(row >= 0 && row < rows()
; 92   :                          && col >= 0 && col < cols());
; 93   :       Scalar& tmp = m_matrix.coeffRef(row,col);
; 94   :       tmp = m_functor(tmp, _other.coeff(row,col));
; 95   :     }
; 96   : 
; 97   :     template<typename OtherDerived>
; 98   :     void copyCoeff(Index index, const DenseBase<OtherDerived>& other)
; 99   :     {
; 100  :       OtherDerived& _other = other.const_cast_derived();
; 101  :       eigen_internal_assert(index >= 0 && index < m_matrix.size());
; 102  :       Scalar& tmp = m_matrix.coeffRef(index);
; 103  :       tmp = m_functor(tmp, _other.coeff(index));
; 104  :     }
; 105  : 
; 106  :     template<typename OtherDerived, int StoreMode, int LoadMode>
; 107  :     void copyPacket(Index row, Index col, const DenseBase<OtherDerived>& other)
; 108  :     {
; 109  :       OtherDerived& _other = other.const_cast_derived();
; 110  :       eigen_internal_assert(row >= 0 && row < rows()
; 111  :                         && col >= 0 && col < cols());
; 112  :       m_matrix.template writePacket<StoreMode>(row, col,
; 113  :         m_functor.packetOp(m_matrix.template packet<StoreMode>(row, col),_other.template packet<LoadMode>(row, col)) );
; 114  :     }
; 115  : 
; 116  :     template<typename OtherDerived, int StoreMode, int LoadMode>
; 117  :     void copyPacket(Index index, const DenseBase<OtherDerived>& other)
; 118  :     {
; 119  :       OtherDerived& _other = other.const_cast_derived();
; 120  :       eigen_internal_assert(index >= 0 && index < m_matrix.size());
; 121  :       m_matrix.template writePacket<StoreMode>(index,
; 122  :         m_functor.packetOp(m_matrix.template packet<StoreMode>(index),_other.template packet<LoadMode>(index)) );
; 123  :     }
; 124  : 
; 125  :     // reimplement lazyAssign to handle complex *= real
; 126  :     // see CwiseBinaryOp ctor for details
; 127  :     template<typename RhsDerived>
; 128  :     EIGEN_STRONG_INLINE SelfCwiseBinaryOp& lazyAssign(const DenseBase<RhsDerived>& rhs)
; 129  :     {
; 130  :       EIGEN_STATIC_ASSERT_SAME_MATRIX_SIZE(Lhs,RhsDerived)
; 131  :       EIGEN_CHECK_BINARY_COMPATIBILIY(BinaryOp,typename Lhs::Scalar,typename RhsDerived::Scalar);
; 132  :       
; 133  :     #ifdef EIGEN_DEBUG_ASSIGN
; 134  :       internal::assign_traits<SelfCwiseBinaryOp, RhsDerived>::debug();
; 135  :     #endif
; 136  :       eigen_assert(rows() == rhs.rows() && cols() == rhs.cols());

	movq	rax, xmm2
	cmp	QWORD PTR [rcx+8], rax
	jne	SHORT $LN25@operator
	cmp	QWORD PTR rhs$2[rsp+16], 1
	je	SHORT $LN26@operator
$LN25@operator:
	lea	rdx, OFFSET FLAT:??_C@_1ME@CGCHACLK@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1FK@JAKLMIFJ@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAr?$AAh?$AAs?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN@
	mov	r8d, 136				; 00000088H
	call	QWORD PTR __imp__wassert
$LN26@operator:

; 137  :       internal::assign_impl<SelfCwiseBinaryOp, RhsDerived>::run(*this,rhs.derived());

	lea	rdx, QWORD PTR rhs$2[rsp]
	lea	rcx, QWORD PTR tmp$[rsp]
	call	?run@?$assign_impl@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@3@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Z ; Eigen::internal::assign_impl<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,4,0,0>::run
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwisebinaryop.h

; 224  :   return derived();

	mov	rax, rbx

; 225  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 112				; 00000070H
	pop	rbx
	ret	0
??$?YV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@?$MatrixBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$MatrixBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@1@@Z ENDP ; Eigen::MatrixBase<Eigen::Matrix<double,-1,1,0,-1,1> >::operator+=<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
;	COMDAT ??$?4V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$MatrixBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@1@AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 48
other$ = 56
??$?4V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$MatrixBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@1@AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z PROC ; Eigen::MatrixBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::operator=<Eigen::Matrix<double,-1,1,0,-1,1> >, COMDAT

; 563  : {

$LN56:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	mov	rax, QWORD PTR [rdx+8]

; 563  : {

	mov	rdi, rdx
	mov	rbx, rcx

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	cmp	QWORD PTR [rcx+8], rax
	jne	SHORT $LN13@operator
	cmp	QWORD PTR [rcx+16], 1
	je	SHORT $LN14@operator
$LN13@operator:
	lea	rdx, OFFSET FLAT:??_C@_1KO@HDGCFKMN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GC@PBCDNLIH@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ@
	mov	r8d, 498				; 000001f2H
	call	QWORD PTR __imp__wassert
$LN14@operator:

; 499  :   internal::assign_impl<Derived, OtherDerived, int(SameType) ? int(internal::assign_traits<Derived, OtherDerived>::Traversal)
; 500  :                                                        : int(InvalidTraversal)>::run(derived(),other.derived());

	mov	rdx, rdi
	mov	rcx, rbx
	call	?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z ; Eigen::internal::assign_impl<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,Eigen::Matrix<double,-1,1,0,-1,1>,4,0,0>::run

; 564  :   return internal::assign_selector<Derived,OtherDerived>::run(derived(), other.derived());

	mov	rax, rbx

; 565  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$?4V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$MatrixBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@1@AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z ENDP ; Eigen::MatrixBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::operator=<Eigen::Matrix<double,-1,1,0,-1,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
;	COMDAT ??$?4V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@?$MatrixBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@1@AEBV?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 48
other$ = 56
??$?4V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@?$MatrixBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@1@AEBV?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@1@@Z PROC ; Eigen::MatrixBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::operator=<Eigen::Matrix<double,-1,-1,0,-1,-1> >, COMDAT

; 563  : {

$LN56:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	mov	rax, QWORD PTR [rdx+8]

; 563  : {

	mov	rdi, rdx
	mov	rbx, rcx

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	cmp	QWORD PTR [rcx+8], rax
	jne	SHORT $LN13@operator
	mov	rax, QWORD PTR [rdx+16]
	cmp	QWORD PTR [rcx+16], rax
	je	SHORT $LN14@operator
$LN13@operator:
	lea	rdx, OFFSET FLAT:??_C@_1KO@HDGCFKMN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GC@PBCDNLIH@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ@
	mov	r8d, 498				; 000001f2H
	call	QWORD PTR __imp__wassert
$LN14@operator:

; 499  :   internal::assign_impl<Derived, OtherDerived, int(SameType) ? int(internal::assign_traits<Derived, OtherDerived>::Traversal)
; 500  :                                                        : int(InvalidTraversal)>::run(derived(),other.derived());

	mov	rdx, rdi
	mov	rcx, rbx
	call	?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@Z ; Eigen::internal::assign_impl<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,Eigen::Matrix<double,-1,-1,0,-1,-1>,4,0,0>::run

; 564  :   return internal::assign_selector<Derived,OtherDerived>::run(derived(), other.derived());

	mov	rax, rbx

; 565  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$?4V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@?$MatrixBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@1@AEBV?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@1@@Z ENDP ; Eigen::MatrixBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::operator=<Eigen::Matrix<double,-1,-1,0,-1,-1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
;	COMDAT ??$?4V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@?$MatrixBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@1@AEBV?$DenseBase@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 48
other$ = 56
??$?4V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@?$MatrixBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@1@AEBV?$DenseBase@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@1@@Z PROC ; Eigen::MatrixBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::operator=<Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> > >, COMDAT

; 563  : {

$LN107:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 240  :     inline DenseIndex cols(void) const {return m_cols;}

	mov	rcx, QWORD PTR [rdx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 563  : {

	mov	rdi, rdx

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	mov	rax, QWORD PTR [rcx+16]
	cmp	QWORD PTR [rbx+8], rax
	jne	SHORT $LN13@operator
	mov	rax, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rbx+16], rax
	je	SHORT $LN14@operator
$LN13@operator:
	lea	rdx, OFFSET FLAT:??_C@_1KO@HDGCFKMN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GC@PBCDNLIH@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ@
	mov	r8d, 498				; 000001f2H
	call	QWORD PTR __imp__wassert
$LN14@operator:

; 499  :   internal::assign_impl<Derived, OtherDerived, int(SameType) ? int(internal::assign_traits<Derived, OtherDerived>::Traversal)
; 500  :                                                        : int(InvalidTraversal)>::run(derived(),other.derived());

	mov	rdx, rdi
	mov	rcx, rbx
	call	?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@$0A@$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Z ; Eigen::internal::assign_impl<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> >,0,0,0>::run
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 199  :     inline const Scalar* data() const { return this->m_data; }

	mov	rcx, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h

; 361  :     return (bool(blas_traits<OtherDerived>::IsTransposed) != DestIsTransposed) && (dest!=0 && dest==(const Scalar*)extract_data(src));

	test	rcx, rcx
	je	SHORT $LN104@operator
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 262  :     inline T *data() { return m_data; }

	mov	rax, QWORD PTR [rdi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h

; 361  :     return (bool(blas_traits<OtherDerived>::IsTransposed) != DestIsTransposed) && (dest!=0 && dest==(const Scalar*)extract_data(src));

	cmp	rcx, QWORD PTR [rax]
	jne	SHORT $LN104@operator

; 362  :   }
; 363  : };
; 364  : 
; 365  : template<typename Scalar, bool DestIsTransposed, typename BinOp, typename DerivedA, typename DerivedB>
; 366  : struct check_transpose_aliasing_run_time_selector<Scalar,DestIsTransposed,CwiseBinaryOp<BinOp,DerivedA,DerivedB> >
; 367  : {
; 368  :   static bool run(const Scalar* dest, const CwiseBinaryOp<BinOp,DerivedA,DerivedB>& src)
; 369  :   {
; 370  :     return ((blas_traits<DerivedA>::IsTransposed != DestIsTransposed) && (dest!=0 && dest==(const Scalar*)extract_data(src.lhs())))
; 371  :         || ((blas_traits<DerivedB>::IsTransposed != DestIsTransposed) && (dest!=0 && dest==(const Scalar*)extract_data(src.rhs())));
; 372  :   }
; 373  : };
; 374  : 
; 375  : // the following selector, checkTransposeAliasing_impl, based on MightHaveTransposeAliasing,
; 376  : // is because when the condition controlling the assert is known at compile time, ICC emits a warning.
; 377  : // This is actually a good warning: in expressions that don't have any transposing, the condition is
; 378  : // known at compile time to be false, and using that, we can avoid generating the code of the assert again
; 379  : // and again for all these expressions that don't need it.
; 380  : 
; 381  : template<typename Derived, typename OtherDerived,
; 382  :          bool MightHaveTransposeAliasing
; 383  :                  = check_transpose_aliasing_compile_time_selector
; 384  :                      <blas_traits<Derived>::IsTransposed,OtherDerived>::ret
; 385  :         >
; 386  : struct checkTransposeAliasing_impl
; 387  : {
; 388  :     static void run(const Derived& dst, const OtherDerived& other)
; 389  :     {
; 390  :         eigen_assert((!check_transpose_aliasing_run_time_selector

	lea	rdx, OFFSET FLAT:??_C@_1LE@ODIDILMJ@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1CCG@OOFKGNBC@?$AA?$CI?$AA?$CB?$AAc?$AAh?$AAe?$AAc?$AAk?$AA_?$AAt?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AA_?$AAa?$AAl?$AAi?$AAa?$AAs?$AAi?$AAn?$AAg?$AA_?$AAr?$AAu?$AAn?$AA_?$AAt@
	mov	r8d, 394				; 0000018aH
	call	QWORD PTR __imp__wassert
$LN104@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 564  :   return internal::assign_selector<Derived,OtherDerived>::run(derived(), other.derived());

	mov	rax, rbx

; 565  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$?4V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@?$MatrixBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@1@AEBV?$DenseBase@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@1@@Z ENDP ; Eigen::MatrixBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::operator=<Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\matrix.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\matrix.h
;	COMDAT ??$?0V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@AEBV?$MatrixBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z
_TEXT	SEGMENT
$T1 = 32
this$GSCopy$ = 40
this$ = 80
other$ = 88
??$?0V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@AEBV?$MatrixBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z PROC ; Eigen::Matrix<double,-1,-1,0,-1,-1>::Matrix<double,-1,-1,0,-1,-1><Eigen::Matrix<double,-1,1,0,-1,1> >, COMDAT

; 274  :     {

$LN354:
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+96], rbx
	mov	QWORD PTR [rsp+104], rbp
	mov	r14, rdx
	mov	rbx, rcx
	mov	QWORD PTR this$GSCopy$[rsp], rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 313  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rdi, QWORD PTR [rdx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 420  :   if(size==0)

	xor	esi, esi
	test	rdi, rdi
	jne	SHORT $LN42@Matrix

; 421  :     return 0; // short-cut. Also fixes Bug 884

	mov	eax, esi
	jmp	SHORT $LN43@Matrix
$LN42@Matrix:

; 244  :   #elif EIGEN_HAS_POSIX_MEMALIGN
; 245  :     std::free(ptr);
; 246  :   #elif EIGEN_HAS_MM_MALLOC
; 247  :     _mm_free(ptr);
; 248  :   #elif defined(_MSC_VER) && (!defined(_WIN32_WCE))
; 249  :     _aligned_free(ptr);
; 250  :   #else
; 251  :     handmade_aligned_free(ptr);
; 252  :   #endif
; 253  : }
; 254  : 
; 255  : /**
; 256  : * \internal
; 257  : * \brief Reallocates an aligned block of memory.
; 258  : * \throws std::bad_alloc on allocation failure
; 259  : **/
; 260  : inline void* aligned_realloc(void *ptr, size_t new_size, size_t old_size)
; 261  : {
; 262  :   EIGEN_UNUSED_VARIABLE(old_size);
; 263  : 
; 264  :   void *result;
; 265  : #if !EIGEN_ALIGN
; 266  :   result = std::realloc(ptr,new_size);
; 267  : #elif EIGEN_MALLOC_ALREADY_ALIGNED
; 268  :   result = std::realloc(ptr,new_size);
; 269  : #elif EIGEN_HAS_POSIX_MEMALIGN
; 270  :   result = generic_aligned_realloc(ptr,new_size,old_size);
; 271  : #elif EIGEN_HAS_MM_MALLOC
; 272  :   // The defined(_mm_free) is just here to verify that this MSVC version
; 273  :   // implements _mm_malloc/_mm_free based on the corresponding _aligned_
; 274  :   // functions. This may not always be the case and we just try to be safe.
; 275  :   #if defined(_MSC_VER) && (!defined(_WIN32_WCE)) && defined(_mm_free)
; 276  :     result = _aligned_realloc(ptr,new_size,16);
; 277  :   #else
; 278  :     result = generic_aligned_realloc(ptr,new_size,old_size);
; 279  :   #endif
; 280  : #elif defined(_MSC_VER) && (!defined(_WIN32_WCE))
; 281  :   result = _aligned_realloc(ptr,new_size,16);
; 282  : #else
; 283  :   result = handmade_aligned_realloc(ptr,new_size,old_size);
; 284  : #endif
; 285  : 
; 286  :   if (!result && new_size)
; 287  :     throw_std_bad_alloc();
; 288  : 
; 289  :   return result;
; 290  : }
; 291  : 
; 292  : /*****************************************************************************
; 293  : *** Implementation of conditionally aligned functions                      ***
; 294  : *****************************************************************************/
; 295  : 
; 296  : /** \internal Allocates \a size bytes. If Align is true, then the returned ptr is 16-byte-aligned.
; 297  :   * On allocation error, the returned pointer is null, and a std::bad_alloc is thrown.
; 298  :   */
; 299  : template<bool Align> inline void* conditional_aligned_malloc(size_t size)
; 300  : {
; 301  :   return aligned_malloc(size);
; 302  : }
; 303  : 
; 304  : template<> inline void* conditional_aligned_malloc<false>(size_t size)
; 305  : {
; 306  :   check_that_malloc_is_allowed();
; 307  : 
; 308  :   void *result = std::malloc(size);
; 309  :   if(!result && size)
; 310  :     throw_std_bad_alloc();
; 311  :   return result;
; 312  : }
; 313  : 
; 314  : /** \internal Frees memory allocated with conditional_aligned_malloc */
; 315  : template<bool Align> inline void conditional_aligned_free(void *ptr)
; 316  : {
; 317  :   aligned_free(ptr);
; 318  : }
; 319  : 
; 320  : template<> inline void conditional_aligned_free<false>(void *ptr)
; 321  : {
; 322  :   std::free(ptr);
; 323  : }
; 324  : 
; 325  : template<bool Align> inline void* conditional_aligned_realloc(void* ptr, size_t new_size, size_t old_size)
; 326  : {
; 327  :   return aligned_realloc(ptr, new_size, old_size);
; 328  : }
; 329  : 
; 330  : template<> inline void* conditional_aligned_realloc<false>(void* ptr, size_t new_size, size_t)
; 331  : {
; 332  :   return std::realloc(ptr, new_size);
; 333  : }
; 334  : 
; 335  : /*****************************************************************************
; 336  : *** Construction/destruction of array elements                             ***
; 337  : *****************************************************************************/
; 338  : 
; 339  : /** \internal Constructs the elements of an array.
; 340  :   * The \a size parameter tells on how many objects to call the constructor of T.
; 341  :   */
; 342  : template<typename T> inline T* construct_elements_of_array(T *ptr, size_t size)
; 343  : {
; 344  :   for (size_t i=0; i < size; ++i) ::new (ptr + i) T;
; 345  :   return ptr;
; 346  : }
; 347  : 
; 348  : /** \internal Destructs the elements of an array.
; 349  :   * The \a size parameters tells on how many objects to call the destructor of T.
; 350  :   */
; 351  : template<typename T> inline void destruct_elements_of_array(T *ptr, size_t size)
; 352  : {
; 353  :   // always destruct an array starting from the end.
; 354  :   if(ptr)
; 355  :     while(size) ptr[--size].~T();
; 356  : }
; 357  : 
; 358  : /*****************************************************************************
; 359  : *** Implementation of aligned new/delete-like functions                    ***
; 360  : *****************************************************************************/
; 361  : 
; 362  : template<typename T>
; 363  : EIGEN_ALWAYS_INLINE void check_size_for_overflow(size_t size)
; 364  : {
; 365  :   if(size > size_t(-1) / sizeof(T))

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdi, rax
	jbe	SHORT $LN45@Matrix

; 366  :     throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN45@Matrix:

; 422  :   check_size_for_overflow<T>(size);
; 423  :   T *result = reinterpret_cast<T*>(conditional_aligned_malloc<Align>(sizeof(T)*size));

	lea	rbp, QWORD PTR [rdi*8]

; 220  :     result = std::malloc(size);

	mov	rcx, rbp
	call	QWORD PTR __imp_malloc

; 221  :   #elif EIGEN_HAS_POSIX_MEMALIGN
; 222  :     if(posix_memalign(&result, 16, size)) result = 0;
; 223  :   #elif EIGEN_HAS_MM_MALLOC
; 224  :     result = _mm_malloc(size, 16);
; 225  :   #elif defined(_MSC_VER) && (!defined(_WIN32_WCE))
; 226  :     result = _aligned_malloc(size, 16);
; 227  :   #else
; 228  :     result = handmade_aligned_malloc(size);
; 229  :   #endif
; 230  : 
; 231  :   if(!result && size)

	test	rax, rax
	jne	SHORT $LN43@Matrix
	test	rbp, rbp
	je	SHORT $LN43@Matrix

; 232  :     throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN43@Matrix:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 235  :     { EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN }

	mov	QWORD PTR [rbx], rax
	mov	QWORD PTR [rbx+8], rdi
	mov	QWORD PTR [rbx+16], 1

; 313  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rdi, QWORD PTR [r14+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	mov	rbp, 9223372036854775807		; 7fffffffffffffffH
	test	rdi, rdi
	je	SHORT $LN352@Matrix
	cmp	rdi, rbp
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN94@Matrix

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN94@Matrix:

; 47   :   }
; 48   : };
; 49   : 
; 50   : template <typename Derived,
; 51   :           typename OtherDerived = Derived,
; 52   :           bool IsVector = bool(Derived::IsVectorAtCompileTime) && bool(OtherDerived::IsVectorAtCompileTime)>
; 53   : struct conservative_resize_like_impl;
; 54   : 
; 55   : template<typename MatrixTypeA, typename MatrixTypeB, bool SwapPointers> struct matrix_swap_impl;
; 56   : 
; 57   : } // end namespace internal
; 58   : 
; 59   : /** \class PlainObjectBase
; 60   :   * \brief %Dense storage base class for matrices and arrays.
; 61   :   *
; 62   :   * This class can be extended with the help of the plugin mechanism described on the page
; 63   :   * \ref TopicCustomizingEigen by defining the preprocessor symbol \c EIGEN_PLAINOBJECTBASE_PLUGIN.
; 64   :   *
; 65   :   * \sa \ref TopicClassHierarchy
; 66   :   */
; 67   : #ifdef EIGEN_PARSED_BY_DOXYGEN
; 68   : namespace internal {
; 69   : 
; 70   : // this is a warkaround to doxygen not being able to understand the inheritence logic
; 71   : // when it is hidden by the dense_xpr_base helper struct.
; 72   : template<typename Derived> struct dense_xpr_base_dispatcher_for_doxygen;// : public MatrixBase<Derived> {};
; 73   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 74   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 75   : struct dense_xpr_base_dispatcher_for_doxygen<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 76   :     : public MatrixBase<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 77   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 78   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 79   : struct dense_xpr_base_dispatcher_for_doxygen<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 80   :     : public ArrayBase<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 81   : 
; 82   : } // namespace internal
; 83   : 
; 84   : template<typename Derived>
; 85   : class PlainObjectBase : public internal::dense_xpr_base_dispatcher_for_doxygen<Derived>
; 86   : #else
; 87   : template<typename Derived>
; 88   : class PlainObjectBase : public internal::dense_xpr_base<Derived>::type
; 89   : #endif
; 90   : {
; 91   :   public:
; 92   :     enum { Options = internal::traits<Derived>::Options };
; 93   :     typedef typename internal::dense_xpr_base<Derived>::type Base;
; 94   : 
; 95   :     typedef typename internal::traits<Derived>::StorageKind StorageKind;
; 96   :     typedef typename internal::traits<Derived>::Index Index;
; 97   :     typedef typename internal::traits<Derived>::Scalar Scalar;
; 98   :     typedef typename internal::packet_traits<Scalar>::type PacketScalar;
; 99   :     typedef typename NumTraits<Scalar>::Real RealScalar;
; 100  :     typedef Derived DenseType;
; 101  : 
; 102  :     using Base::RowsAtCompileTime;
; 103  :     using Base::ColsAtCompileTime;
; 104  :     using Base::SizeAtCompileTime;
; 105  :     using Base::MaxRowsAtCompileTime;
; 106  :     using Base::MaxColsAtCompileTime;
; 107  :     using Base::MaxSizeAtCompileTime;
; 108  :     using Base::IsVectorAtCompileTime;
; 109  :     using Base::Flags;
; 110  : 
; 111  :     template<typename PlainObjectType, int MapOptions, typename StrideType> friend class Eigen::Map;
; 112  :     friend  class Eigen::Map<Derived, Unaligned>;
; 113  :     typedef Eigen::Map<Derived, Unaligned>  MapType;
; 114  :     friend  class Eigen::Map<const Derived, Unaligned>;
; 115  :     typedef const Eigen::Map<const Derived, Unaligned> ConstMapType;
; 116  :     friend  class Eigen::Map<Derived, Aligned>;
; 117  :     typedef Eigen::Map<Derived, Aligned> AlignedMapType;
; 118  :     friend  class Eigen::Map<const Derived, Aligned>;
; 119  :     typedef const Eigen::Map<const Derived, Aligned> ConstAlignedMapType;
; 120  :     template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };
; 121  :     template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };
; 122  :     template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, Aligned, StrideType> type; };
; 123  :     template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, Aligned, StrideType> type; };
; 124  : 
; 125  :   protected:
; 126  :     DenseStorage<Scalar, Base::MaxSizeAtCompileTime, Base::RowsAtCompileTime, Base::ColsAtCompileTime, Options> m_storage;
; 127  : 
; 128  :   public:
; 129  :     enum { NeedsToAlign = SizeAtCompileTime != Dynamic && (internal::traits<Derived>::Flags & AlignedBit) != 0 };
; 130  :     EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(NeedsToAlign)
; 131  : 
; 132  :     Base& base() { return *static_cast<Base*>(this); }
; 133  :     const Base& base() const { return *static_cast<const Base*>(this); }
; 134  : 
; 135  :     EIGEN_STRONG_INLINE Index rows() const { return m_storage.rows(); }
; 136  :     EIGEN_STRONG_INLINE Index cols() const { return m_storage.cols(); }
; 137  : 
; 138  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index rowId, Index colId) const
; 139  :     {
; 140  :       if(Flags & RowMajorBit)
; 141  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 142  :       else // column-major
; 143  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 144  :     }
; 145  : 
; 146  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index index) const
; 147  :     {
; 148  :       return m_storage.data()[index];
; 149  :     }
; 150  : 
; 151  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index rowId, Index colId)
; 152  :     {
; 153  :       if(Flags & RowMajorBit)
; 154  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 155  :       else // column-major
; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 157  :     }
; 158  : 
; 159  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
; 160  :     {
; 161  :       return m_storage.data()[index];
; 162  :     }
; 163  : 
; 164  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
; 165  :     {
; 166  :       if(Flags & RowMajorBit)
; 167  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 168  :       else // column-major
; 169  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 170  :     }
; 171  : 
; 172  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
; 173  :     {
; 174  :       return m_storage.data()[index];
; 175  :     }
; 176  : 
; 177  :     /** \internal */
; 178  :     template<int LoadMode>
; 179  :     EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const
; 180  :     {
; 181  :       return internal::ploadt<PacketScalar, LoadMode>
; 182  :                (m_storage.data() + (Flags & RowMajorBit
; 183  :                                    ? colId + rowId * m_storage.cols()
; 184  :                                    : rowId + colId * m_storage.rows()));
; 185  :     }
; 186  : 
; 187  :     /** \internal */
; 188  :     template<int LoadMode>
; 189  :     EIGEN_STRONG_INLINE PacketScalar packet(Index index) const
; 190  :     {
; 191  :       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);
; 192  :     }
; 193  : 
; 194  :     /** \internal */
; 195  :     template<int StoreMode>
; 196  :     EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)
; 197  :     {
; 198  :       internal::pstoret<Scalar, PacketScalar, StoreMode>
; 199  :               (m_storage.data() + (Flags & RowMajorBit
; 200  :                                    ? colId + rowId * m_storage.cols()
; 201  :                                    : rowId + colId * m_storage.rows()), val);
; 202  :     }
; 203  : 
; 204  :     /** \internal */
; 205  :     template<int StoreMode>
; 206  :     EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
; 207  :     {
; 208  :       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
; 209  :     }
; 210  : 
; 211  :     /** \returns a const pointer to the data array of this matrix */
; 212  :     EIGEN_STRONG_INLINE const Scalar *data() const
; 213  :     { return m_storage.data(); }
; 214  : 
; 215  :     /** \returns a pointer to the data array of this matrix */
; 216  :     EIGEN_STRONG_INLINE Scalar *data()
; 217  :     { return m_storage.data(); }
; 218  : 
; 219  :     /** Resizes \c *this to a \a rows x \a cols matrix.
; 220  :       *
; 221  :       * This method is intended for dynamic-size matrices, although it is legal to call it on any
; 222  :       * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
; 223  :       * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
; 224  :       *
; 225  :       * If the current number of coefficients of \c *this exactly matches the
; 226  :       * product \a rows * \a cols, then no memory allocation is performed and
; 227  :       * the current values are left unchanged. In all other cases, including
; 228  :       * shrinking, the data is reallocated and all previous values are lost.
; 229  :       *
; 230  :       * Example: \include Matrix_resize_int_int.cpp
; 231  :       * Output: \verbinclude Matrix_resize_int_int.out
; 232  :       *
; 233  :       * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
; 234  :       */
; 235  :     EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)
; 236  :     {
; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rdi, rdi
$LN352@Matrix:
	jns	SHORT $LN199@Matrix
	mov	r8d, 241				; 000000f1H
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	call	QWORD PTR __imp__wassert
$LN199@Matrix:

; 44   :                : (rows > max_index / cols);

	test	rdi, rdi
	je	SHORT $LN206@Matrix
	cmp	rdi, rbp
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN206@Matrix

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN206@Matrix:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 249  :       if(size != m_rows*m_cols)

	mov	rax, QWORD PTR [rbx+16]
	imul	rax, QWORD PTR [rbx+8]
	cmp	rdi, rax
	je	SHORT $LN211@Matrix
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR [rbx]
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 252  :         if (size)

	test	rdi, rdi
	je	SHORT $LN212@Matrix

; 253  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

	mov	rcx, rdi
	call	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
	mov	QWORD PTR [rbx], rax

; 254  :         else

	jmp	SHORT $LN211@Matrix
$LN212@Matrix:

; 255  :           m_data = 0;

	mov	QWORD PTR [rbx], rsi
$LN211@Matrix:

; 256  :         EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN
; 257  :       }
; 258  :       m_rows = nbRows;

	mov	QWORD PTR [rbx+8], rdi

; 259  :       m_cols = nbCols;

	mov	QWORD PTR [rbx+16], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	cmp	rdi, QWORD PTR [r14+8]
	je	SHORT $LN235@Matrix
	mov	r8d, 498				; 000001f2H
	lea	rdx, OFFSET FLAT:??_C@_1KO@HDGCFKMN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GC@PBCDNLIH@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ@
	call	QWORD PTR __imp__wassert
$LN235@Matrix:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 240  :     inline DenseIndex cols(void) const {return m_cols;}

	mov	r9, QWORD PTR [rbx+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 49   :   inline Index size() const { return rows() * cols(); }

	imul	r9, QWORD PTR [rbx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 404  :     const Index alignedEnd = alignedStart + ((size-alignedStart)/packetSize)*packetSize;

	mov	rax, r9
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r8, rax
	add	r8, r8

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	test	r8, r8
	jle	SHORT $LN272@Matrix
	npad	7
$LL274@Matrix:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 333  :     inline const T *data() const { return m_data; }

	mov	rax, QWORD PTR [r14]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 220  : template<> EIGEN_STRONG_INLINE Packet2d pload<Packet2d>(const double*  from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_pd(from); }

	movaps	xmm0, XMMWORD PTR [rax+rsi*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 262  :     inline T *data() { return m_data; }

	mov	rax, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [rax+rsi*8], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	add	rsi, 2
	cmp	rsi, r8
	jl	SHORT $LL274@Matrix
$LN272@Matrix:

; 409  :     {
; 410  :       dst.template copyPacket<Derived2, dstAlignment, srcAlignment>(index, src);
; 411  :     }
; 412  : 
; 413  :     unaligned_assign_impl<>::run(src,dst,alignedEnd,size);

	mov	rdx, rbx
	mov	rcx, r14
	call	??$run@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@@?$unaligned_assign_impl@$0A@@internal@Eigen@@SAXAEBV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@_J2@Z ; Eigen::internal::unaligned_assign_impl<0>::run<Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Matrix<double,-1,-1,0,-1,-1> >
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\matrix.h

; 282  :     }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+104]
	add	rsp, 48					; 00000030H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN351@Matrix:
??$?0V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@AEBV?$MatrixBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z ENDP ; Eigen::Matrix<double,-1,-1,0,-1,-1>::Matrix<double,-1,-1,0,-1,-1><Eigen::Matrix<double,-1,1,0,-1,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$GSCopy$ = 40
this$ = 80
other$ = 88
?dtor$0@?0???$?0V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@AEBV?$MatrixBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z@4HA PROC ; `Eigen::Matrix<double,-1,-1,0,-1,-1>::Matrix<double,-1,-1,0,-1,-1><Eigen::Matrix<double,-1,1,0,-1,1> >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	jmp	??1?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAA@XZ
?dtor$0@?0???$?0V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@QEAA@AEBV?$MatrixBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z@4HA ENDP ; `Eigen::Matrix<double,-1,-1,0,-1,-1>::Matrix<double,-1,-1,0,-1,-1><Eigen::Matrix<double,-1,1,0,-1,1> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
;	COMDAT ?rows@?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?rows@?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@Eigen@@QEBA_JXZ PROC ; Eigen::EigenBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const >,4> >::rows, COMDAT

; 44   :   inline Index rows() const { return derived().rows(); }

	mov	rax, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+8]
	ret	0
?rows@?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@Eigen@@QEBA_JXZ ENDP ; Eigen::EigenBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const >,4> >::rows
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
;	COMDAT ?cols@?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$dead$ = 8
?cols@?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@Eigen@@QEBA_JXZ PROC ; Eigen::EigenBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const >,4> >::cols, COMDAT

; 46   :   inline Index cols() const { return derived().cols(); }

	mov	eax, 1
	ret	0
?cols@?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@Eigen@@QEBA_JXZ ENDP ; Eigen::EigenBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const >,4> >::cols
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\generalproduct.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\generalproduct.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\generalproduct.h
;	COMDAT ??0?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@QEAA@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 48
a_lhs$ = 56
a_rhs$ = 64
??0?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@QEAA@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@1@@Z PROC ; Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>, COMDAT

; 337  :     {

$LN31:
	push	rbx
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h

; 99   :     {

	mov	QWORD PTR [rcx], rdx
	movups	xmm0, XMMWORD PTR [r8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 307  :     inline DenseStorage() : m_data(0), m_rows(0) {}

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\generalproduct.h

; 337  :     {

	mov	r9, rdx
	mov	rbx, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h

; 99   :     {

	movups	XMMWORD PTR [rcx+8], xmm0
	movsdx	xmm1, QWORD PTR [r8+16]
	movsdx	QWORD PTR [rcx+24], xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 307  :     inline DenseStorage() : m_data(0), m_rows(0) {}

	mov	QWORD PTR [rcx+32], rax
	mov	QWORD PTR [rcx+40], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h

; 100  :       eigen_assert(a_lhs.cols() == a_rhs.rows()

	mov	rax, QWORD PTR [r8+8]
	mov	rdx, QWORD PTR [rax+8]
	cmp	QWORD PTR [r9+16], rdx
	je	SHORT $LN29@GeneralPro
	lea	rdx, OFFSET FLAT:??_C@_1LI@OBICGMAP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1BCA@DNDIGDNN@?$AAa?$AA_?$AAl?$AAh?$AAs?$AA?4?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAa?$AA_?$AAr?$AAh?$AAs?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5@
	mov	r8d, 102				; 00000066H
	call	QWORD PTR __imp__wassert
$LN29@GeneralPro:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\generalproduct.h

; 340  :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@QEAA@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@1@@Z ENDP ; Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
;	COMDAT ?rows@?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?rows@?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@Eigen@@QEBA_JXZ PROC ; Eigen::EigenBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4> >::rows, COMDAT

; 44   :   inline Index rows() const { return derived().rows(); }

	mov	rax, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+8]
	ret	0
?rows@?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@Eigen@@QEBA_JXZ ENDP ; Eigen::EigenBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4> >::rows
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
;	COMDAT ?cols@?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$dead$ = 8
?cols@?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@Eigen@@QEBA_JXZ PROC ; Eigen::EigenBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4> >::cols, COMDAT

; 46   :   inline Index cols() const { return derived().cols(); }

	mov	eax, 1
	ret	0
?cols@?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@Eigen@@QEBA_JXZ ENDP ; Eigen::EigenBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4> >::cols
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
;	COMDAT ?derived@?$EigenBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@XZ
_TEXT	SEGMENT
this$ = 8
?derived@?$EigenBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@XZ PROC ; Eigen::EigenBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::derived, COMDAT

; 34   :   Derived& derived() { return *static_cast<Derived*>(this); }

	mov	rax, rcx
	ret	0
?derived@?$EigenBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@XZ ENDP ; Eigen::EigenBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::derived
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
;	COMDAT ?derived@?$EigenBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBAAEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@XZ
_TEXT	SEGMENT
this$ = 8
?derived@?$EigenBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBAAEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@XZ PROC ; Eigen::EigenBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::derived, COMDAT

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	mov	rax, rcx
	ret	0
?derived@?$EigenBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBAAEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@XZ ENDP ; Eigen::EigenBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::derived
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
;	COMDAT ?derived@?$EigenBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@2@XZ
_TEXT	SEGMENT
this$ = 8
?derived@?$EigenBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@2@XZ PROC ; Eigen::EigenBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::derived, COMDAT

; 34   :   Derived& derived() { return *static_cast<Derived*>(this); }

	mov	rax, rcx
	ret	0
?derived@?$EigenBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@2@XZ ENDP ; Eigen::EigenBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::derived
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h
;	COMDAT ??0?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@QEAA@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBU?$scalar_sum_op@N@internal@1@@Z
_TEXT	SEGMENT
this$ = 8
xpr$ = 16
func$ = 24
??0?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@QEAA@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBU?$scalar_sum_op@N@internal@1@@Z PROC ; Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >, COMDAT

; 55   :     inline SelfCwiseBinaryOp(Lhs& xpr, const BinaryOp& func = BinaryOp()) : m_matrix(xpr), m_functor(func) {}

	mov	QWORD PTR [rcx], rdx
	mov	QWORD PTR [rcx+8], r8
	mov	rax, rcx
	ret	0
??0?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@QEAA@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBU?$scalar_sum_op@N@internal@1@@Z ENDP ; Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h
;	COMDAT ??4?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@QEAAAEAV01@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@1@@Z
_TEXT	SEGMENT
rhs$ = 32
__$ArrayPad$ = 72
this$ = 96
_rhs$ = 104
??4?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@QEAAAEAV01@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@1@@Z PROC ; Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::operator=, COMDAT

; 148  :     {

$LN52:
	push	rbx
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 149  :       typename internal::nested<Rhs>::type rhs(_rhs);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	xmm1, XMMWORD PTR [rdx+16]
	mov	rbx, rcx

; 136  :       eigen_assert(rows() == rhs.rows() && cols() == rhs.cols());

	mov	rcx, QWORD PTR [rcx]

; 149  :       typename internal::nested<Rhs>::type rhs(_rhs);

	movups	xmm2, xmm0
	movups	XMMWORD PTR rhs$[rsp], xmm0
	movsdx	xmm0, QWORD PTR [rdx+32]

; 136  :       eigen_assert(rows() == rhs.rows() && cols() == rhs.cols());

	psrldq	xmm2, 8

; 149  :       typename internal::nested<Rhs>::type rhs(_rhs);

	movsdx	QWORD PTR rhs$[rsp+32], xmm0
	movups	XMMWORD PTR rhs$[rsp+16], xmm1

; 136  :       eigen_assert(rows() == rhs.rows() && cols() == rhs.cols());

	movq	rax, xmm2
	cmp	QWORD PTR [rcx+8], rax
	jne	SHORT $LN17@operator
	cmp	QWORD PTR rhs$[rsp+16], 1
	je	SHORT $LN18@operator
$LN17@operator:
	lea	rdx, OFFSET FLAT:??_C@_1ME@CGCHACLK@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1FK@JAKLMIFJ@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAr?$AAh?$AAs?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN@
	mov	r8d, 136				; 00000088H
	call	QWORD PTR __imp__wassert
$LN18@operator:

; 137  :       internal::assign_impl<SelfCwiseBinaryOp, RhsDerived>::run(*this,rhs.derived());

	lea	rdx, QWORD PTR rhs$[rsp]
	mov	rcx, rbx
	call	?run@?$assign_impl@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@3@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Z ; Eigen::internal::assign_impl<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,4,0,0>::run

; 150  :       return Base::operator=(rhs);

	mov	rax, rbx

; 151  :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 80					; 00000050H
	pop	rbx
	ret	0
??4?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@QEAAAEAV01@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@1@@Z ENDP ; Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
;	COMDAT ?run@?$assign_selector@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$0A@$0A@@internal@Eigen@@SAAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@AEAV43@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z
_TEXT	SEGMENT
dst$ = 48
other$ = 56
?run@?$assign_selector@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$0A@$0A@@internal@Eigen@@SAAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@AEAV43@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z PROC ; Eigen::internal::assign_selector<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,Eigen::Matrix<double,-1,1,0,-1,1>,0,0>::run, COMDAT

; 520  :   static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }

$LN50:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	mov	rax, QWORD PTR [rdx+8]

; 520  :   static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }

	mov	rdi, rdx
	mov	rbx, rcx

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	cmp	QWORD PTR [rcx+8], rax
	jne	SHORT $LN7@run
	cmp	QWORD PTR [rcx+16], 1
	je	SHORT $LN8@run
$LN7@run:
	lea	rdx, OFFSET FLAT:??_C@_1KO@HDGCFKMN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GC@PBCDNLIH@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ@
	mov	r8d, 498				; 000001f2H
	call	QWORD PTR __imp__wassert
$LN8@run:

; 499  :   internal::assign_impl<Derived, OtherDerived, int(SameType) ? int(internal::assign_traits<Derived, OtherDerived>::Traversal)
; 500  :                                                        : int(InvalidTraversal)>::run(derived(),other.derived());

	mov	rdx, rdi
	mov	rcx, rbx
	call	?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z ; Eigen::internal::assign_impl<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,Eigen::Matrix<double,-1,1,0,-1,1>,4,0,0>::run

; 520  :   static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?run@?$assign_selector@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$0A@$0A@@internal@Eigen@@SAAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@AEAV43@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z ENDP ; Eigen::internal::assign_selector<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,Eigen::Matrix<double,-1,1,0,-1,1>,0,0>::run
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
;	COMDAT ?run@?$assign_selector@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$0A@$0A@@internal@Eigen@@SAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEAV43@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@Z
_TEXT	SEGMENT
dst$ = 48
other$ = 56
?run@?$assign_selector@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$0A@$0A@@internal@Eigen@@SAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEAV43@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@Z PROC ; Eigen::internal::assign_selector<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,Eigen::Matrix<double,-1,-1,0,-1,-1>,0,0>::run, COMDAT

; 520  :   static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }

$LN50:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	mov	rax, QWORD PTR [rdx+8]

; 520  :   static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }

	mov	rdi, rdx
	mov	rbx, rcx

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	cmp	QWORD PTR [rcx+8], rax
	jne	SHORT $LN7@run
	mov	rax, QWORD PTR [rdx+16]
	cmp	QWORD PTR [rcx+16], rax
	je	SHORT $LN8@run
$LN7@run:
	lea	rdx, OFFSET FLAT:??_C@_1KO@HDGCFKMN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GC@PBCDNLIH@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ@
	mov	r8d, 498				; 000001f2H
	call	QWORD PTR __imp__wassert
$LN8@run:

; 499  :   internal::assign_impl<Derived, OtherDerived, int(SameType) ? int(internal::assign_traits<Derived, OtherDerived>::Traversal)
; 500  :                                                        : int(InvalidTraversal)>::run(derived(),other.derived());

	mov	rdx, rdi
	mov	rcx, rbx
	call	?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@Z ; Eigen::internal::assign_impl<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,Eigen::Matrix<double,-1,-1,0,-1,-1>,4,0,0>::run

; 520  :   static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?run@?$assign_selector@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$0A@$0A@@internal@Eigen@@SAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEAV43@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@Z ENDP ; Eigen::internal::assign_selector<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,Eigen::Matrix<double,-1,-1,0,-1,-1>,0,0>::run
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
;	COMDAT ?run@?$assign_selector@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@$0A@$0A@@internal@Eigen@@SAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEAV43@AEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Z
_TEXT	SEGMENT
dst$ = 48
other$ = 56
?run@?$assign_selector@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@$0A@$0A@@internal@Eigen@@SAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEAV43@AEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Z PROC ; Eigen::internal::assign_selector<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> >,0,0>::run, COMDAT

; 520  :   static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }

$LN101:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 240  :     inline DenseIndex cols(void) const {return m_cols;}

	mov	rcx, QWORD PTR [rdx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 520  :   static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }

	mov	rdi, rdx

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	mov	rax, QWORD PTR [rcx+16]
	cmp	QWORD PTR [rbx+8], rax
	jne	SHORT $LN7@run
	mov	rax, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rbx+16], rax
	je	SHORT $LN8@run
$LN7@run:
	lea	rdx, OFFSET FLAT:??_C@_1KO@HDGCFKMN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GC@PBCDNLIH@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ@
	mov	r8d, 498				; 000001f2H
	call	QWORD PTR __imp__wassert
$LN8@run:

; 499  :   internal::assign_impl<Derived, OtherDerived, int(SameType) ? int(internal::assign_traits<Derived, OtherDerived>::Traversal)
; 500  :                                                        : int(InvalidTraversal)>::run(derived(),other.derived());

	mov	rdx, rdi
	mov	rcx, rbx
	call	?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@$0A@$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Z ; Eigen::internal::assign_impl<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> >,0,0,0>::run
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 199  :     inline const Scalar* data() const { return this->m_data; }

	mov	rcx, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h

; 361  :     return (bool(blas_traits<OtherDerived>::IsTransposed) != DestIsTransposed) && (dest!=0 && dest==(const Scalar*)extract_data(src));

	test	rcx, rcx
	je	SHORT $LN98@run
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 262  :     inline T *data() { return m_data; }

	mov	rax, QWORD PTR [rdi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h

; 361  :     return (bool(blas_traits<OtherDerived>::IsTransposed) != DestIsTransposed) && (dest!=0 && dest==(const Scalar*)extract_data(src));

	cmp	rcx, QWORD PTR [rax]
	jne	SHORT $LN98@run

; 362  :   }
; 363  : };
; 364  : 
; 365  : template<typename Scalar, bool DestIsTransposed, typename BinOp, typename DerivedA, typename DerivedB>
; 366  : struct check_transpose_aliasing_run_time_selector<Scalar,DestIsTransposed,CwiseBinaryOp<BinOp,DerivedA,DerivedB> >
; 367  : {
; 368  :   static bool run(const Scalar* dest, const CwiseBinaryOp<BinOp,DerivedA,DerivedB>& src)
; 369  :   {
; 370  :     return ((blas_traits<DerivedA>::IsTransposed != DestIsTransposed) && (dest!=0 && dest==(const Scalar*)extract_data(src.lhs())))
; 371  :         || ((blas_traits<DerivedB>::IsTransposed != DestIsTransposed) && (dest!=0 && dest==(const Scalar*)extract_data(src.rhs())));
; 372  :   }
; 373  : };
; 374  : 
; 375  : // the following selector, checkTransposeAliasing_impl, based on MightHaveTransposeAliasing,
; 376  : // is because when the condition controlling the assert is known at compile time, ICC emits a warning.
; 377  : // This is actually a good warning: in expressions that don't have any transposing, the condition is
; 378  : // known at compile time to be false, and using that, we can avoid generating the code of the assert again
; 379  : // and again for all these expressions that don't need it.
; 380  : 
; 381  : template<typename Derived, typename OtherDerived,
; 382  :          bool MightHaveTransposeAliasing
; 383  :                  = check_transpose_aliasing_compile_time_selector
; 384  :                      <blas_traits<Derived>::IsTransposed,OtherDerived>::ret
; 385  :         >
; 386  : struct checkTransposeAliasing_impl
; 387  : {
; 388  :     static void run(const Derived& dst, const OtherDerived& other)
; 389  :     {
; 390  :         eigen_assert((!check_transpose_aliasing_run_time_selector

	lea	rdx, OFFSET FLAT:??_C@_1LE@ODIDILMJ@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1CCG@OOFKGNBC@?$AA?$CI?$AA?$CB?$AAc?$AAh?$AAe?$AAc?$AAk?$AA_?$AAt?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AA_?$AAa?$AAl?$AAi?$AAa?$AAs?$AAi?$AAn?$AAg?$AA_?$AAr?$AAu?$AAn?$AA_?$AAt@
	mov	r8d, 394				; 0000018aH
	call	QWORD PTR __imp__wassert
$LN98@run:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 520  :   static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?run@?$assign_selector@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@$0A@$0A@@internal@Eigen@@SAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEAV43@AEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Z ENDP ; Eigen::internal::assign_selector<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> >,0,0>::run
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@QEAAX_K@Z PROC ; Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>::__autoclassinit2, COMDAT
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax
	mov	QWORD PTR [rcx+32], rax
	ret	0
?__autoclassinit2@?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@QEAAX_K@Z ENDP ; Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h
;	COMDAT ??0?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEAA@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 48
a_lhs$ = 56
a_rhs$ = 64
??0?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEAA@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@1@@Z PROC ; Eigen::ProductBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >::ProductBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >, COMDAT

; 99   :     {

$LN29:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	QWORD PTR [rcx], rdx
	movups	xmm0, XMMWORD PTR [r8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 307  :     inline DenseStorage() : m_data(0), m_rows(0) {}

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h

; 99   :     {

	mov	r9, rdx
	mov	rbx, rcx
	movups	XMMWORD PTR [rcx+8], xmm0
	movsdx	xmm1, QWORD PTR [r8+16]
	movsdx	QWORD PTR [rcx+24], xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 307  :     inline DenseStorage() : m_data(0), m_rows(0) {}

	mov	QWORD PTR [rcx+32], rax
	mov	QWORD PTR [rcx+40], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h

; 100  :       eigen_assert(a_lhs.cols() == a_rhs.rows()

	mov	rax, QWORD PTR [r8+8]
	mov	rdx, QWORD PTR [rax+8]
	cmp	QWORD PTR [r9+16], rdx
	je	SHORT $LN27@ProductBas
	lea	rdx, OFFSET FLAT:??_C@_1LI@OBICGMAP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1BCA@DNDIGDNN@?$AAa?$AA_?$AAl?$AAh?$AAs?$AA?4?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAa?$AA_?$AAr?$AAh?$AAs?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5@
	mov	r8d, 102				; 00000066H
	call	QWORD PTR __imp__wassert
$LN27@ProductBas:

; 101  :         && "invalid matrix product"
; 102  :         && "if you wanted a coeff-wise or a dot product use the respective explicit functions");
; 103  :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEAA@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@1@@Z ENDP ; Eigen::ProductBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >::ProductBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h
;	COMDAT ?rows@?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?rows@?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEBA_JXZ PROC ; Eigen::ProductBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >::rows, COMDAT

; 105  :     inline Index rows() const { return m_lhs.rows(); }

	mov	rax, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+8]
	ret	0
?rows@?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEBA_JXZ ENDP ; Eigen::ProductBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >::rows
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h
;	COMDAT ?cols@?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$dead$ = 8
?cols@?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEBA_JXZ PROC ; Eigen::ProductBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >::cols, COMDAT

; 106  :     inline Index cols() const { return m_rhs.cols(); }

	mov	eax, 1
	ret	0
?cols@?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEBA_JXZ ENDP ; Eigen::ProductBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >::cols
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
;	COMDAT ?derived@?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@Eigen@@QEBAAEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@XZ
_TEXT	SEGMENT
this$ = 8
?derived@?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@Eigen@@QEBAAEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@XZ PROC ; Eigen::EigenBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4> >::derived, COMDAT

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	mov	rax, rcx
	ret	0
?derived@?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@Eigen@@QEBAAEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@XZ ENDP ; Eigen::EigenBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4> >::derived
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\matrixbase.h
;	COMDAT ??0?$MatrixBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@IEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$MatrixBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@IEAA@XZ PROC ; Eigen::MatrixBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> > >::MatrixBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> > >, COMDAT

; 494  :     MatrixBase() : Base() {}

	mov	rax, rcx
	ret	0
??0?$MatrixBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@IEAA@XZ ENDP ; Eigen::MatrixBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> > >::MatrixBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\matrixbase.h
;	COMDAT ??0?$MatrixBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@Eigen@@IEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$MatrixBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@Eigen@@IEAA@XZ PROC ; Eigen::MatrixBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4> >::MatrixBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4> >, COMDAT

; 494  :     MatrixBase() : Base() {}

	mov	rax, rcx
	ret	0
??0?$MatrixBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@Eigen@@IEAA@XZ ENDP ; Eigen::MatrixBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4> >::MatrixBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densebase.h
;	COMDAT ??0?$DenseBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@IEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$DenseBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@IEAA@XZ PROC ; Eigen::DenseBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> > >::DenseBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> > >, COMDAT

; 504  :     {
; 505  :       /* Just checks for self-consistency of the flags.
; 506  :        * Only do it when debugging Eigen, as this borders on paranoiac and could slow compilation down
; 507  :        */
; 508  : #ifdef EIGEN_INTERNAL_DEBUGGING
; 509  :       EIGEN_STATIC_ASSERT((EIGEN_IMPLIES(MaxRowsAtCompileTime==1 && MaxColsAtCompileTime!=1, int(IsRowMajor))
; 510  :                         && EIGEN_IMPLIES(MaxColsAtCompileTime==1 && MaxRowsAtCompileTime!=1, int(!IsRowMajor))),
; 511  :                           INVALID_STORAGE_ORDER_FOR_THIS_VECTOR_EXPRESSION)
; 512  : #endif
; 513  :     }

	mov	rax, rcx
	ret	0
??0?$DenseBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@IEAA@XZ ENDP ; Eigen::DenseBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> > >::DenseBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densebase.h
;	COMDAT ??0?$DenseBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@Eigen@@IEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$DenseBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@Eigen@@IEAA@XZ PROC ; Eigen::DenseBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4> >::DenseBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4> >, COMDAT

; 504  :     {
; 505  :       /* Just checks for self-consistency of the flags.
; 506  :        * Only do it when debugging Eigen, as this borders on paranoiac and could slow compilation down
; 507  :        */
; 508  : #ifdef EIGEN_INTERNAL_DEBUGGING
; 509  :       EIGEN_STATIC_ASSERT((EIGEN_IMPLIES(MaxRowsAtCompileTime==1 && MaxColsAtCompileTime!=1, int(IsRowMajor))
; 510  :                         && EIGEN_IMPLIES(MaxColsAtCompileTime==1 && MaxRowsAtCompileTime!=1, int(!IsRowMajor))),
; 511  :                           INVALID_STORAGE_ORDER_FOR_THIS_VECTOR_EXPRESSION)
; 512  : #endif
; 513  :     }

	mov	rax, rcx
	ret	0
??0?$DenseBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@Eigen@@IEAA@XZ ENDP ; Eigen::DenseBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4> >::DenseBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
;	COMDAT ??$_set_noalias@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@IEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$DenseBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 48
other$ = 56
??$_set_noalias@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@IEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$DenseBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z PROC ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,1,0,-1,1> >::_set_noalias<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const >,4> >, COMDAT

; 614  :     EIGEN_STRONG_INLINE Derived& _set_noalias(const DenseBase<OtherDerived>& other)

$LN240:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rax, QWORD PTR [rdx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 614  :     EIGEN_STRONG_INLINE Derived& _set_noalias(const DenseBase<OtherDerived>& other)

	mov	rsi, rdx
	mov	rdi, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rbx, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	mov	rbp, 9223372036854775807		; 7fffffffffffffffH
	test	rbx, rbx
	je	SHORT $LN235@set_noalia
	cmp	rbx, rbp
	setg	al

; 45   :     if (error)

	test	al, al
	jne	SHORT $LN237@set_noalia

; 47   :   }
; 48   : };
; 49   : 
; 50   : template <typename Derived,
; 51   :           typename OtherDerived = Derived,
; 52   :           bool IsVector = bool(Derived::IsVectorAtCompileTime) && bool(OtherDerived::IsVectorAtCompileTime)>
; 53   : struct conservative_resize_like_impl;
; 54   : 
; 55   : template<typename MatrixTypeA, typename MatrixTypeB, bool SwapPointers> struct matrix_swap_impl;
; 56   : 
; 57   : } // end namespace internal
; 58   : 
; 59   : /** \class PlainObjectBase
; 60   :   * \brief %Dense storage base class for matrices and arrays.
; 61   :   *
; 62   :   * This class can be extended with the help of the plugin mechanism described on the page
; 63   :   * \ref TopicCustomizingEigen by defining the preprocessor symbol \c EIGEN_PLAINOBJECTBASE_PLUGIN.
; 64   :   *
; 65   :   * \sa \ref TopicClassHierarchy
; 66   :   */
; 67   : #ifdef EIGEN_PARSED_BY_DOXYGEN
; 68   : namespace internal {
; 69   : 
; 70   : // this is a warkaround to doxygen not being able to understand the inheritence logic
; 71   : // when it is hidden by the dense_xpr_base helper struct.
; 72   : template<typename Derived> struct dense_xpr_base_dispatcher_for_doxygen;// : public MatrixBase<Derived> {};
; 73   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 74   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 75   : struct dense_xpr_base_dispatcher_for_doxygen<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 76   :     : public MatrixBase<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 77   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 78   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 79   : struct dense_xpr_base_dispatcher_for_doxygen<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 80   :     : public ArrayBase<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 81   : 
; 82   : } // namespace internal
; 83   : 
; 84   : template<typename Derived>
; 85   : class PlainObjectBase : public internal::dense_xpr_base_dispatcher_for_doxygen<Derived>
; 86   : #else
; 87   : template<typename Derived>
; 88   : class PlainObjectBase : public internal::dense_xpr_base<Derived>::type
; 89   : #endif
; 90   : {
; 91   :   public:
; 92   :     enum { Options = internal::traits<Derived>::Options };
; 93   :     typedef typename internal::dense_xpr_base<Derived>::type Base;
; 94   : 
; 95   :     typedef typename internal::traits<Derived>::StorageKind StorageKind;
; 96   :     typedef typename internal::traits<Derived>::Index Index;
; 97   :     typedef typename internal::traits<Derived>::Scalar Scalar;
; 98   :     typedef typename internal::packet_traits<Scalar>::type PacketScalar;
; 99   :     typedef typename NumTraits<Scalar>::Real RealScalar;
; 100  :     typedef Derived DenseType;
; 101  : 
; 102  :     using Base::RowsAtCompileTime;
; 103  :     using Base::ColsAtCompileTime;
; 104  :     using Base::SizeAtCompileTime;
; 105  :     using Base::MaxRowsAtCompileTime;
; 106  :     using Base::MaxColsAtCompileTime;
; 107  :     using Base::MaxSizeAtCompileTime;
; 108  :     using Base::IsVectorAtCompileTime;
; 109  :     using Base::Flags;
; 110  : 
; 111  :     template<typename PlainObjectType, int MapOptions, typename StrideType> friend class Eigen::Map;
; 112  :     friend  class Eigen::Map<Derived, Unaligned>;
; 113  :     typedef Eigen::Map<Derived, Unaligned>  MapType;
; 114  :     friend  class Eigen::Map<const Derived, Unaligned>;
; 115  :     typedef const Eigen::Map<const Derived, Unaligned> ConstMapType;
; 116  :     friend  class Eigen::Map<Derived, Aligned>;
; 117  :     typedef Eigen::Map<Derived, Aligned> AlignedMapType;
; 118  :     friend  class Eigen::Map<const Derived, Aligned>;
; 119  :     typedef const Eigen::Map<const Derived, Aligned> ConstAlignedMapType;
; 120  :     template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };
; 121  :     template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };
; 122  :     template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, Aligned, StrideType> type; };
; 123  :     template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, Aligned, StrideType> type; };
; 124  : 
; 125  :   protected:
; 126  :     DenseStorage<Scalar, Base::MaxSizeAtCompileTime, Base::RowsAtCompileTime, Base::ColsAtCompileTime, Options> m_storage;
; 127  : 
; 128  :   public:
; 129  :     enum { NeedsToAlign = SizeAtCompileTime != Dynamic && (internal::traits<Derived>::Flags & AlignedBit) != 0 };
; 130  :     EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(NeedsToAlign)
; 131  : 
; 132  :     Base& base() { return *static_cast<Base*>(this); }
; 133  :     const Base& base() const { return *static_cast<const Base*>(this); }
; 134  : 
; 135  :     EIGEN_STRONG_INLINE Index rows() const { return m_storage.rows(); }
; 136  :     EIGEN_STRONG_INLINE Index cols() const { return m_storage.cols(); }
; 137  : 
; 138  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index rowId, Index colId) const
; 139  :     {
; 140  :       if(Flags & RowMajorBit)
; 141  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 142  :       else // column-major
; 143  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 144  :     }
; 145  : 
; 146  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index index) const
; 147  :     {
; 148  :       return m_storage.data()[index];
; 149  :     }
; 150  : 
; 151  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index rowId, Index colId)
; 152  :     {
; 153  :       if(Flags & RowMajorBit)
; 154  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 155  :       else // column-major
; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 157  :     }
; 158  : 
; 159  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
; 160  :     {
; 161  :       return m_storage.data()[index];
; 162  :     }
; 163  : 
; 164  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
; 165  :     {
; 166  :       if(Flags & RowMajorBit)
; 167  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 168  :       else // column-major
; 169  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 170  :     }
; 171  : 
; 172  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
; 173  :     {
; 174  :       return m_storage.data()[index];
; 175  :     }
; 176  : 
; 177  :     /** \internal */
; 178  :     template<int LoadMode>
; 179  :     EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const
; 180  :     {
; 181  :       return internal::ploadt<PacketScalar, LoadMode>
; 182  :                (m_storage.data() + (Flags & RowMajorBit
; 183  :                                    ? colId + rowId * m_storage.cols()
; 184  :                                    : rowId + colId * m_storage.rows()));
; 185  :     }
; 186  : 
; 187  :     /** \internal */
; 188  :     template<int LoadMode>
; 189  :     EIGEN_STRONG_INLINE PacketScalar packet(Index index) const
; 190  :     {
; 191  :       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);
; 192  :     }
; 193  : 
; 194  :     /** \internal */
; 195  :     template<int StoreMode>
; 196  :     EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)
; 197  :     {
; 198  :       internal::pstoret<Scalar, PacketScalar, StoreMode>
; 199  :               (m_storage.data() + (Flags & RowMajorBit
; 200  :                                    ? colId + rowId * m_storage.cols()
; 201  :                                    : rowId + colId * m_storage.rows()), val);
; 202  :     }
; 203  : 
; 204  :     /** \internal */
; 205  :     template<int StoreMode>
; 206  :     EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
; 207  :     {
; 208  :       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
; 209  :     }
; 210  : 
; 211  :     /** \returns a const pointer to the data array of this matrix */
; 212  :     EIGEN_STRONG_INLINE const Scalar *data() const
; 213  :     { return m_storage.data(); }
; 214  : 
; 215  :     /** \returns a pointer to the data array of this matrix */
; 216  :     EIGEN_STRONG_INLINE Scalar *data()
; 217  :     { return m_storage.data(); }
; 218  : 
; 219  :     /** Resizes \c *this to a \a rows x \a cols matrix.
; 220  :       *
; 221  :       * This method is intended for dynamic-size matrices, although it is legal to call it on any
; 222  :       * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
; 223  :       * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
; 224  :       *
; 225  :       * If the current number of coefficients of \c *this exactly matches the
; 226  :       * product \a rows * \a cols, then no memory allocation is performed and
; 227  :       * the current values are left unchanged. In all other cases, including
; 228  :       * shrinking, the data is reallocated and all previous values are lost.
; 229  :       *
; 230  :       * Example: \include Matrix_resize_int_int.cpp
; 231  :       * Output: \verbinclude Matrix_resize_int_int.out
; 232  :       *
; 233  :       * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
; 234  :       */
; 235  :     EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)
; 236  :     {
; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rbx, rbx
$LN235@set_noalia:
	jns	SHORT $LN140@set_noalia
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	mov	r8d, 241				; 000000f1H
	call	QWORD PTR __imp__wassert
$LN140@set_noalia:

; 44   :                : (rows > max_index / cols);

	test	rbx, rbx
	je	SHORT $LN147@set_noalia
	cmp	rbx, rbp
	setg	al

; 45   :     if (error)

	test	al, al
	jne	SHORT $LN239@set_noalia
$LN147@set_noalia:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 322  :       if(size != m_rows*_Cols)

	cmp	rbx, QWORD PTR [rdi+8]
	je	SHORT $LN152@set_noalia
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR [rdi]
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 325  :         if (size)

	test	rbx, rbx
	je	SHORT $LN153@set_noalia

; 326  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

	mov	rcx, rbx
	call	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
	mov	QWORD PTR [rdi], rax

; 327  :         else

	jmp	SHORT $LN152@set_noalia
$LN153@set_noalia:

; 328  :           m_data = 0;

	mov	QWORD PTR [rdi], 0
$LN152@set_noalia:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h

; 284  :   other.derived().evalTo(derived());

	mov	rdx, rdi
	mov	rcx, rsi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 331  :       m_rows = nbRows;

	mov	QWORD PTR [rdi+8], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h

; 284  :   other.derived().evalTo(derived());

	call	??$evalTo@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEBAXAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@@Z ; Eigen::ProductBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const > >::evalTo<Eigen::Matrix<double,-1,1,0,-1,1> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 622  :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN237@set_noalia:

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN239@set_noalia:
	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN234@set_noalia:
??$_set_noalias@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@IEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$DenseBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z ENDP ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,1,0,-1,1> >::_set_noalias<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const >,4> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
;	COMDAT ??$_set_noalias@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@IEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$DenseBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 48
other$ = 56
??$_set_noalias@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@IEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$DenseBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z PROC ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,1,0,-1,1> >::_set_noalias<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4> >, COMDAT

; 614  :     EIGEN_STRONG_INLINE Derived& _set_noalias(const DenseBase<OtherDerived>& other)

$LN240:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rax, QWORD PTR [rdx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 614  :     EIGEN_STRONG_INLINE Derived& _set_noalias(const DenseBase<OtherDerived>& other)

	mov	rsi, rdx
	mov	rdi, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rbx, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	mov	rbp, 9223372036854775807		; 7fffffffffffffffH
	test	rbx, rbx
	je	SHORT $LN235@set_noalia
	cmp	rbx, rbp
	setg	al

; 45   :     if (error)

	test	al, al
	jne	SHORT $LN237@set_noalia

; 47   :   }
; 48   : };
; 49   : 
; 50   : template <typename Derived,
; 51   :           typename OtherDerived = Derived,
; 52   :           bool IsVector = bool(Derived::IsVectorAtCompileTime) && bool(OtherDerived::IsVectorAtCompileTime)>
; 53   : struct conservative_resize_like_impl;
; 54   : 
; 55   : template<typename MatrixTypeA, typename MatrixTypeB, bool SwapPointers> struct matrix_swap_impl;
; 56   : 
; 57   : } // end namespace internal
; 58   : 
; 59   : /** \class PlainObjectBase
; 60   :   * \brief %Dense storage base class for matrices and arrays.
; 61   :   *
; 62   :   * This class can be extended with the help of the plugin mechanism described on the page
; 63   :   * \ref TopicCustomizingEigen by defining the preprocessor symbol \c EIGEN_PLAINOBJECTBASE_PLUGIN.
; 64   :   *
; 65   :   * \sa \ref TopicClassHierarchy
; 66   :   */
; 67   : #ifdef EIGEN_PARSED_BY_DOXYGEN
; 68   : namespace internal {
; 69   : 
; 70   : // this is a warkaround to doxygen not being able to understand the inheritence logic
; 71   : // when it is hidden by the dense_xpr_base helper struct.
; 72   : template<typename Derived> struct dense_xpr_base_dispatcher_for_doxygen;// : public MatrixBase<Derived> {};
; 73   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 74   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 75   : struct dense_xpr_base_dispatcher_for_doxygen<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 76   :     : public MatrixBase<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 77   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 78   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 79   : struct dense_xpr_base_dispatcher_for_doxygen<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 80   :     : public ArrayBase<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 81   : 
; 82   : } // namespace internal
; 83   : 
; 84   : template<typename Derived>
; 85   : class PlainObjectBase : public internal::dense_xpr_base_dispatcher_for_doxygen<Derived>
; 86   : #else
; 87   : template<typename Derived>
; 88   : class PlainObjectBase : public internal::dense_xpr_base<Derived>::type
; 89   : #endif
; 90   : {
; 91   :   public:
; 92   :     enum { Options = internal::traits<Derived>::Options };
; 93   :     typedef typename internal::dense_xpr_base<Derived>::type Base;
; 94   : 
; 95   :     typedef typename internal::traits<Derived>::StorageKind StorageKind;
; 96   :     typedef typename internal::traits<Derived>::Index Index;
; 97   :     typedef typename internal::traits<Derived>::Scalar Scalar;
; 98   :     typedef typename internal::packet_traits<Scalar>::type PacketScalar;
; 99   :     typedef typename NumTraits<Scalar>::Real RealScalar;
; 100  :     typedef Derived DenseType;
; 101  : 
; 102  :     using Base::RowsAtCompileTime;
; 103  :     using Base::ColsAtCompileTime;
; 104  :     using Base::SizeAtCompileTime;
; 105  :     using Base::MaxRowsAtCompileTime;
; 106  :     using Base::MaxColsAtCompileTime;
; 107  :     using Base::MaxSizeAtCompileTime;
; 108  :     using Base::IsVectorAtCompileTime;
; 109  :     using Base::Flags;
; 110  : 
; 111  :     template<typename PlainObjectType, int MapOptions, typename StrideType> friend class Eigen::Map;
; 112  :     friend  class Eigen::Map<Derived, Unaligned>;
; 113  :     typedef Eigen::Map<Derived, Unaligned>  MapType;
; 114  :     friend  class Eigen::Map<const Derived, Unaligned>;
; 115  :     typedef const Eigen::Map<const Derived, Unaligned> ConstMapType;
; 116  :     friend  class Eigen::Map<Derived, Aligned>;
; 117  :     typedef Eigen::Map<Derived, Aligned> AlignedMapType;
; 118  :     friend  class Eigen::Map<const Derived, Aligned>;
; 119  :     typedef const Eigen::Map<const Derived, Aligned> ConstAlignedMapType;
; 120  :     template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };
; 121  :     template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };
; 122  :     template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, Aligned, StrideType> type; };
; 123  :     template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, Aligned, StrideType> type; };
; 124  : 
; 125  :   protected:
; 126  :     DenseStorage<Scalar, Base::MaxSizeAtCompileTime, Base::RowsAtCompileTime, Base::ColsAtCompileTime, Options> m_storage;
; 127  : 
; 128  :   public:
; 129  :     enum { NeedsToAlign = SizeAtCompileTime != Dynamic && (internal::traits<Derived>::Flags & AlignedBit) != 0 };
; 130  :     EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(NeedsToAlign)
; 131  : 
; 132  :     Base& base() { return *static_cast<Base*>(this); }
; 133  :     const Base& base() const { return *static_cast<const Base*>(this); }
; 134  : 
; 135  :     EIGEN_STRONG_INLINE Index rows() const { return m_storage.rows(); }
; 136  :     EIGEN_STRONG_INLINE Index cols() const { return m_storage.cols(); }
; 137  : 
; 138  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index rowId, Index colId) const
; 139  :     {
; 140  :       if(Flags & RowMajorBit)
; 141  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 142  :       else // column-major
; 143  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 144  :     }
; 145  : 
; 146  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index index) const
; 147  :     {
; 148  :       return m_storage.data()[index];
; 149  :     }
; 150  : 
; 151  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index rowId, Index colId)
; 152  :     {
; 153  :       if(Flags & RowMajorBit)
; 154  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 155  :       else // column-major
; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 157  :     }
; 158  : 
; 159  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
; 160  :     {
; 161  :       return m_storage.data()[index];
; 162  :     }
; 163  : 
; 164  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
; 165  :     {
; 166  :       if(Flags & RowMajorBit)
; 167  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 168  :       else // column-major
; 169  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 170  :     }
; 171  : 
; 172  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
; 173  :     {
; 174  :       return m_storage.data()[index];
; 175  :     }
; 176  : 
; 177  :     /** \internal */
; 178  :     template<int LoadMode>
; 179  :     EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const
; 180  :     {
; 181  :       return internal::ploadt<PacketScalar, LoadMode>
; 182  :                (m_storage.data() + (Flags & RowMajorBit
; 183  :                                    ? colId + rowId * m_storage.cols()
; 184  :                                    : rowId + colId * m_storage.rows()));
; 185  :     }
; 186  : 
; 187  :     /** \internal */
; 188  :     template<int LoadMode>
; 189  :     EIGEN_STRONG_INLINE PacketScalar packet(Index index) const
; 190  :     {
; 191  :       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);
; 192  :     }
; 193  : 
; 194  :     /** \internal */
; 195  :     template<int StoreMode>
; 196  :     EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)
; 197  :     {
; 198  :       internal::pstoret<Scalar, PacketScalar, StoreMode>
; 199  :               (m_storage.data() + (Flags & RowMajorBit
; 200  :                                    ? colId + rowId * m_storage.cols()
; 201  :                                    : rowId + colId * m_storage.rows()), val);
; 202  :     }
; 203  : 
; 204  :     /** \internal */
; 205  :     template<int StoreMode>
; 206  :     EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
; 207  :     {
; 208  :       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
; 209  :     }
; 210  : 
; 211  :     /** \returns a const pointer to the data array of this matrix */
; 212  :     EIGEN_STRONG_INLINE const Scalar *data() const
; 213  :     { return m_storage.data(); }
; 214  : 
; 215  :     /** \returns a pointer to the data array of this matrix */
; 216  :     EIGEN_STRONG_INLINE Scalar *data()
; 217  :     { return m_storage.data(); }
; 218  : 
; 219  :     /** Resizes \c *this to a \a rows x \a cols matrix.
; 220  :       *
; 221  :       * This method is intended for dynamic-size matrices, although it is legal to call it on any
; 222  :       * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
; 223  :       * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
; 224  :       *
; 225  :       * If the current number of coefficients of \c *this exactly matches the
; 226  :       * product \a rows * \a cols, then no memory allocation is performed and
; 227  :       * the current values are left unchanged. In all other cases, including
; 228  :       * shrinking, the data is reallocated and all previous values are lost.
; 229  :       *
; 230  :       * Example: \include Matrix_resize_int_int.cpp
; 231  :       * Output: \verbinclude Matrix_resize_int_int.out
; 232  :       *
; 233  :       * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
; 234  :       */
; 235  :     EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)
; 236  :     {
; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rbx, rbx
$LN235@set_noalia:
	jns	SHORT $LN140@set_noalia
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	mov	r8d, 241				; 000000f1H
	call	QWORD PTR __imp__wassert
$LN140@set_noalia:

; 44   :                : (rows > max_index / cols);

	test	rbx, rbx
	je	SHORT $LN147@set_noalia
	cmp	rbx, rbp
	setg	al

; 45   :     if (error)

	test	al, al
	jne	SHORT $LN239@set_noalia
$LN147@set_noalia:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 322  :       if(size != m_rows*_Cols)

	cmp	rbx, QWORD PTR [rdi+8]
	je	SHORT $LN152@set_noalia
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR [rdi]
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 325  :         if (size)

	test	rbx, rbx
	je	SHORT $LN153@set_noalia

; 326  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

	mov	rcx, rbx
	call	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
	mov	QWORD PTR [rdi], rax

; 327  :         else

	jmp	SHORT $LN152@set_noalia
$LN153@set_noalia:

; 328  :           m_data = 0;

	mov	QWORD PTR [rdi], 0
$LN152@set_noalia:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h

; 284  :   other.derived().evalTo(derived());

	mov	rdx, rdi
	mov	rcx, rsi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 331  :       m_rows = nbRows;

	mov	QWORD PTR [rdi+8], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h

; 284  :   other.derived().evalTo(derived());

	call	??$evalTo@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEBAXAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@@Z ; Eigen::ProductBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >::evalTo<Eigen::Matrix<double,-1,1,0,-1,1> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 622  :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN237@set_noalia:

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN239@set_noalia:
	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN234@set_noalia:
??$_set_noalias@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@IEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$DenseBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z ENDP ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,1,0,-1,1> >::_set_noalias<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
;	COMDAT ??$_set@V?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@IEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$DenseBase@V?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 64
other$ = 72
??$_set@V?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@IEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$DenseBase@V?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@@1@@Z PROC ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,1,0,-1,1> >::_set<Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>,Eigen::ReturnByValue<Eigen::internal::solve_retval_base<Eigen::PartialPivLU<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::Matrix<double,-1,1,0,-1,1> > > const > >, COMDAT

; 596  :     EIGEN_STRONG_INLINE Derived& _set(const DenseBase<OtherDerived>& other)

$LN379:
	push	rbx
	push	rbp
	push	rsi
	sub	rsp, 32					; 00000020H
	mov	rsi, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	test	rdx, rdx
	je	SHORT $LN15@set
	lea	rax, QWORD PTR [rdx-1]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 606  :     EIGEN_STRONG_INLINE void _set_selector(const OtherDerived& other, const internal::false_type&) { _set_noalias(other); }

	test	rax, rax
	je	SHORT $LN15@set
	inc	rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	je	SHORT $LN15@set
	dec	rax
	jmp	SHORT $LN16@set
$LN15@set:
	xor	eax, eax
$LN16@set:
	mov	QWORD PTR [rsp+80], rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 520  :   static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }

	inc	rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	je	SHORT $LN21@set
	lea	rdi, QWORD PTR [rax-1]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 520  :   static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }

	test	rdi, rdi
	je	SHORT $LN21@set
	inc	rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	je	SHORT $LN43@set
	lea	rbx, QWORD PTR [rdi-1]
	jmp	SHORT $LN44@set
$LN21@set:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 520  :   static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }

	xor	edi, edi
$LN43@set:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	xor	ebx, ebx
$LN44@set:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 313  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rbx, QWORD PTR [rbx+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	mov	rbp, 9223372036854775807		; 7fffffffffffffffH
	test	rbx, rbx
	je	SHORT $LN374@set
	cmp	rbx, rbp
	setg	al

; 45   :     if (error)

	test	al, al
	jne	$LN376@set

; 47   :   }
; 48   : };
; 49   : 
; 50   : template <typename Derived,
; 51   :           typename OtherDerived = Derived,
; 52   :           bool IsVector = bool(Derived::IsVectorAtCompileTime) && bool(OtherDerived::IsVectorAtCompileTime)>
; 53   : struct conservative_resize_like_impl;
; 54   : 
; 55   : template<typename MatrixTypeA, typename MatrixTypeB, bool SwapPointers> struct matrix_swap_impl;
; 56   : 
; 57   : } // end namespace internal
; 58   : 
; 59   : /** \class PlainObjectBase
; 60   :   * \brief %Dense storage base class for matrices and arrays.
; 61   :   *
; 62   :   * This class can be extended with the help of the plugin mechanism described on the page
; 63   :   * \ref TopicCustomizingEigen by defining the preprocessor symbol \c EIGEN_PLAINOBJECTBASE_PLUGIN.
; 64   :   *
; 65   :   * \sa \ref TopicClassHierarchy
; 66   :   */
; 67   : #ifdef EIGEN_PARSED_BY_DOXYGEN
; 68   : namespace internal {
; 69   : 
; 70   : // this is a warkaround to doxygen not being able to understand the inheritence logic
; 71   : // when it is hidden by the dense_xpr_base helper struct.
; 72   : template<typename Derived> struct dense_xpr_base_dispatcher_for_doxygen;// : public MatrixBase<Derived> {};
; 73   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 74   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 75   : struct dense_xpr_base_dispatcher_for_doxygen<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 76   :     : public MatrixBase<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 77   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 78   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 79   : struct dense_xpr_base_dispatcher_for_doxygen<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 80   :     : public ArrayBase<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 81   : 
; 82   : } // namespace internal
; 83   : 
; 84   : template<typename Derived>
; 85   : class PlainObjectBase : public internal::dense_xpr_base_dispatcher_for_doxygen<Derived>
; 86   : #else
; 87   : template<typename Derived>
; 88   : class PlainObjectBase : public internal::dense_xpr_base<Derived>::type
; 89   : #endif
; 90   : {
; 91   :   public:
; 92   :     enum { Options = internal::traits<Derived>::Options };
; 93   :     typedef typename internal::dense_xpr_base<Derived>::type Base;
; 94   : 
; 95   :     typedef typename internal::traits<Derived>::StorageKind StorageKind;
; 96   :     typedef typename internal::traits<Derived>::Index Index;
; 97   :     typedef typename internal::traits<Derived>::Scalar Scalar;
; 98   :     typedef typename internal::packet_traits<Scalar>::type PacketScalar;
; 99   :     typedef typename NumTraits<Scalar>::Real RealScalar;
; 100  :     typedef Derived DenseType;
; 101  : 
; 102  :     using Base::RowsAtCompileTime;
; 103  :     using Base::ColsAtCompileTime;
; 104  :     using Base::SizeAtCompileTime;
; 105  :     using Base::MaxRowsAtCompileTime;
; 106  :     using Base::MaxColsAtCompileTime;
; 107  :     using Base::MaxSizeAtCompileTime;
; 108  :     using Base::IsVectorAtCompileTime;
; 109  :     using Base::Flags;
; 110  : 
; 111  :     template<typename PlainObjectType, int MapOptions, typename StrideType> friend class Eigen::Map;
; 112  :     friend  class Eigen::Map<Derived, Unaligned>;
; 113  :     typedef Eigen::Map<Derived, Unaligned>  MapType;
; 114  :     friend  class Eigen::Map<const Derived, Unaligned>;
; 115  :     typedef const Eigen::Map<const Derived, Unaligned> ConstMapType;
; 116  :     friend  class Eigen::Map<Derived, Aligned>;
; 117  :     typedef Eigen::Map<Derived, Aligned> AlignedMapType;
; 118  :     friend  class Eigen::Map<const Derived, Aligned>;
; 119  :     typedef const Eigen::Map<const Derived, Aligned> ConstAlignedMapType;
; 120  :     template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };
; 121  :     template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };
; 122  :     template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, Aligned, StrideType> type; };
; 123  :     template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, Aligned, StrideType> type; };
; 124  : 
; 125  :   protected:
; 126  :     DenseStorage<Scalar, Base::MaxSizeAtCompileTime, Base::RowsAtCompileTime, Base::ColsAtCompileTime, Options> m_storage;
; 127  : 
; 128  :   public:
; 129  :     enum { NeedsToAlign = SizeAtCompileTime != Dynamic && (internal::traits<Derived>::Flags & AlignedBit) != 0 };
; 130  :     EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(NeedsToAlign)
; 131  : 
; 132  :     Base& base() { return *static_cast<Base*>(this); }
; 133  :     const Base& base() const { return *static_cast<const Base*>(this); }
; 134  : 
; 135  :     EIGEN_STRONG_INLINE Index rows() const { return m_storage.rows(); }
; 136  :     EIGEN_STRONG_INLINE Index cols() const { return m_storage.cols(); }
; 137  : 
; 138  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index rowId, Index colId) const
; 139  :     {
; 140  :       if(Flags & RowMajorBit)
; 141  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 142  :       else // column-major
; 143  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 144  :     }
; 145  : 
; 146  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index index) const
; 147  :     {
; 148  :       return m_storage.data()[index];
; 149  :     }
; 150  : 
; 151  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index rowId, Index colId)
; 152  :     {
; 153  :       if(Flags & RowMajorBit)
; 154  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 155  :       else // column-major
; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 157  :     }
; 158  : 
; 159  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
; 160  :     {
; 161  :       return m_storage.data()[index];
; 162  :     }
; 163  : 
; 164  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
; 165  :     {
; 166  :       if(Flags & RowMajorBit)
; 167  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 168  :       else // column-major
; 169  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 170  :     }
; 171  : 
; 172  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
; 173  :     {
; 174  :       return m_storage.data()[index];
; 175  :     }
; 176  : 
; 177  :     /** \internal */
; 178  :     template<int LoadMode>
; 179  :     EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const
; 180  :     {
; 181  :       return internal::ploadt<PacketScalar, LoadMode>
; 182  :                (m_storage.data() + (Flags & RowMajorBit
; 183  :                                    ? colId + rowId * m_storage.cols()
; 184  :                                    : rowId + colId * m_storage.rows()));
; 185  :     }
; 186  : 
; 187  :     /** \internal */
; 188  :     template<int LoadMode>
; 189  :     EIGEN_STRONG_INLINE PacketScalar packet(Index index) const
; 190  :     {
; 191  :       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);
; 192  :     }
; 193  : 
; 194  :     /** \internal */
; 195  :     template<int StoreMode>
; 196  :     EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)
; 197  :     {
; 198  :       internal::pstoret<Scalar, PacketScalar, StoreMode>
; 199  :               (m_storage.data() + (Flags & RowMajorBit
; 200  :                                    ? colId + rowId * m_storage.cols()
; 201  :                                    : rowId + colId * m_storage.rows()), val);
; 202  :     }
; 203  : 
; 204  :     /** \internal */
; 205  :     template<int StoreMode>
; 206  :     EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
; 207  :     {
; 208  :       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
; 209  :     }
; 210  : 
; 211  :     /** \returns a const pointer to the data array of this matrix */
; 212  :     EIGEN_STRONG_INLINE const Scalar *data() const
; 213  :     { return m_storage.data(); }
; 214  : 
; 215  :     /** \returns a pointer to the data array of this matrix */
; 216  :     EIGEN_STRONG_INLINE Scalar *data()
; 217  :     { return m_storage.data(); }
; 218  : 
; 219  :     /** Resizes \c *this to a \a rows x \a cols matrix.
; 220  :       *
; 221  :       * This method is intended for dynamic-size matrices, although it is legal to call it on any
; 222  :       * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
; 223  :       * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
; 224  :       *
; 225  :       * If the current number of coefficients of \c *this exactly matches the
; 226  :       * product \a rows * \a cols, then no memory allocation is performed and
; 227  :       * the current values are left unchanged. In all other cases, including
; 228  :       * shrinking, the data is reallocated and all previous values are lost.
; 229  :       *
; 230  :       * Example: \include Matrix_resize_int_int.cpp
; 231  :       * Output: \verbinclude Matrix_resize_int_int.out
; 232  :       *
; 233  :       * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
; 234  :       */
; 235  :     EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)
; 236  :     {
; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rbx, rbx
$LN374@set:
	jns	SHORT $LN136@set
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	mov	r8d, 241				; 000000f1H
	call	QWORD PTR __imp__wassert
$LN136@set:

; 44   :                : (rows > max_index / cols);

	test	rbx, rbx
	je	SHORT $LN143@set
	cmp	rbx, rbp
	setg	al

; 45   :     if (error)

	test	al, al
	jne	$LN378@set
$LN143@set:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 322  :       if(size != m_rows*_Cols)

	cmp	rbx, QWORD PTR [rsi+8]
	je	SHORT $LN148@set
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR [rsi]
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 325  :         if (size)

	test	rbx, rbx
	je	SHORT $LN149@set

; 326  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

	mov	rcx, rbx
	call	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
	mov	QWORD PTR [rsi], rax

; 327  :         else

	jmp	SHORT $LN148@set
$LN149@set:

; 328  :           m_data = 0;

	mov	QWORD PTR [rsi], 0
$LN148@set:

; 329  :         EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN
; 330  :       }
; 331  :       m_rows = nbRows;

	mov	QWORD PTR [rsi+8], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	test	rdi, rdi
	je	SHORT $LN29@set
	dec	rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 414  :       return Base::lazyAssign(other.derived());

	je	SHORT $LN29@set
	inc	rdi
	jmp	SHORT $LN30@set
$LN29@set:
	xor	edi, edi
$LN30@set:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	test	rdi, rdi
	je	SHORT $LN232@set
	lea	rax, QWORD PTR [rdi-1]
	jmp	SHORT $LN233@set
$LN232@set:
	xor	eax, eax
$LN233@set:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	cmp	rbx, QWORD PTR [rax+16]
	je	SHORT $LN219@set
	lea	rdx, OFFSET FLAT:??_C@_1KO@HDGCFKMN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GC@PBCDNLIH@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ@
	mov	r8d, 498				; 000001f2H
	call	QWORD PTR __imp__wassert
$LN219@set:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	test	rdi, rdi
	je	SHORT $LN262@set
	lea	rcx, QWORD PTR [rdi-1]
	jmp	SHORT $LN263@set
$LN262@set:
	xor	ecx, ecx
$LN263@set:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 395  :     const Index size = dst.size();

	mov	r11, QWORD PTR [rsi+8]

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	xor	r9d, r9d
	mov	rax, r11
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r10, rax
	add	r10, r10
	test	r10, r10
	jle	SHORT $LN266@set
	movdqa	xmm1, XMMWORD PTR __xmm@80000000000000008000000000000000
$LL268@set:

; 409  :     {
; 410  :       dst.template copyPacket<Derived2, dstAlignment, srcAlignment>(index, src);

	test	rcx, rcx
	je	SHORT $LN311@set
	lea	rax, QWORD PTR [rcx+1]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	test	rax, rax
	je	SHORT $LN311@set
	dec	rax
	jmp	SHORT $LN312@set
$LN311@set:
	xor	eax, eax
$LN312@set:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 538  :         other.derived().template packet<LoadMode>(index));

	inc	rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	je	SHORT $LN317@set
	lea	r8, QWORD PTR [rax-1]
	jmp	SHORT $LN318@set
$LN317@set:
	xor	r8d, r8d
$LN318@set:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	mov	rax, QWORD PTR [rsi]
	lea	rdx, QWORD PTR [rax+r9*8]
	mov	rax, QWORD PTR [r8+8]
	add	r9, 2
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 220  : template<> EIGEN_STRONG_INLINE Packet2d pload<Packet2d>(const double*  from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_pd(from); }

	movaps	xmm0, XMMWORD PTR [rax+r9*8-16]

; 138  :   return _mm_xor_pd(a,mask);

	xorps	xmm0, xmm1

; 221  : template<> EIGEN_STRONG_INLINE Packet4i pload<Packet4i>(const int*     from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_si128(reinterpret_cast<const Packet4i*>(from)); }
; 222  : 
; 223  : #if defined(_MSC_VER)
; 224  :   template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float*  from) {
; 225  :     EIGEN_DEBUG_UNALIGNED_LOAD
; 226  :     #if (_MSC_VER==1600)
; 227  :     // NOTE Some version of MSVC10 generates bad code when using _mm_loadu_ps
; 228  :     // (i.e., it does not generate an unaligned load!!
; 229  :     // TODO On most architectures this version should also be faster than a single _mm_loadu_ps
; 230  :     // so we could also enable it for MSVC08 but first we have to make this later does not generate crap when doing so...
; 231  :     __m128 res = _mm_loadl_pi(_mm_set1_ps(0.0f), (const __m64*)(from));
; 232  :     res = _mm_loadh_pi(res, (const __m64*)(from+2));
; 233  :     return res;
; 234  :     #else
; 235  :     return _mm_loadu_ps(from);
; 236  :     #endif
; 237  :   }
; 238  :   template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm_loadu_pd(from); }
; 239  :   template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int*    from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm_loadu_si128(reinterpret_cast<const Packet4i*>(from)); }
; 240  : #else
; 241  : // Fast unaligned loads. Note that here we cannot directly use intrinsics: this would
; 242  : // require pointer casting to incompatible pointer types and leads to invalid code
; 243  : // because of the strict aliasing rule. The "dummy" stuff are required to enforce
; 244  : // a correct instruction dependency.
; 245  : // TODO: do the same for MSVC (ICC is compatible)
; 246  : // NOTE: with the code below, MSVC's compiler crashes!
; 247  : 
; 248  : #if defined(__GNUC__) && defined(__i386__)
; 249  :   // bug 195: gcc/i386 emits weird x87 fldl/fstpl instructions for _mm_load_sd
; 250  :   #define EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS 1
; 251  : #elif defined(__clang__)
; 252  :   // bug 201: Segfaults in __mm_loadh_pd with clang 2.8
; 253  :   #define EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS 1
; 254  : #else
; 255  :   #define EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS 0
; 256  : #endif
; 257  : 
; 258  : template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float* from)
; 259  : {
; 260  :   EIGEN_DEBUG_UNALIGNED_LOAD
; 261  : #if EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS
; 262  :   return _mm_loadu_ps(from);
; 263  : #else
; 264  :   __m128d res;
; 265  :   res =  _mm_load_sd((const double*)(from)) ;
; 266  :   res =  _mm_loadh_pd(res, (const double*)(from+2)) ;
; 267  :   return _mm_castpd_ps(res);
; 268  : #endif
; 269  : }
; 270  : template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from)
; 271  : {
; 272  :   EIGEN_DEBUG_UNALIGNED_LOAD
; 273  : #if EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS
; 274  :   return _mm_loadu_pd(from);
; 275  : #else
; 276  :   __m128d res;
; 277  :   res = _mm_load_sd(from) ;
; 278  :   res = _mm_loadh_pd(res,from+1);
; 279  :   return res;
; 280  : #endif
; 281  : }
; 282  : template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int* from)
; 283  : {
; 284  :   EIGEN_DEBUG_UNALIGNED_LOAD
; 285  : #if EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS
; 286  :   return _mm_loadu_si128(reinterpret_cast<const Packet4i*>(from));
; 287  : #else
; 288  :   __m128d res;
; 289  :   res =  _mm_load_sd((const double*)(from)) ;
; 290  :   res =  _mm_loadh_pd(res, (const double*)(from+2)) ;
; 291  :   return _mm_castpd_si128(res);
; 292  : #endif
; 293  : }
; 294  : #endif
; 295  : 
; 296  : template<> EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float*   from)
; 297  : {
; 298  :   return vec4f_swizzle1(_mm_castpd_ps(_mm_load_sd(reinterpret_cast<const double*>(from))), 0, 0, 1, 1);
; 299  : }
; 300  : template<> EIGEN_STRONG_INLINE Packet2d ploaddup<Packet2d>(const double*  from)
; 301  : { return pset1<Packet2d>(from[0]); }
; 302  : template<> EIGEN_STRONG_INLINE Packet4i ploaddup<Packet4i>(const int*     from)
; 303  : {
; 304  :   Packet4i tmp;
; 305  :   tmp = _mm_loadl_epi64(reinterpret_cast<const Packet4i*>(from));
; 306  :   return vec4i_swizzle1(tmp, 0, 0, 1, 1);
; 307  : }
; 308  : 
; 309  : template<> EIGEN_STRONG_INLINE void pstore<float>(float*   to, const Packet4f& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_ps(to, from); }
; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [rdx], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	cmp	r9, r10
	jl	SHORT $LL268@set
$LN266@set:

; 411  :     }
; 412  : 
; 413  :     unaligned_assign_impl<>::run(src,dst,alignedEnd,size);

	mov	r9, r11
	mov	r8, r10
	mov	rdx, rsi
	call	??$run@V?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@?$unaligned_assign_impl@$0A@@internal@Eigen@@SAXAEBV?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@2@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@_J2@Z ; Eigen::internal::unaligned_assign_impl<0>::run<Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>,Eigen::ReturnByValue<Eigen::internal::solve_retval_base<Eigen::PartialPivLU<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::Matrix<double,-1,1,0,-1,1> > > const >,Eigen::Matrix<double,-1,1,0,-1,1> >
	mov	rdi, QWORD PTR [rsp+80]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 599  :       return this->derived();

	mov	rax, rsi

; 600  :     }

	add	rsp, 32					; 00000020H
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN376@set:

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN378@set:
	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN373@set:
??$_set@V?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@IEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$DenseBase@V?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@@1@@Z ENDP ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,1,0,-1,1> >::_set<Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>,Eigen::ReturnByValue<Eigen::internal::solve_retval_base<Eigen::PartialPivLU<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::Matrix<double,-1,1,0,-1,1> > > const > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
;	COMDAT ??$_set_noalias@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 64
other$ = 72
??$_set_noalias@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z PROC ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::_set_noalias<Eigen::Matrix<double,-1,1,0,-1,1> >, COMDAT

; 614  :     EIGEN_STRONG_INLINE Derived& _set_noalias(const DenseBase<OtherDerived>& other)

$LN296:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 313  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rsi, QWORD PTR [rdx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 614  :     EIGEN_STRONG_INLINE Derived& _set_noalias(const DenseBase<OtherDerived>& other)

	mov	r14, rdx
	mov	rbx, rcx

; 44   :                : (rows > max_index / cols);

	mov	rdi, 9223372036854775807		; 7fffffffffffffffH
	test	rsi, rsi
	je	SHORT $LN291@set_noalia
	cmp	rsi, rdi
	setg	al

; 45   :     if (error)

	test	al, al
	jne	$LN293@set_noalia

; 47   :   }
; 48   : };
; 49   : 
; 50   : template <typename Derived,
; 51   :           typename OtherDerived = Derived,
; 52   :           bool IsVector = bool(Derived::IsVectorAtCompileTime) && bool(OtherDerived::IsVectorAtCompileTime)>
; 53   : struct conservative_resize_like_impl;
; 54   : 
; 55   : template<typename MatrixTypeA, typename MatrixTypeB, bool SwapPointers> struct matrix_swap_impl;
; 56   : 
; 57   : } // end namespace internal
; 58   : 
; 59   : /** \class PlainObjectBase
; 60   :   * \brief %Dense storage base class for matrices and arrays.
; 61   :   *
; 62   :   * This class can be extended with the help of the plugin mechanism described on the page
; 63   :   * \ref TopicCustomizingEigen by defining the preprocessor symbol \c EIGEN_PLAINOBJECTBASE_PLUGIN.
; 64   :   *
; 65   :   * \sa \ref TopicClassHierarchy
; 66   :   */
; 67   : #ifdef EIGEN_PARSED_BY_DOXYGEN
; 68   : namespace internal {
; 69   : 
; 70   : // this is a warkaround to doxygen not being able to understand the inheritence logic
; 71   : // when it is hidden by the dense_xpr_base helper struct.
; 72   : template<typename Derived> struct dense_xpr_base_dispatcher_for_doxygen;// : public MatrixBase<Derived> {};
; 73   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 74   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 75   : struct dense_xpr_base_dispatcher_for_doxygen<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 76   :     : public MatrixBase<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 77   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 78   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 79   : struct dense_xpr_base_dispatcher_for_doxygen<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 80   :     : public ArrayBase<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 81   : 
; 82   : } // namespace internal
; 83   : 
; 84   : template<typename Derived>
; 85   : class PlainObjectBase : public internal::dense_xpr_base_dispatcher_for_doxygen<Derived>
; 86   : #else
; 87   : template<typename Derived>
; 88   : class PlainObjectBase : public internal::dense_xpr_base<Derived>::type
; 89   : #endif
; 90   : {
; 91   :   public:
; 92   :     enum { Options = internal::traits<Derived>::Options };
; 93   :     typedef typename internal::dense_xpr_base<Derived>::type Base;
; 94   : 
; 95   :     typedef typename internal::traits<Derived>::StorageKind StorageKind;
; 96   :     typedef typename internal::traits<Derived>::Index Index;
; 97   :     typedef typename internal::traits<Derived>::Scalar Scalar;
; 98   :     typedef typename internal::packet_traits<Scalar>::type PacketScalar;
; 99   :     typedef typename NumTraits<Scalar>::Real RealScalar;
; 100  :     typedef Derived DenseType;
; 101  : 
; 102  :     using Base::RowsAtCompileTime;
; 103  :     using Base::ColsAtCompileTime;
; 104  :     using Base::SizeAtCompileTime;
; 105  :     using Base::MaxRowsAtCompileTime;
; 106  :     using Base::MaxColsAtCompileTime;
; 107  :     using Base::MaxSizeAtCompileTime;
; 108  :     using Base::IsVectorAtCompileTime;
; 109  :     using Base::Flags;
; 110  : 
; 111  :     template<typename PlainObjectType, int MapOptions, typename StrideType> friend class Eigen::Map;
; 112  :     friend  class Eigen::Map<Derived, Unaligned>;
; 113  :     typedef Eigen::Map<Derived, Unaligned>  MapType;
; 114  :     friend  class Eigen::Map<const Derived, Unaligned>;
; 115  :     typedef const Eigen::Map<const Derived, Unaligned> ConstMapType;
; 116  :     friend  class Eigen::Map<Derived, Aligned>;
; 117  :     typedef Eigen::Map<Derived, Aligned> AlignedMapType;
; 118  :     friend  class Eigen::Map<const Derived, Aligned>;
; 119  :     typedef const Eigen::Map<const Derived, Aligned> ConstAlignedMapType;
; 120  :     template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };
; 121  :     template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };
; 122  :     template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, Aligned, StrideType> type; };
; 123  :     template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, Aligned, StrideType> type; };
; 124  : 
; 125  :   protected:
; 126  :     DenseStorage<Scalar, Base::MaxSizeAtCompileTime, Base::RowsAtCompileTime, Base::ColsAtCompileTime, Options> m_storage;
; 127  : 
; 128  :   public:
; 129  :     enum { NeedsToAlign = SizeAtCompileTime != Dynamic && (internal::traits<Derived>::Flags & AlignedBit) != 0 };
; 130  :     EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(NeedsToAlign)
; 131  : 
; 132  :     Base& base() { return *static_cast<Base*>(this); }
; 133  :     const Base& base() const { return *static_cast<const Base*>(this); }
; 134  : 
; 135  :     EIGEN_STRONG_INLINE Index rows() const { return m_storage.rows(); }
; 136  :     EIGEN_STRONG_INLINE Index cols() const { return m_storage.cols(); }
; 137  : 
; 138  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index rowId, Index colId) const
; 139  :     {
; 140  :       if(Flags & RowMajorBit)
; 141  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 142  :       else // column-major
; 143  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 144  :     }
; 145  : 
; 146  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index index) const
; 147  :     {
; 148  :       return m_storage.data()[index];
; 149  :     }
; 150  : 
; 151  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index rowId, Index colId)
; 152  :     {
; 153  :       if(Flags & RowMajorBit)
; 154  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 155  :       else // column-major
; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 157  :     }
; 158  : 
; 159  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
; 160  :     {
; 161  :       return m_storage.data()[index];
; 162  :     }
; 163  : 
; 164  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
; 165  :     {
; 166  :       if(Flags & RowMajorBit)
; 167  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 168  :       else // column-major
; 169  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 170  :     }
; 171  : 
; 172  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
; 173  :     {
; 174  :       return m_storage.data()[index];
; 175  :     }
; 176  : 
; 177  :     /** \internal */
; 178  :     template<int LoadMode>
; 179  :     EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const
; 180  :     {
; 181  :       return internal::ploadt<PacketScalar, LoadMode>
; 182  :                (m_storage.data() + (Flags & RowMajorBit
; 183  :                                    ? colId + rowId * m_storage.cols()
; 184  :                                    : rowId + colId * m_storage.rows()));
; 185  :     }
; 186  : 
; 187  :     /** \internal */
; 188  :     template<int LoadMode>
; 189  :     EIGEN_STRONG_INLINE PacketScalar packet(Index index) const
; 190  :     {
; 191  :       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);
; 192  :     }
; 193  : 
; 194  :     /** \internal */
; 195  :     template<int StoreMode>
; 196  :     EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)
; 197  :     {
; 198  :       internal::pstoret<Scalar, PacketScalar, StoreMode>
; 199  :               (m_storage.data() + (Flags & RowMajorBit
; 200  :                                    ? colId + rowId * m_storage.cols()
; 201  :                                    : rowId + colId * m_storage.rows()), val);
; 202  :     }
; 203  : 
; 204  :     /** \internal */
; 205  :     template<int StoreMode>
; 206  :     EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
; 207  :     {
; 208  :       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
; 209  :     }
; 210  : 
; 211  :     /** \returns a const pointer to the data array of this matrix */
; 212  :     EIGEN_STRONG_INLINE const Scalar *data() const
; 213  :     { return m_storage.data(); }
; 214  : 
; 215  :     /** \returns a pointer to the data array of this matrix */
; 216  :     EIGEN_STRONG_INLINE Scalar *data()
; 217  :     { return m_storage.data(); }
; 218  : 
; 219  :     /** Resizes \c *this to a \a rows x \a cols matrix.
; 220  :       *
; 221  :       * This method is intended for dynamic-size matrices, although it is legal to call it on any
; 222  :       * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
; 223  :       * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
; 224  :       *
; 225  :       * If the current number of coefficients of \c *this exactly matches the
; 226  :       * product \a rows * \a cols, then no memory allocation is performed and
; 227  :       * the current values are left unchanged. In all other cases, including
; 228  :       * shrinking, the data is reallocated and all previous values are lost.
; 229  :       *
; 230  :       * Example: \include Matrix_resize_int_int.cpp
; 231  :       * Output: \verbinclude Matrix_resize_int_int.out
; 232  :       *
; 233  :       * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
; 234  :       */
; 235  :     EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)
; 236  :     {
; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rsi, rsi
$LN291@set_noalia:
	jns	SHORT $LN138@set_noalia
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	mov	r8d, 241				; 000000f1H
	call	QWORD PTR __imp__wassert
$LN138@set_noalia:

; 44   :                : (rows > max_index / cols);

	test	rsi, rsi
	je	SHORT $LN145@set_noalia
	cmp	rsi, rdi
	setg	al

; 45   :     if (error)

	test	al, al
	jne	$LN295@set_noalia
$LN145@set_noalia:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 249  :       if(size != m_rows*m_cols)

	mov	rax, QWORD PTR [rbx+16]
	xor	edi, edi
	imul	rax, QWORD PTR [rbx+8]
	cmp	rsi, rax
	je	SHORT $LN150@set_noalia
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR [rbx]
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 252  :         if (size)

	test	rsi, rsi
	je	SHORT $LN151@set_noalia

; 253  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

	mov	rcx, rsi
	call	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
	mov	QWORD PTR [rbx], rax

; 254  :         else

	jmp	SHORT $LN150@set_noalia
$LN151@set_noalia:

; 255  :           m_data = 0;

	mov	QWORD PTR [rbx], rdi
$LN150@set_noalia:

; 256  :         EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN
; 257  :       }
; 258  :       m_rows = nbRows;

	mov	QWORD PTR [rbx+8], rsi

; 259  :       m_cols = nbCols;

	mov	QWORD PTR [rbx+16], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	cmp	rsi, QWORD PTR [r14+8]
	je	SHORT $LN174@set_noalia
	lea	rdx, OFFSET FLAT:??_C@_1KO@HDGCFKMN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GC@PBCDNLIH@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ@
	mov	r8d, 498				; 000001f2H
	call	QWORD PTR __imp__wassert
$LN174@set_noalia:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 49   :   inline Index size() const { return rows() * cols(); }

	mov	r9, QWORD PTR [rbx+16]
	imul	r9, QWORD PTR [rbx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 404  :     const Index alignedEnd = alignedStart + ((size-alignedStart)/packetSize)*packetSize;

	mov	rax, r9
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r8, rax
	add	r8, r8

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	test	r8, r8
	jle	SHORT $LN211@set_noalia
	npad	1
$LL213@set_noalia:
	mov	rdx, QWORD PTR [r14]
	mov	rax, QWORD PTR [rbx]
	add	rdi, 2
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 220  : template<> EIGEN_STRONG_INLINE Packet2d pload<Packet2d>(const double*  from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_pd(from); }

	movaps	xmm0, XMMWORD PTR [rdx+rdi*8-16]

; 221  : template<> EIGEN_STRONG_INLINE Packet4i pload<Packet4i>(const int*     from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_si128(reinterpret_cast<const Packet4i*>(from)); }
; 222  : 
; 223  : #if defined(_MSC_VER)
; 224  :   template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float*  from) {
; 225  :     EIGEN_DEBUG_UNALIGNED_LOAD
; 226  :     #if (_MSC_VER==1600)
; 227  :     // NOTE Some version of MSVC10 generates bad code when using _mm_loadu_ps
; 228  :     // (i.e., it does not generate an unaligned load!!
; 229  :     // TODO On most architectures this version should also be faster than a single _mm_loadu_ps
; 230  :     // so we could also enable it for MSVC08 but first we have to make this later does not generate crap when doing so...
; 231  :     __m128 res = _mm_loadl_pi(_mm_set1_ps(0.0f), (const __m64*)(from));
; 232  :     res = _mm_loadh_pi(res, (const __m64*)(from+2));
; 233  :     return res;
; 234  :     #else
; 235  :     return _mm_loadu_ps(from);
; 236  :     #endif
; 237  :   }
; 238  :   template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm_loadu_pd(from); }
; 239  :   template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int*    from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm_loadu_si128(reinterpret_cast<const Packet4i*>(from)); }
; 240  : #else
; 241  : // Fast unaligned loads. Note that here we cannot directly use intrinsics: this would
; 242  : // require pointer casting to incompatible pointer types and leads to invalid code
; 243  : // because of the strict aliasing rule. The "dummy" stuff are required to enforce
; 244  : // a correct instruction dependency.
; 245  : // TODO: do the same for MSVC (ICC is compatible)
; 246  : // NOTE: with the code below, MSVC's compiler crashes!
; 247  : 
; 248  : #if defined(__GNUC__) && defined(__i386__)
; 249  :   // bug 195: gcc/i386 emits weird x87 fldl/fstpl instructions for _mm_load_sd
; 250  :   #define EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS 1
; 251  : #elif defined(__clang__)
; 252  :   // bug 201: Segfaults in __mm_loadh_pd with clang 2.8
; 253  :   #define EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS 1
; 254  : #else
; 255  :   #define EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS 0
; 256  : #endif
; 257  : 
; 258  : template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float* from)
; 259  : {
; 260  :   EIGEN_DEBUG_UNALIGNED_LOAD
; 261  : #if EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS
; 262  :   return _mm_loadu_ps(from);
; 263  : #else
; 264  :   __m128d res;
; 265  :   res =  _mm_load_sd((const double*)(from)) ;
; 266  :   res =  _mm_loadh_pd(res, (const double*)(from+2)) ;
; 267  :   return _mm_castpd_ps(res);
; 268  : #endif
; 269  : }
; 270  : template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from)
; 271  : {
; 272  :   EIGEN_DEBUG_UNALIGNED_LOAD
; 273  : #if EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS
; 274  :   return _mm_loadu_pd(from);
; 275  : #else
; 276  :   __m128d res;
; 277  :   res = _mm_load_sd(from) ;
; 278  :   res = _mm_loadh_pd(res,from+1);
; 279  :   return res;
; 280  : #endif
; 281  : }
; 282  : template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int* from)
; 283  : {
; 284  :   EIGEN_DEBUG_UNALIGNED_LOAD
; 285  : #if EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS
; 286  :   return _mm_loadu_si128(reinterpret_cast<const Packet4i*>(from));
; 287  : #else
; 288  :   __m128d res;
; 289  :   res =  _mm_load_sd((const double*)(from)) ;
; 290  :   res =  _mm_loadh_pd(res, (const double*)(from+2)) ;
; 291  :   return _mm_castpd_si128(res);
; 292  : #endif
; 293  : }
; 294  : #endif
; 295  : 
; 296  : template<> EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float*   from)
; 297  : {
; 298  :   return vec4f_swizzle1(_mm_castpd_ps(_mm_load_sd(reinterpret_cast<const double*>(from))), 0, 0, 1, 1);
; 299  : }
; 300  : template<> EIGEN_STRONG_INLINE Packet2d ploaddup<Packet2d>(const double*  from)
; 301  : { return pset1<Packet2d>(from[0]); }
; 302  : template<> EIGEN_STRONG_INLINE Packet4i ploaddup<Packet4i>(const int*     from)
; 303  : {
; 304  :   Packet4i tmp;
; 305  :   tmp = _mm_loadl_epi64(reinterpret_cast<const Packet4i*>(from));
; 306  :   return vec4i_swizzle1(tmp, 0, 0, 1, 1);
; 307  : }
; 308  : 
; 309  : template<> EIGEN_STRONG_INLINE void pstore<float>(float*   to, const Packet4f& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_ps(to, from); }
; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [rax+rdi*8-16], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	cmp	rdi, r8
	jl	SHORT $LL213@set_noalia
$LN211@set_noalia:

; 409  :     {
; 410  :       dst.template copyPacket<Derived2, dstAlignment, srcAlignment>(index, src);
; 411  :     }
; 412  : 
; 413  :     unaligned_assign_impl<>::run(src,dst,alignedEnd,size);

	mov	rdx, rbx
	mov	rcx, r14
	call	??$run@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@@?$unaligned_assign_impl@$0A@@internal@Eigen@@SAXAEBV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@_J2@Z ; Eigen::internal::unaligned_assign_impl<0>::run<Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Matrix<double,-1,-1,0,-1,-1> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 621  :       return internal::assign_selector<Derived,OtherDerived,false>::run(this->derived(), other.derived());

	mov	rax, rbx

; 622  :     }

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN293@set_noalia:

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN295@set_noalia:
	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN290@set_noalia:
??$_set_noalias@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z ENDP ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::_set_noalias<Eigen::Matrix<double,-1,1,0,-1,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
;	COMDAT ??$?4V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@?$MatrixBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@QEAAAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@1@AEBV?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 48
other$ = 56
??$?4V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@?$MatrixBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@QEAAAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@1@AEBV?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@1@@Z PROC ; Eigen::MatrixBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> > >::operator=<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >, COMDAT

; 563  : {

$LN48:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h

; 136  :       eigen_assert(rows() == rhs.rows() && cols() == rhs.cols());

	mov	r8, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rdx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 563  : {

	mov	rbx, rdx
	mov	rdi, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h

; 136  :       eigen_assert(rows() == rhs.rows() && cols() == rhs.cols());

	cmp	QWORD PTR [r8+8], rax
	jne	SHORT $LN13@operator
	cmp	QWORD PTR [rdx+16], 1
	je	SHORT $LN14@operator
$LN13@operator:
	lea	rdx, OFFSET FLAT:??_C@_1ME@CGCHACLK@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1FK@JAKLMIFJ@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAr?$AAh?$AAs?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN@
	mov	r8d, 136				; 00000088H
	call	QWORD PTR __imp__wassert
$LN14@operator:

; 137  :       internal::assign_impl<SelfCwiseBinaryOp, RhsDerived>::run(*this,rhs.derived());

	mov	rdx, rbx
	mov	rcx, rdi
	call	?run@?$assign_impl@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@3@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Z ; Eigen::internal::assign_impl<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,4,0,0>::run
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 565  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$?4V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@?$MatrixBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@QEAAAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@1@AEBV?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@1@@Z ENDP ; Eigen::MatrixBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> > >::operator=<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
;	COMDAT ??$lazyAssign@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@1@AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 48
other$ = 56
??$lazyAssign@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@1@AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z PROC ; Eigen::DenseBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::lazyAssign<Eigen::Matrix<double,-1,1,0,-1,1> >, COMDAT

; 486  : {

$LN46:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 487  :   enum{
; 488  :     SameType = internal::is_same<typename Derived::Scalar,typename OtherDerived::Scalar>::value
; 489  :   };
; 490  : 
; 491  :   EIGEN_STATIC_ASSERT_LVALUE(Derived)
; 492  :   EIGEN_STATIC_ASSERT_SAME_MATRIX_SIZE(Derived,OtherDerived)
; 493  :   EIGEN_STATIC_ASSERT(SameType,YOU_MIXED_DIFFERENT_NUMERIC_TYPES__YOU_NEED_TO_USE_THE_CAST_METHOD_OF_MATRIXBASE_TO_CAST_NUMERIC_TYPES_EXPLICITLY)
; 494  : 
; 495  : #ifdef EIGEN_DEBUG_ASSIGN
; 496  :   internal::assign_traits<Derived, OtherDerived>::debug();
; 497  : #endif
; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	mov	rax, QWORD PTR [rdx+8]
	mov	rdi, rdx
	mov	rbx, rcx
	cmp	QWORD PTR [rcx+8], rax
	jne	SHORT $LN3@lazyAssign
	cmp	QWORD PTR [rcx+16], 1
	je	SHORT $LN4@lazyAssign
$LN3@lazyAssign:
	lea	rdx, OFFSET FLAT:??_C@_1KO@HDGCFKMN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GC@PBCDNLIH@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ@
	mov	r8d, 498				; 000001f2H
	call	QWORD PTR __imp__wassert
$LN4@lazyAssign:

; 499  :   internal::assign_impl<Derived, OtherDerived, int(SameType) ? int(internal::assign_traits<Derived, OtherDerived>::Traversal)
; 500  :                                                        : int(InvalidTraversal)>::run(derived(),other.derived());

	mov	rdx, rdi
	mov	rcx, rbx
	call	?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z ; Eigen::internal::assign_impl<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,Eigen::Matrix<double,-1,1,0,-1,1>,4,0,0>::run

; 501  : #ifndef EIGEN_NO_DEBUG
; 502  :   checkTransposeAliasing(other.derived());
; 503  : #endif
; 504  :   return derived();

	mov	rax, rbx

; 505  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$lazyAssign@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@1@AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z ENDP ; Eigen::DenseBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::lazyAssign<Eigen::Matrix<double,-1,1,0,-1,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
;	COMDAT ??$lazyAssign@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@?$DenseBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@1@AEBV?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 48
other$ = 56
??$lazyAssign@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@?$DenseBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@1@AEBV?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@1@@Z PROC ; Eigen::DenseBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::lazyAssign<Eigen::Matrix<double,-1,-1,0,-1,-1> >, COMDAT

; 486  : {

$LN46:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 487  :   enum{
; 488  :     SameType = internal::is_same<typename Derived::Scalar,typename OtherDerived::Scalar>::value
; 489  :   };
; 490  : 
; 491  :   EIGEN_STATIC_ASSERT_LVALUE(Derived)
; 492  :   EIGEN_STATIC_ASSERT_SAME_MATRIX_SIZE(Derived,OtherDerived)
; 493  :   EIGEN_STATIC_ASSERT(SameType,YOU_MIXED_DIFFERENT_NUMERIC_TYPES__YOU_NEED_TO_USE_THE_CAST_METHOD_OF_MATRIXBASE_TO_CAST_NUMERIC_TYPES_EXPLICITLY)
; 494  : 
; 495  : #ifdef EIGEN_DEBUG_ASSIGN
; 496  :   internal::assign_traits<Derived, OtherDerived>::debug();
; 497  : #endif
; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	mov	rax, QWORD PTR [rdx+8]
	mov	rdi, rdx
	mov	rbx, rcx
	cmp	QWORD PTR [rcx+8], rax
	jne	SHORT $LN3@lazyAssign
	mov	rax, QWORD PTR [rdx+16]
	cmp	QWORD PTR [rcx+16], rax
	je	SHORT $LN4@lazyAssign
$LN3@lazyAssign:
	lea	rdx, OFFSET FLAT:??_C@_1KO@HDGCFKMN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GC@PBCDNLIH@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ@
	mov	r8d, 498				; 000001f2H
	call	QWORD PTR __imp__wassert
$LN4@lazyAssign:

; 499  :   internal::assign_impl<Derived, OtherDerived, int(SameType) ? int(internal::assign_traits<Derived, OtherDerived>::Traversal)
; 500  :                                                        : int(InvalidTraversal)>::run(derived(),other.derived());

	mov	rdx, rdi
	mov	rcx, rbx
	call	?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@Z ; Eigen::internal::assign_impl<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,Eigen::Matrix<double,-1,-1,0,-1,-1>,4,0,0>::run

; 501  : #ifndef EIGEN_NO_DEBUG
; 502  :   checkTransposeAliasing(other.derived());
; 503  : #endif
; 504  :   return derived();

	mov	rax, rbx

; 505  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$lazyAssign@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@?$DenseBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@1@AEBV?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@1@@Z ENDP ; Eigen::DenseBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::lazyAssign<Eigen::Matrix<double,-1,-1,0,-1,-1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
;	COMDAT ??$lazyAssign@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@?$DenseBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@1@AEBV?$DenseBase@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 48
other$ = 56
??$lazyAssign@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@?$DenseBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@1@AEBV?$DenseBase@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@1@@Z PROC ; Eigen::DenseBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::lazyAssign<Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> > >, COMDAT

; 486  : {

$LN97:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 240  :     inline DenseIndex cols(void) const {return m_cols;}

	mov	rcx, QWORD PTR [rdx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 486  : {

	mov	rdi, rdx

; 487  :   enum{
; 488  :     SameType = internal::is_same<typename Derived::Scalar,typename OtherDerived::Scalar>::value
; 489  :   };
; 490  : 
; 491  :   EIGEN_STATIC_ASSERT_LVALUE(Derived)
; 492  :   EIGEN_STATIC_ASSERT_SAME_MATRIX_SIZE(Derived,OtherDerived)
; 493  :   EIGEN_STATIC_ASSERT(SameType,YOU_MIXED_DIFFERENT_NUMERIC_TYPES__YOU_NEED_TO_USE_THE_CAST_METHOD_OF_MATRIXBASE_TO_CAST_NUMERIC_TYPES_EXPLICITLY)
; 494  : 
; 495  : #ifdef EIGEN_DEBUG_ASSIGN
; 496  :   internal::assign_traits<Derived, OtherDerived>::debug();
; 497  : #endif
; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	mov	rax, QWORD PTR [rcx+16]
	cmp	QWORD PTR [rbx+8], rax
	jne	SHORT $LN3@lazyAssign
	mov	rax, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rbx+16], rax
	je	SHORT $LN4@lazyAssign
$LN3@lazyAssign:
	lea	rdx, OFFSET FLAT:??_C@_1KO@HDGCFKMN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GC@PBCDNLIH@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ@
	mov	r8d, 498				; 000001f2H
	call	QWORD PTR __imp__wassert
$LN4@lazyAssign:

; 499  :   internal::assign_impl<Derived, OtherDerived, int(SameType) ? int(internal::assign_traits<Derived, OtherDerived>::Traversal)
; 500  :                                                        : int(InvalidTraversal)>::run(derived(),other.derived());

	mov	rdx, rdi
	mov	rcx, rbx
	call	?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@$0A@$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Z ; Eigen::internal::assign_impl<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> >,0,0,0>::run
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 199  :     inline const Scalar* data() const { return this->m_data; }

	mov	rcx, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h

; 361  :     return (bool(blas_traits<OtherDerived>::IsTransposed) != DestIsTransposed) && (dest!=0 && dest==(const Scalar*)extract_data(src));

	test	rcx, rcx
	je	SHORT $LN94@lazyAssign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 262  :     inline T *data() { return m_data; }

	mov	rax, QWORD PTR [rdi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h

; 361  :     return (bool(blas_traits<OtherDerived>::IsTransposed) != DestIsTransposed) && (dest!=0 && dest==(const Scalar*)extract_data(src));

	cmp	rcx, QWORD PTR [rax]
	jne	SHORT $LN94@lazyAssign

; 362  :   }
; 363  : };
; 364  : 
; 365  : template<typename Scalar, bool DestIsTransposed, typename BinOp, typename DerivedA, typename DerivedB>
; 366  : struct check_transpose_aliasing_run_time_selector<Scalar,DestIsTransposed,CwiseBinaryOp<BinOp,DerivedA,DerivedB> >
; 367  : {
; 368  :   static bool run(const Scalar* dest, const CwiseBinaryOp<BinOp,DerivedA,DerivedB>& src)
; 369  :   {
; 370  :     return ((blas_traits<DerivedA>::IsTransposed != DestIsTransposed) && (dest!=0 && dest==(const Scalar*)extract_data(src.lhs())))
; 371  :         || ((blas_traits<DerivedB>::IsTransposed != DestIsTransposed) && (dest!=0 && dest==(const Scalar*)extract_data(src.rhs())));
; 372  :   }
; 373  : };
; 374  : 
; 375  : // the following selector, checkTransposeAliasing_impl, based on MightHaveTransposeAliasing,
; 376  : // is because when the condition controlling the assert is known at compile time, ICC emits a warning.
; 377  : // This is actually a good warning: in expressions that don't have any transposing, the condition is
; 378  : // known at compile time to be false, and using that, we can avoid generating the code of the assert again
; 379  : // and again for all these expressions that don't need it.
; 380  : 
; 381  : template<typename Derived, typename OtherDerived,
; 382  :          bool MightHaveTransposeAliasing
; 383  :                  = check_transpose_aliasing_compile_time_selector
; 384  :                      <blas_traits<Derived>::IsTransposed,OtherDerived>::ret
; 385  :         >
; 386  : struct checkTransposeAliasing_impl
; 387  : {
; 388  :     static void run(const Derived& dst, const OtherDerived& other)
; 389  :     {
; 390  :         eigen_assert((!check_transpose_aliasing_run_time_selector

	lea	rdx, OFFSET FLAT:??_C@_1LE@ODIDILMJ@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1CCG@OOFKGNBC@?$AA?$CI?$AA?$CB?$AAc?$AAh?$AAe?$AAc?$AAk?$AA_?$AAt?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AA_?$AAa?$AAl?$AAi?$AAa?$AAs?$AAi?$AAn?$AAg?$AA_?$AAr?$AAu?$AAn?$AA_?$AAt@
	mov	r8d, 394				; 0000018aH
	call	QWORD PTR __imp__wassert
$LN94@lazyAssign:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 504  :   return derived();

	mov	rax, rbx

; 505  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$lazyAssign@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@?$DenseBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEAAAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@1@AEBV?$DenseBase@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@1@@Z ENDP ; Eigen::DenseBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::lazyAssign<Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
;	COMDAT ?rows@?$EigenBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?rows@?$EigenBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBA_JXZ PROC ; Eigen::EigenBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::rows, COMDAT

; 44   :   inline Index rows() const { return derived().rows(); }

	mov	rax, QWORD PTR [rcx+8]
	ret	0
?rows@?$EigenBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBA_JXZ ENDP ; Eigen::EigenBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::rows
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
;	COMDAT ?cols@?$EigenBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?cols@?$EigenBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBA_JXZ PROC ; Eigen::EigenBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::cols, COMDAT

; 46   :   inline Index cols() const { return derived().cols(); }

	mov	rax, QWORD PTR [rcx+16]
	ret	0
?cols@?$EigenBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBA_JXZ ENDP ; Eigen::EigenBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::cols
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
;	COMDAT ?rows@?$EigenBase@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?rows@?$EigenBase@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@Eigen@@QEBA_JXZ PROC ; Eigen::EigenBase<Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> > >::rows, COMDAT

; 44   :   inline Index rows() const { return derived().rows(); }

	mov	rax, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+16]
	ret	0
?rows@?$EigenBase@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@Eigen@@QEBA_JXZ ENDP ; Eigen::EigenBase<Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> > >::rows
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
;	COMDAT ?cols@?$EigenBase@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?cols@?$EigenBase@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@Eigen@@QEBA_JXZ PROC ; Eigen::EigenBase<Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> > >::cols, COMDAT

; 46   :   inline Index cols() const { return derived().cols(); }

	mov	rax, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+8]
	ret	0
?cols@?$EigenBase@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@Eigen@@QEBA_JXZ ENDP ; Eigen::EigenBase<Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> > >::cols
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
;	COMDAT ?rows@?$EigenBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?rows@?$EigenBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBA_JXZ PROC ; Eigen::EigenBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::rows, COMDAT

; 44   :   inline Index rows() const { return derived().rows(); }

	mov	rax, QWORD PTR [rcx+8]
	ret	0
?rows@?$EigenBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBA_JXZ ENDP ; Eigen::EigenBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::rows
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
;	COMDAT ?cols@?$EigenBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?cols@?$EigenBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBA_JXZ PROC ; Eigen::EigenBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::cols, COMDAT

; 46   :   inline Index cols() const { return derived().cols(); }

	mov	rax, QWORD PTR [rcx+16]
	ret	0
?cols@?$EigenBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBA_JXZ ENDP ; Eigen::EigenBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::cols
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
;	COMDAT ?derived@?$EigenBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@QEAAAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@2@XZ
_TEXT	SEGMENT
this$ = 8
?derived@?$EigenBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@QEAAAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@2@XZ PROC ; Eigen::EigenBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> > >::derived, COMDAT

; 34   :   Derived& derived() { return *static_cast<Derived*>(this); }

	mov	rax, rcx
	ret	0
?derived@?$EigenBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@QEAAAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@2@XZ ENDP ; Eigen::EigenBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> > >::derived
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
;	COMDAT ?run@?$assign_selector@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@$0A@$0A@@internal@Eigen@@SAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@3@AEAV43@AEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@3@@Z
_TEXT	SEGMENT
dst$ = 48
other$ = 56
?run@?$assign_selector@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@$0A@$0A@@internal@Eigen@@SAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@3@AEAV43@AEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@3@@Z PROC ; Eigen::internal::assign_selector<Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const >,4>,0,0>::run, COMDAT

; 520  :   static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }

$LN233:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rax, QWORD PTR [rdx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 520  :   static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }

	mov	rsi, rdx
	mov	rdi, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rbx, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	mov	rbp, 9223372036854775807		; 7fffffffffffffffH
	test	rbx, rbx
	je	SHORT $LN228@run
	cmp	rbx, rbp
	setg	al

; 45   :     if (error)

	test	al, al
	jne	SHORT $LN230@run

; 47   :   }
; 48   : };
; 49   : 
; 50   : template <typename Derived,
; 51   :           typename OtherDerived = Derived,
; 52   :           bool IsVector = bool(Derived::IsVectorAtCompileTime) && bool(OtherDerived::IsVectorAtCompileTime)>
; 53   : struct conservative_resize_like_impl;
; 54   : 
; 55   : template<typename MatrixTypeA, typename MatrixTypeB, bool SwapPointers> struct matrix_swap_impl;
; 56   : 
; 57   : } // end namespace internal
; 58   : 
; 59   : /** \class PlainObjectBase
; 60   :   * \brief %Dense storage base class for matrices and arrays.
; 61   :   *
; 62   :   * This class can be extended with the help of the plugin mechanism described on the page
; 63   :   * \ref TopicCustomizingEigen by defining the preprocessor symbol \c EIGEN_PLAINOBJECTBASE_PLUGIN.
; 64   :   *
; 65   :   * \sa \ref TopicClassHierarchy
; 66   :   */
; 67   : #ifdef EIGEN_PARSED_BY_DOXYGEN
; 68   : namespace internal {
; 69   : 
; 70   : // this is a warkaround to doxygen not being able to understand the inheritence logic
; 71   : // when it is hidden by the dense_xpr_base helper struct.
; 72   : template<typename Derived> struct dense_xpr_base_dispatcher_for_doxygen;// : public MatrixBase<Derived> {};
; 73   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 74   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 75   : struct dense_xpr_base_dispatcher_for_doxygen<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 76   :     : public MatrixBase<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 77   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 78   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 79   : struct dense_xpr_base_dispatcher_for_doxygen<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 80   :     : public ArrayBase<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 81   : 
; 82   : } // namespace internal
; 83   : 
; 84   : template<typename Derived>
; 85   : class PlainObjectBase : public internal::dense_xpr_base_dispatcher_for_doxygen<Derived>
; 86   : #else
; 87   : template<typename Derived>
; 88   : class PlainObjectBase : public internal::dense_xpr_base<Derived>::type
; 89   : #endif
; 90   : {
; 91   :   public:
; 92   :     enum { Options = internal::traits<Derived>::Options };
; 93   :     typedef typename internal::dense_xpr_base<Derived>::type Base;
; 94   : 
; 95   :     typedef typename internal::traits<Derived>::StorageKind StorageKind;
; 96   :     typedef typename internal::traits<Derived>::Index Index;
; 97   :     typedef typename internal::traits<Derived>::Scalar Scalar;
; 98   :     typedef typename internal::packet_traits<Scalar>::type PacketScalar;
; 99   :     typedef typename NumTraits<Scalar>::Real RealScalar;
; 100  :     typedef Derived DenseType;
; 101  : 
; 102  :     using Base::RowsAtCompileTime;
; 103  :     using Base::ColsAtCompileTime;
; 104  :     using Base::SizeAtCompileTime;
; 105  :     using Base::MaxRowsAtCompileTime;
; 106  :     using Base::MaxColsAtCompileTime;
; 107  :     using Base::MaxSizeAtCompileTime;
; 108  :     using Base::IsVectorAtCompileTime;
; 109  :     using Base::Flags;
; 110  : 
; 111  :     template<typename PlainObjectType, int MapOptions, typename StrideType> friend class Eigen::Map;
; 112  :     friend  class Eigen::Map<Derived, Unaligned>;
; 113  :     typedef Eigen::Map<Derived, Unaligned>  MapType;
; 114  :     friend  class Eigen::Map<const Derived, Unaligned>;
; 115  :     typedef const Eigen::Map<const Derived, Unaligned> ConstMapType;
; 116  :     friend  class Eigen::Map<Derived, Aligned>;
; 117  :     typedef Eigen::Map<Derived, Aligned> AlignedMapType;
; 118  :     friend  class Eigen::Map<const Derived, Aligned>;
; 119  :     typedef const Eigen::Map<const Derived, Aligned> ConstAlignedMapType;
; 120  :     template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };
; 121  :     template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };
; 122  :     template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, Aligned, StrideType> type; };
; 123  :     template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, Aligned, StrideType> type; };
; 124  : 
; 125  :   protected:
; 126  :     DenseStorage<Scalar, Base::MaxSizeAtCompileTime, Base::RowsAtCompileTime, Base::ColsAtCompileTime, Options> m_storage;
; 127  : 
; 128  :   public:
; 129  :     enum { NeedsToAlign = SizeAtCompileTime != Dynamic && (internal::traits<Derived>::Flags & AlignedBit) != 0 };
; 130  :     EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(NeedsToAlign)
; 131  : 
; 132  :     Base& base() { return *static_cast<Base*>(this); }
; 133  :     const Base& base() const { return *static_cast<const Base*>(this); }
; 134  : 
; 135  :     EIGEN_STRONG_INLINE Index rows() const { return m_storage.rows(); }
; 136  :     EIGEN_STRONG_INLINE Index cols() const { return m_storage.cols(); }
; 137  : 
; 138  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index rowId, Index colId) const
; 139  :     {
; 140  :       if(Flags & RowMajorBit)
; 141  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 142  :       else // column-major
; 143  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 144  :     }
; 145  : 
; 146  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index index) const
; 147  :     {
; 148  :       return m_storage.data()[index];
; 149  :     }
; 150  : 
; 151  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index rowId, Index colId)
; 152  :     {
; 153  :       if(Flags & RowMajorBit)
; 154  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 155  :       else // column-major
; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 157  :     }
; 158  : 
; 159  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
; 160  :     {
; 161  :       return m_storage.data()[index];
; 162  :     }
; 163  : 
; 164  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
; 165  :     {
; 166  :       if(Flags & RowMajorBit)
; 167  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 168  :       else // column-major
; 169  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 170  :     }
; 171  : 
; 172  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
; 173  :     {
; 174  :       return m_storage.data()[index];
; 175  :     }
; 176  : 
; 177  :     /** \internal */
; 178  :     template<int LoadMode>
; 179  :     EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const
; 180  :     {
; 181  :       return internal::ploadt<PacketScalar, LoadMode>
; 182  :                (m_storage.data() + (Flags & RowMajorBit
; 183  :                                    ? colId + rowId * m_storage.cols()
; 184  :                                    : rowId + colId * m_storage.rows()));
; 185  :     }
; 186  : 
; 187  :     /** \internal */
; 188  :     template<int LoadMode>
; 189  :     EIGEN_STRONG_INLINE PacketScalar packet(Index index) const
; 190  :     {
; 191  :       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);
; 192  :     }
; 193  : 
; 194  :     /** \internal */
; 195  :     template<int StoreMode>
; 196  :     EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)
; 197  :     {
; 198  :       internal::pstoret<Scalar, PacketScalar, StoreMode>
; 199  :               (m_storage.data() + (Flags & RowMajorBit
; 200  :                                    ? colId + rowId * m_storage.cols()
; 201  :                                    : rowId + colId * m_storage.rows()), val);
; 202  :     }
; 203  : 
; 204  :     /** \internal */
; 205  :     template<int StoreMode>
; 206  :     EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
; 207  :     {
; 208  :       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
; 209  :     }
; 210  : 
; 211  :     /** \returns a const pointer to the data array of this matrix */
; 212  :     EIGEN_STRONG_INLINE const Scalar *data() const
; 213  :     { return m_storage.data(); }
; 214  : 
; 215  :     /** \returns a pointer to the data array of this matrix */
; 216  :     EIGEN_STRONG_INLINE Scalar *data()
; 217  :     { return m_storage.data(); }
; 218  : 
; 219  :     /** Resizes \c *this to a \a rows x \a cols matrix.
; 220  :       *
; 221  :       * This method is intended for dynamic-size matrices, although it is legal to call it on any
; 222  :       * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
; 223  :       * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
; 224  :       *
; 225  :       * If the current number of coefficients of \c *this exactly matches the
; 226  :       * product \a rows * \a cols, then no memory allocation is performed and
; 227  :       * the current values are left unchanged. In all other cases, including
; 228  :       * shrinking, the data is reallocated and all previous values are lost.
; 229  :       *
; 230  :       * Example: \include Matrix_resize_int_int.cpp
; 231  :       * Output: \verbinclude Matrix_resize_int_int.out
; 232  :       *
; 233  :       * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
; 234  :       */
; 235  :     EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)
; 236  :     {
; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rbx, rbx
$LN228@run:
	jns	SHORT $LN134@run
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	mov	r8d, 241				; 000000f1H
	call	QWORD PTR __imp__wassert
$LN134@run:

; 44   :                : (rows > max_index / cols);

	test	rbx, rbx
	je	SHORT $LN141@run
	cmp	rbx, rbp
	setg	al

; 45   :     if (error)

	test	al, al
	jne	SHORT $LN232@run
$LN141@run:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 322  :       if(size != m_rows*_Cols)

	cmp	rbx, QWORD PTR [rdi+8]
	je	SHORT $LN146@run
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR [rdi]
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 325  :         if (size)

	test	rbx, rbx
	je	SHORT $LN147@run

; 326  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

	mov	rcx, rbx
	call	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
	mov	QWORD PTR [rdi], rax

; 327  :         else

	jmp	SHORT $LN146@run
$LN147@run:

; 328  :           m_data = 0;

	mov	QWORD PTR [rdi], 0
$LN146@run:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h

; 284  :   other.derived().evalTo(derived());

	mov	rdx, rdi
	mov	rcx, rsi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 331  :       m_rows = nbRows;

	mov	QWORD PTR [rdi+8], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h

; 284  :   other.derived().evalTo(derived());

	call	??$evalTo@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEBAXAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@@Z ; Eigen::ProductBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const > >::evalTo<Eigen::Matrix<double,-1,1,0,-1,1> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 520  :   static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN230@run:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN232@run:
	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN227@run:
?run@?$assign_selector@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@$0A@$0A@@internal@Eigen@@SAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@3@AEAV43@AEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@3@@Z ENDP ; Eigen::internal::assign_selector<Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const >,4>,0,0>::run
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
;	COMDAT ?run@?$assign_selector@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@$0A@$0A@@internal@Eigen@@SAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@3@AEAV43@AEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@3@@Z
_TEXT	SEGMENT
dst$ = 48
other$ = 56
?run@?$assign_selector@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@$0A@$0A@@internal@Eigen@@SAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@3@AEAV43@AEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@3@@Z PROC ; Eigen::internal::assign_selector<Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,0,0>::run, COMDAT

; 520  :   static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }

$LN233:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rax, QWORD PTR [rdx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 520  :   static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }

	mov	rsi, rdx
	mov	rdi, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rbx, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	mov	rbp, 9223372036854775807		; 7fffffffffffffffH
	test	rbx, rbx
	je	SHORT $LN228@run
	cmp	rbx, rbp
	setg	al

; 45   :     if (error)

	test	al, al
	jne	SHORT $LN230@run

; 47   :   }
; 48   : };
; 49   : 
; 50   : template <typename Derived,
; 51   :           typename OtherDerived = Derived,
; 52   :           bool IsVector = bool(Derived::IsVectorAtCompileTime) && bool(OtherDerived::IsVectorAtCompileTime)>
; 53   : struct conservative_resize_like_impl;
; 54   : 
; 55   : template<typename MatrixTypeA, typename MatrixTypeB, bool SwapPointers> struct matrix_swap_impl;
; 56   : 
; 57   : } // end namespace internal
; 58   : 
; 59   : /** \class PlainObjectBase
; 60   :   * \brief %Dense storage base class for matrices and arrays.
; 61   :   *
; 62   :   * This class can be extended with the help of the plugin mechanism described on the page
; 63   :   * \ref TopicCustomizingEigen by defining the preprocessor symbol \c EIGEN_PLAINOBJECTBASE_PLUGIN.
; 64   :   *
; 65   :   * \sa \ref TopicClassHierarchy
; 66   :   */
; 67   : #ifdef EIGEN_PARSED_BY_DOXYGEN
; 68   : namespace internal {
; 69   : 
; 70   : // this is a warkaround to doxygen not being able to understand the inheritence logic
; 71   : // when it is hidden by the dense_xpr_base helper struct.
; 72   : template<typename Derived> struct dense_xpr_base_dispatcher_for_doxygen;// : public MatrixBase<Derived> {};
; 73   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 74   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 75   : struct dense_xpr_base_dispatcher_for_doxygen<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 76   :     : public MatrixBase<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 77   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 78   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 79   : struct dense_xpr_base_dispatcher_for_doxygen<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 80   :     : public ArrayBase<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 81   : 
; 82   : } // namespace internal
; 83   : 
; 84   : template<typename Derived>
; 85   : class PlainObjectBase : public internal::dense_xpr_base_dispatcher_for_doxygen<Derived>
; 86   : #else
; 87   : template<typename Derived>
; 88   : class PlainObjectBase : public internal::dense_xpr_base<Derived>::type
; 89   : #endif
; 90   : {
; 91   :   public:
; 92   :     enum { Options = internal::traits<Derived>::Options };
; 93   :     typedef typename internal::dense_xpr_base<Derived>::type Base;
; 94   : 
; 95   :     typedef typename internal::traits<Derived>::StorageKind StorageKind;
; 96   :     typedef typename internal::traits<Derived>::Index Index;
; 97   :     typedef typename internal::traits<Derived>::Scalar Scalar;
; 98   :     typedef typename internal::packet_traits<Scalar>::type PacketScalar;
; 99   :     typedef typename NumTraits<Scalar>::Real RealScalar;
; 100  :     typedef Derived DenseType;
; 101  : 
; 102  :     using Base::RowsAtCompileTime;
; 103  :     using Base::ColsAtCompileTime;
; 104  :     using Base::SizeAtCompileTime;
; 105  :     using Base::MaxRowsAtCompileTime;
; 106  :     using Base::MaxColsAtCompileTime;
; 107  :     using Base::MaxSizeAtCompileTime;
; 108  :     using Base::IsVectorAtCompileTime;
; 109  :     using Base::Flags;
; 110  : 
; 111  :     template<typename PlainObjectType, int MapOptions, typename StrideType> friend class Eigen::Map;
; 112  :     friend  class Eigen::Map<Derived, Unaligned>;
; 113  :     typedef Eigen::Map<Derived, Unaligned>  MapType;
; 114  :     friend  class Eigen::Map<const Derived, Unaligned>;
; 115  :     typedef const Eigen::Map<const Derived, Unaligned> ConstMapType;
; 116  :     friend  class Eigen::Map<Derived, Aligned>;
; 117  :     typedef Eigen::Map<Derived, Aligned> AlignedMapType;
; 118  :     friend  class Eigen::Map<const Derived, Aligned>;
; 119  :     typedef const Eigen::Map<const Derived, Aligned> ConstAlignedMapType;
; 120  :     template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };
; 121  :     template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };
; 122  :     template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, Aligned, StrideType> type; };
; 123  :     template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, Aligned, StrideType> type; };
; 124  : 
; 125  :   protected:
; 126  :     DenseStorage<Scalar, Base::MaxSizeAtCompileTime, Base::RowsAtCompileTime, Base::ColsAtCompileTime, Options> m_storage;
; 127  : 
; 128  :   public:
; 129  :     enum { NeedsToAlign = SizeAtCompileTime != Dynamic && (internal::traits<Derived>::Flags & AlignedBit) != 0 };
; 130  :     EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(NeedsToAlign)
; 131  : 
; 132  :     Base& base() { return *static_cast<Base*>(this); }
; 133  :     const Base& base() const { return *static_cast<const Base*>(this); }
; 134  : 
; 135  :     EIGEN_STRONG_INLINE Index rows() const { return m_storage.rows(); }
; 136  :     EIGEN_STRONG_INLINE Index cols() const { return m_storage.cols(); }
; 137  : 
; 138  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index rowId, Index colId) const
; 139  :     {
; 140  :       if(Flags & RowMajorBit)
; 141  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 142  :       else // column-major
; 143  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 144  :     }
; 145  : 
; 146  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index index) const
; 147  :     {
; 148  :       return m_storage.data()[index];
; 149  :     }
; 150  : 
; 151  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index rowId, Index colId)
; 152  :     {
; 153  :       if(Flags & RowMajorBit)
; 154  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 155  :       else // column-major
; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 157  :     }
; 158  : 
; 159  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
; 160  :     {
; 161  :       return m_storage.data()[index];
; 162  :     }
; 163  : 
; 164  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
; 165  :     {
; 166  :       if(Flags & RowMajorBit)
; 167  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 168  :       else // column-major
; 169  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 170  :     }
; 171  : 
; 172  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
; 173  :     {
; 174  :       return m_storage.data()[index];
; 175  :     }
; 176  : 
; 177  :     /** \internal */
; 178  :     template<int LoadMode>
; 179  :     EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const
; 180  :     {
; 181  :       return internal::ploadt<PacketScalar, LoadMode>
; 182  :                (m_storage.data() + (Flags & RowMajorBit
; 183  :                                    ? colId + rowId * m_storage.cols()
; 184  :                                    : rowId + colId * m_storage.rows()));
; 185  :     }
; 186  : 
; 187  :     /** \internal */
; 188  :     template<int LoadMode>
; 189  :     EIGEN_STRONG_INLINE PacketScalar packet(Index index) const
; 190  :     {
; 191  :       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);
; 192  :     }
; 193  : 
; 194  :     /** \internal */
; 195  :     template<int StoreMode>
; 196  :     EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)
; 197  :     {
; 198  :       internal::pstoret<Scalar, PacketScalar, StoreMode>
; 199  :               (m_storage.data() + (Flags & RowMajorBit
; 200  :                                    ? colId + rowId * m_storage.cols()
; 201  :                                    : rowId + colId * m_storage.rows()), val);
; 202  :     }
; 203  : 
; 204  :     /** \internal */
; 205  :     template<int StoreMode>
; 206  :     EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
; 207  :     {
; 208  :       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
; 209  :     }
; 210  : 
; 211  :     /** \returns a const pointer to the data array of this matrix */
; 212  :     EIGEN_STRONG_INLINE const Scalar *data() const
; 213  :     { return m_storage.data(); }
; 214  : 
; 215  :     /** \returns a pointer to the data array of this matrix */
; 216  :     EIGEN_STRONG_INLINE Scalar *data()
; 217  :     { return m_storage.data(); }
; 218  : 
; 219  :     /** Resizes \c *this to a \a rows x \a cols matrix.
; 220  :       *
; 221  :       * This method is intended for dynamic-size matrices, although it is legal to call it on any
; 222  :       * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
; 223  :       * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
; 224  :       *
; 225  :       * If the current number of coefficients of \c *this exactly matches the
; 226  :       * product \a rows * \a cols, then no memory allocation is performed and
; 227  :       * the current values are left unchanged. In all other cases, including
; 228  :       * shrinking, the data is reallocated and all previous values are lost.
; 229  :       *
; 230  :       * Example: \include Matrix_resize_int_int.cpp
; 231  :       * Output: \verbinclude Matrix_resize_int_int.out
; 232  :       *
; 233  :       * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
; 234  :       */
; 235  :     EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)
; 236  :     {
; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rbx, rbx
$LN228@run:
	jns	SHORT $LN134@run
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	mov	r8d, 241				; 000000f1H
	call	QWORD PTR __imp__wassert
$LN134@run:

; 44   :                : (rows > max_index / cols);

	test	rbx, rbx
	je	SHORT $LN141@run
	cmp	rbx, rbp
	setg	al

; 45   :     if (error)

	test	al, al
	jne	SHORT $LN232@run
$LN141@run:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 322  :       if(size != m_rows*_Cols)

	cmp	rbx, QWORD PTR [rdi+8]
	je	SHORT $LN146@run
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR [rdi]
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 325  :         if (size)

	test	rbx, rbx
	je	SHORT $LN147@run

; 326  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

	mov	rcx, rbx
	call	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
	mov	QWORD PTR [rdi], rax

; 327  :         else

	jmp	SHORT $LN146@run
$LN147@run:

; 328  :           m_data = 0;

	mov	QWORD PTR [rdi], 0
$LN146@run:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h

; 284  :   other.derived().evalTo(derived());

	mov	rdx, rdi
	mov	rcx, rsi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 331  :       m_rows = nbRows;

	mov	QWORD PTR [rdi+8], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h

; 284  :   other.derived().evalTo(derived());

	call	??$evalTo@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEBAXAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@@Z ; Eigen::ProductBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >::evalTo<Eigen::Matrix<double,-1,1,0,-1,1> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 520  :   static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN230@run:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN232@run:
	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN227@run:
?run@?$assign_selector@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@$0A@$0A@@internal@Eigen@@SAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@3@AEAV43@AEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@3@@Z ENDP ; Eigen::internal::assign_selector<Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,0,0>::run
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
;	COMDAT ?run@?$assign_selector@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$0A@$0A@@internal@Eigen@@SAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@AEAV43@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z
_TEXT	SEGMENT
dst$ = 64
other$ = 72
?run@?$assign_selector@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$0A@$0A@@internal@Eigen@@SAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@AEAV43@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z PROC ; Eigen::internal::assign_selector<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::Matrix<double,-1,1,0,-1,1>,0,0>::run, COMDAT

; 520  :   static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }

$LN289:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 313  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rsi, QWORD PTR [rdx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 520  :   static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }

	mov	r14, rdx
	mov	rbx, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	mov	rdi, 9223372036854775807		; 7fffffffffffffffH
	test	rsi, rsi
	je	SHORT $LN284@run
	cmp	rsi, rdi
	setg	al

; 45   :     if (error)

	test	al, al
	jne	$LN286@run

; 47   :   }
; 48   : };
; 49   : 
; 50   : template <typename Derived,
; 51   :           typename OtherDerived = Derived,
; 52   :           bool IsVector = bool(Derived::IsVectorAtCompileTime) && bool(OtherDerived::IsVectorAtCompileTime)>
; 53   : struct conservative_resize_like_impl;
; 54   : 
; 55   : template<typename MatrixTypeA, typename MatrixTypeB, bool SwapPointers> struct matrix_swap_impl;
; 56   : 
; 57   : } // end namespace internal
; 58   : 
; 59   : /** \class PlainObjectBase
; 60   :   * \brief %Dense storage base class for matrices and arrays.
; 61   :   *
; 62   :   * This class can be extended with the help of the plugin mechanism described on the page
; 63   :   * \ref TopicCustomizingEigen by defining the preprocessor symbol \c EIGEN_PLAINOBJECTBASE_PLUGIN.
; 64   :   *
; 65   :   * \sa \ref TopicClassHierarchy
; 66   :   */
; 67   : #ifdef EIGEN_PARSED_BY_DOXYGEN
; 68   : namespace internal {
; 69   : 
; 70   : // this is a warkaround to doxygen not being able to understand the inheritence logic
; 71   : // when it is hidden by the dense_xpr_base helper struct.
; 72   : template<typename Derived> struct dense_xpr_base_dispatcher_for_doxygen;// : public MatrixBase<Derived> {};
; 73   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 74   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 75   : struct dense_xpr_base_dispatcher_for_doxygen<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 76   :     : public MatrixBase<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 77   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 78   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 79   : struct dense_xpr_base_dispatcher_for_doxygen<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 80   :     : public ArrayBase<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 81   : 
; 82   : } // namespace internal
; 83   : 
; 84   : template<typename Derived>
; 85   : class PlainObjectBase : public internal::dense_xpr_base_dispatcher_for_doxygen<Derived>
; 86   : #else
; 87   : template<typename Derived>
; 88   : class PlainObjectBase : public internal::dense_xpr_base<Derived>::type
; 89   : #endif
; 90   : {
; 91   :   public:
; 92   :     enum { Options = internal::traits<Derived>::Options };
; 93   :     typedef typename internal::dense_xpr_base<Derived>::type Base;
; 94   : 
; 95   :     typedef typename internal::traits<Derived>::StorageKind StorageKind;
; 96   :     typedef typename internal::traits<Derived>::Index Index;
; 97   :     typedef typename internal::traits<Derived>::Scalar Scalar;
; 98   :     typedef typename internal::packet_traits<Scalar>::type PacketScalar;
; 99   :     typedef typename NumTraits<Scalar>::Real RealScalar;
; 100  :     typedef Derived DenseType;
; 101  : 
; 102  :     using Base::RowsAtCompileTime;
; 103  :     using Base::ColsAtCompileTime;
; 104  :     using Base::SizeAtCompileTime;
; 105  :     using Base::MaxRowsAtCompileTime;
; 106  :     using Base::MaxColsAtCompileTime;
; 107  :     using Base::MaxSizeAtCompileTime;
; 108  :     using Base::IsVectorAtCompileTime;
; 109  :     using Base::Flags;
; 110  : 
; 111  :     template<typename PlainObjectType, int MapOptions, typename StrideType> friend class Eigen::Map;
; 112  :     friend  class Eigen::Map<Derived, Unaligned>;
; 113  :     typedef Eigen::Map<Derived, Unaligned>  MapType;
; 114  :     friend  class Eigen::Map<const Derived, Unaligned>;
; 115  :     typedef const Eigen::Map<const Derived, Unaligned> ConstMapType;
; 116  :     friend  class Eigen::Map<Derived, Aligned>;
; 117  :     typedef Eigen::Map<Derived, Aligned> AlignedMapType;
; 118  :     friend  class Eigen::Map<const Derived, Aligned>;
; 119  :     typedef const Eigen::Map<const Derived, Aligned> ConstAlignedMapType;
; 120  :     template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };
; 121  :     template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };
; 122  :     template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, Aligned, StrideType> type; };
; 123  :     template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, Aligned, StrideType> type; };
; 124  : 
; 125  :   protected:
; 126  :     DenseStorage<Scalar, Base::MaxSizeAtCompileTime, Base::RowsAtCompileTime, Base::ColsAtCompileTime, Options> m_storage;
; 127  : 
; 128  :   public:
; 129  :     enum { NeedsToAlign = SizeAtCompileTime != Dynamic && (internal::traits<Derived>::Flags & AlignedBit) != 0 };
; 130  :     EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(NeedsToAlign)
; 131  : 
; 132  :     Base& base() { return *static_cast<Base*>(this); }
; 133  :     const Base& base() const { return *static_cast<const Base*>(this); }
; 134  : 
; 135  :     EIGEN_STRONG_INLINE Index rows() const { return m_storage.rows(); }
; 136  :     EIGEN_STRONG_INLINE Index cols() const { return m_storage.cols(); }
; 137  : 
; 138  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index rowId, Index colId) const
; 139  :     {
; 140  :       if(Flags & RowMajorBit)
; 141  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 142  :       else // column-major
; 143  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 144  :     }
; 145  : 
; 146  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index index) const
; 147  :     {
; 148  :       return m_storage.data()[index];
; 149  :     }
; 150  : 
; 151  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index rowId, Index colId)
; 152  :     {
; 153  :       if(Flags & RowMajorBit)
; 154  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 155  :       else // column-major
; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 157  :     }
; 158  : 
; 159  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
; 160  :     {
; 161  :       return m_storage.data()[index];
; 162  :     }
; 163  : 
; 164  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
; 165  :     {
; 166  :       if(Flags & RowMajorBit)
; 167  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 168  :       else // column-major
; 169  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 170  :     }
; 171  : 
; 172  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
; 173  :     {
; 174  :       return m_storage.data()[index];
; 175  :     }
; 176  : 
; 177  :     /** \internal */
; 178  :     template<int LoadMode>
; 179  :     EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const
; 180  :     {
; 181  :       return internal::ploadt<PacketScalar, LoadMode>
; 182  :                (m_storage.data() + (Flags & RowMajorBit
; 183  :                                    ? colId + rowId * m_storage.cols()
; 184  :                                    : rowId + colId * m_storage.rows()));
; 185  :     }
; 186  : 
; 187  :     /** \internal */
; 188  :     template<int LoadMode>
; 189  :     EIGEN_STRONG_INLINE PacketScalar packet(Index index) const
; 190  :     {
; 191  :       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);
; 192  :     }
; 193  : 
; 194  :     /** \internal */
; 195  :     template<int StoreMode>
; 196  :     EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)
; 197  :     {
; 198  :       internal::pstoret<Scalar, PacketScalar, StoreMode>
; 199  :               (m_storage.data() + (Flags & RowMajorBit
; 200  :                                    ? colId + rowId * m_storage.cols()
; 201  :                                    : rowId + colId * m_storage.rows()), val);
; 202  :     }
; 203  : 
; 204  :     /** \internal */
; 205  :     template<int StoreMode>
; 206  :     EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
; 207  :     {
; 208  :       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
; 209  :     }
; 210  : 
; 211  :     /** \returns a const pointer to the data array of this matrix */
; 212  :     EIGEN_STRONG_INLINE const Scalar *data() const
; 213  :     { return m_storage.data(); }
; 214  : 
; 215  :     /** \returns a pointer to the data array of this matrix */
; 216  :     EIGEN_STRONG_INLINE Scalar *data()
; 217  :     { return m_storage.data(); }
; 218  : 
; 219  :     /** Resizes \c *this to a \a rows x \a cols matrix.
; 220  :       *
; 221  :       * This method is intended for dynamic-size matrices, although it is legal to call it on any
; 222  :       * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
; 223  :       * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
; 224  :       *
; 225  :       * If the current number of coefficients of \c *this exactly matches the
; 226  :       * product \a rows * \a cols, then no memory allocation is performed and
; 227  :       * the current values are left unchanged. In all other cases, including
; 228  :       * shrinking, the data is reallocated and all previous values are lost.
; 229  :       *
; 230  :       * Example: \include Matrix_resize_int_int.cpp
; 231  :       * Output: \verbinclude Matrix_resize_int_int.out
; 232  :       *
; 233  :       * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
; 234  :       */
; 235  :     EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)
; 236  :     {
; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rsi, rsi
$LN284@run:
	jns	SHORT $LN132@run
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	mov	r8d, 241				; 000000f1H
	call	QWORD PTR __imp__wassert
$LN132@run:

; 44   :                : (rows > max_index / cols);

	test	rsi, rsi
	je	SHORT $LN139@run
	cmp	rsi, rdi
	setg	al

; 45   :     if (error)

	test	al, al
	jne	$LN288@run
$LN139@run:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 249  :       if(size != m_rows*m_cols)

	mov	rax, QWORD PTR [rbx+16]
	xor	edi, edi
	imul	rax, QWORD PTR [rbx+8]
	cmp	rsi, rax
	je	SHORT $LN144@run
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR [rbx]
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 252  :         if (size)

	test	rsi, rsi
	je	SHORT $LN145@run

; 253  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

	mov	rcx, rsi
	call	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
	mov	QWORD PTR [rbx], rax

; 254  :         else

	jmp	SHORT $LN144@run
$LN145@run:

; 255  :           m_data = 0;

	mov	QWORD PTR [rbx], rdi
$LN144@run:

; 256  :         EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN
; 257  :       }
; 258  :       m_rows = nbRows;

	mov	QWORD PTR [rbx+8], rsi

; 259  :       m_cols = nbCols;

	mov	QWORD PTR [rbx+16], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	cmp	rsi, QWORD PTR [r14+8]
	je	SHORT $LN168@run
	lea	rdx, OFFSET FLAT:??_C@_1KO@HDGCFKMN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GC@PBCDNLIH@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ@
	mov	r8d, 498				; 000001f2H
	call	QWORD PTR __imp__wassert
$LN168@run:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 49   :   inline Index size() const { return rows() * cols(); }

	mov	r9, QWORD PTR [rbx+16]
	imul	r9, QWORD PTR [rbx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 404  :     const Index alignedEnd = alignedStart + ((size-alignedStart)/packetSize)*packetSize;

	mov	rax, r9
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r8, rax
	add	r8, r8

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	test	r8, r8
	jle	SHORT $LN205@run
	npad	1
$LL207@run:
	mov	rdx, QWORD PTR [r14]
	mov	rax, QWORD PTR [rbx]
	add	rdi, 2
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 220  : template<> EIGEN_STRONG_INLINE Packet2d pload<Packet2d>(const double*  from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_pd(from); }

	movaps	xmm0, XMMWORD PTR [rdx+rdi*8-16]

; 221  : template<> EIGEN_STRONG_INLINE Packet4i pload<Packet4i>(const int*     from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_si128(reinterpret_cast<const Packet4i*>(from)); }
; 222  : 
; 223  : #if defined(_MSC_VER)
; 224  :   template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float*  from) {
; 225  :     EIGEN_DEBUG_UNALIGNED_LOAD
; 226  :     #if (_MSC_VER==1600)
; 227  :     // NOTE Some version of MSVC10 generates bad code when using _mm_loadu_ps
; 228  :     // (i.e., it does not generate an unaligned load!!
; 229  :     // TODO On most architectures this version should also be faster than a single _mm_loadu_ps
; 230  :     // so we could also enable it for MSVC08 but first we have to make this later does not generate crap when doing so...
; 231  :     __m128 res = _mm_loadl_pi(_mm_set1_ps(0.0f), (const __m64*)(from));
; 232  :     res = _mm_loadh_pi(res, (const __m64*)(from+2));
; 233  :     return res;
; 234  :     #else
; 235  :     return _mm_loadu_ps(from);
; 236  :     #endif
; 237  :   }
; 238  :   template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm_loadu_pd(from); }
; 239  :   template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int*    from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm_loadu_si128(reinterpret_cast<const Packet4i*>(from)); }
; 240  : #else
; 241  : // Fast unaligned loads. Note that here we cannot directly use intrinsics: this would
; 242  : // require pointer casting to incompatible pointer types and leads to invalid code
; 243  : // because of the strict aliasing rule. The "dummy" stuff are required to enforce
; 244  : // a correct instruction dependency.
; 245  : // TODO: do the same for MSVC (ICC is compatible)
; 246  : // NOTE: with the code below, MSVC's compiler crashes!
; 247  : 
; 248  : #if defined(__GNUC__) && defined(__i386__)
; 249  :   // bug 195: gcc/i386 emits weird x87 fldl/fstpl instructions for _mm_load_sd
; 250  :   #define EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS 1
; 251  : #elif defined(__clang__)
; 252  :   // bug 201: Segfaults in __mm_loadh_pd with clang 2.8
; 253  :   #define EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS 1
; 254  : #else
; 255  :   #define EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS 0
; 256  : #endif
; 257  : 
; 258  : template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float* from)
; 259  : {
; 260  :   EIGEN_DEBUG_UNALIGNED_LOAD
; 261  : #if EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS
; 262  :   return _mm_loadu_ps(from);
; 263  : #else
; 264  :   __m128d res;
; 265  :   res =  _mm_load_sd((const double*)(from)) ;
; 266  :   res =  _mm_loadh_pd(res, (const double*)(from+2)) ;
; 267  :   return _mm_castpd_ps(res);
; 268  : #endif
; 269  : }
; 270  : template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from)
; 271  : {
; 272  :   EIGEN_DEBUG_UNALIGNED_LOAD
; 273  : #if EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS
; 274  :   return _mm_loadu_pd(from);
; 275  : #else
; 276  :   __m128d res;
; 277  :   res = _mm_load_sd(from) ;
; 278  :   res = _mm_loadh_pd(res,from+1);
; 279  :   return res;
; 280  : #endif
; 281  : }
; 282  : template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int* from)
; 283  : {
; 284  :   EIGEN_DEBUG_UNALIGNED_LOAD
; 285  : #if EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS
; 286  :   return _mm_loadu_si128(reinterpret_cast<const Packet4i*>(from));
; 287  : #else
; 288  :   __m128d res;
; 289  :   res =  _mm_load_sd((const double*)(from)) ;
; 290  :   res =  _mm_loadh_pd(res, (const double*)(from+2)) ;
; 291  :   return _mm_castpd_si128(res);
; 292  : #endif
; 293  : }
; 294  : #endif
; 295  : 
; 296  : template<> EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float*   from)
; 297  : {
; 298  :   return vec4f_swizzle1(_mm_castpd_ps(_mm_load_sd(reinterpret_cast<const double*>(from))), 0, 0, 1, 1);
; 299  : }
; 300  : template<> EIGEN_STRONG_INLINE Packet2d ploaddup<Packet2d>(const double*  from)
; 301  : { return pset1<Packet2d>(from[0]); }
; 302  : template<> EIGEN_STRONG_INLINE Packet4i ploaddup<Packet4i>(const int*     from)
; 303  : {
; 304  :   Packet4i tmp;
; 305  :   tmp = _mm_loadl_epi64(reinterpret_cast<const Packet4i*>(from));
; 306  :   return vec4i_swizzle1(tmp, 0, 0, 1, 1);
; 307  : }
; 308  : 
; 309  : template<> EIGEN_STRONG_INLINE void pstore<float>(float*   to, const Packet4f& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_ps(to, from); }
; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [rax+rdi*8-16], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	cmp	rdi, r8
	jl	SHORT $LL207@run
$LN205@run:

; 409  :     {
; 410  :       dst.template copyPacket<Derived2, dstAlignment, srcAlignment>(index, src);
; 411  :     }
; 412  : 
; 413  :     unaligned_assign_impl<>::run(src,dst,alignedEnd,size);

	mov	rdx, rbx
	mov	rcx, r14
	call	??$run@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@@?$unaligned_assign_impl@$0A@@internal@Eigen@@SAXAEBV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@_J2@Z ; Eigen::internal::unaligned_assign_impl<0>::run<Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Matrix<double,-1,-1,0,-1,-1> >

; 520  :   static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN286@run:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN288@run:
	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN283@run:
?run@?$assign_selector@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$0A@$0A@@internal@Eigen@@SAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@AEAV43@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z ENDP ; Eigen::internal::assign_selector<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::Matrix<double,-1,1,0,-1,1>,0,0>::run
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
;	COMDAT ?run@?$assign_selector@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@$0A@$0A@@internal@Eigen@@SAAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@3@AEAV43@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Z
_TEXT	SEGMENT
dst$ = 48
other$ = 56
?run@?$assign_selector@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@$0A@$0A@@internal@Eigen@@SAAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@3@AEAV43@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Z PROC ; Eigen::internal::assign_selector<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,0,0>::run, COMDAT

; 520  :   static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }

$LN42:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h

; 136  :       eigen_assert(rows() == rhs.rows() && cols() == rhs.cols());

	mov	r8, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rdx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 520  :   static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }

	mov	rbx, rdx
	mov	rdi, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h

; 136  :       eigen_assert(rows() == rhs.rows() && cols() == rhs.cols());

	cmp	QWORD PTR [r8+8], rax
	jne	SHORT $LN7@run
	cmp	QWORD PTR [rdx+16], 1
	je	SHORT $LN8@run
$LN7@run:
	lea	rdx, OFFSET FLAT:??_C@_1ME@CGCHACLK@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1FK@JAKLMIFJ@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAr?$AAh?$AAs?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN@
	mov	r8d, 136				; 00000088H
	call	QWORD PTR __imp__wassert
$LN8@run:

; 137  :       internal::assign_impl<SelfCwiseBinaryOp, RhsDerived>::run(*this,rhs.derived());

	mov	rdx, rbx
	mov	rcx, rdi
	call	?run@?$assign_impl@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@3@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Z ; Eigen::internal::assign_impl<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,4,0,0>::run
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 520  :   static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?run@?$assign_selector@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@$0A@$0A@@internal@Eigen@@SAAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@3@AEAV43@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Z ENDP ; Eigen::internal::assign_selector<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,0,0>::run
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
;	COMDAT ?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z
_TEXT	SEGMENT
$T1 = 0
size$ = 8
__$ArrayPad$ = 16
dst$ = 48
src$ = 56
?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z PROC ; Eigen::internal::assign_impl<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,Eigen::Matrix<double,-1,1,0,-1,1>,4,0,0>::run, COMDAT

; 441  :   {

$LN746:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 49   :   inline Index size() const { return rows() * cols(); }

	mov	rbx, QWORD PTR [rcx+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 441  :   {

	mov	r10, rcx
	mov	r11, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 49   :   inline Index size() const { return rows() * cols(); }

	imul	rbx, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 454  :                        : internal::first_aligned(&dst.coeffRef(0,0), innerSize);

	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR size$[rsp], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 478  :   else if(size_t(array) & (sizeof(Scalar)-1))

	test	cl, 7
	je	SHORT $LN210@run

; 479  :   {
; 480  :     // There is vectorization for this scalar type, but the array is not aligned to the size of a single scalar.
; 481  :     // Consequently, no element of the array is well aligned.
; 482  :     return size;

	mov	r9, rbx
	jmp	SHORT $LN209@run
$LN210@run:

; 487  :                            & PacketAlignedMask, size);

	shr	rcx, 3
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 4121 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	rax, QWORD PTR size$[rsp]
	lea	rdx, QWORD PTR $T1[rsp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 487  :                            & PacketAlignedMask, size);

	neg	rcx
	and	ecx, 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 4121 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	rbx, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 487  :                            & PacketAlignedMask, size);

	mov	QWORD PTR $T1[rsp], rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 4121 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovge	rax, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 487  :                            & PacketAlignedMask, size);

	mov	r9, QWORD PTR [rax]
$LN209@run:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 458  :       const Index alignedEnd = alignedStart + ((innerSize-alignedStart) & ~packetAlignedMask);

	mov	rdx, rbx

; 460  :       for(Index inner = 0; inner<alignedStart ; ++inner)

	xor	r8d, r8d
	sub	rdx, r9
	and	rdx, -2
	add	rdx, r9
	cmp	r9, 4
	jl	SHORT $LC738@run
	mov	QWORD PTR [rsp+64], rdi
	lea	rdi, QWORD PTR [r9-3]
	npad	10
$LL739@run:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 480  :       derived().coeffRef(row, col) = other.derived().coeff(row, col);

	mov	rax, QWORD PTR [r11]
	mov	rcx, QWORD PTR [r10]
	add	r8, 4
	mov	rax, QWORD PTR [rax+r8*8-32]
	mov	QWORD PTR [rcx+r8*8-32], rax
	mov	rax, QWORD PTR [r11]
	mov	rcx, QWORD PTR [r10]
	mov	rax, QWORD PTR [rax+r8*8-24]
	mov	QWORD PTR [rcx+r8*8-24], rax
	mov	rax, QWORD PTR [r11]
	mov	rcx, QWORD PTR [r10]
	mov	rax, QWORD PTR [rax+r8*8-16]
	mov	QWORD PTR [rcx+r8*8-16], rax
	mov	rax, QWORD PTR [r11]
	mov	rcx, QWORD PTR [r10]
	mov	rax, QWORD PTR [rax+r8*8-8]
	mov	QWORD PTR [rcx+r8*8-8], rax
	cmp	r8, rdi
	jl	SHORT $LL739@run
	mov	rdi, QWORD PTR [rsp+64]
$LC738@run:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 460  :       for(Index inner = 0; inner<alignedStart ; ++inner)

	cmp	r8, r9
	jge	SHORT $LN737@run
$LC9@run:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 480  :       derived().coeffRef(row, col) = other.derived().coeff(row, col);

	mov	rax, QWORD PTR [r11]
	mov	rcx, QWORD PTR [r10]
	inc	r8
	mov	rax, QWORD PTR [rax+r8*8-8]
	mov	QWORD PTR [rcx+r8*8-8], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 460  :       for(Index inner = 0; inner<alignedStart ; ++inner)

	cmp	r8, r9
	jl	SHORT $LC9@run
$LN737@run:

; 464  :       for(Index inner = alignedStart; inner<alignedEnd; inner+=packetSize)

	cmp	r9, rdx
	jge	SHORT $LN4@run
$LL6@run:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 184  :                                    : rowId + colId * m_storage.rows()));

	mov	rax, QWORD PTR [r11]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 217  :                (this->m_data + (col * colStride() + row * rowStride()), val);

	mov	rcx, QWORD PTR [r10]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 464  :       for(Index inner = alignedStart; inner<alignedEnd; inner+=packetSize)

	add	r9, 2
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 238  :   template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm_loadu_pd(from); }

	movups	xmm0, XMMWORD PTR [rax+r9*8-16]

; 239  :   template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int*    from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm_loadu_si128(reinterpret_cast<const Packet4i*>(from)); }
; 240  : #else
; 241  : // Fast unaligned loads. Note that here we cannot directly use intrinsics: this would
; 242  : // require pointer casting to incompatible pointer types and leads to invalid code
; 243  : // because of the strict aliasing rule. The "dummy" stuff are required to enforce
; 244  : // a correct instruction dependency.
; 245  : // TODO: do the same for MSVC (ICC is compatible)
; 246  : // NOTE: with the code below, MSVC's compiler crashes!
; 247  : 
; 248  : #if defined(__GNUC__) && defined(__i386__)
; 249  :   // bug 195: gcc/i386 emits weird x87 fldl/fstpl instructions for _mm_load_sd
; 250  :   #define EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS 1
; 251  : #elif defined(__clang__)
; 252  :   // bug 201: Segfaults in __mm_loadh_pd with clang 2.8
; 253  :   #define EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS 1
; 254  : #else
; 255  :   #define EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS 0
; 256  : #endif
; 257  : 
; 258  : template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float* from)
; 259  : {
; 260  :   EIGEN_DEBUG_UNALIGNED_LOAD
; 261  : #if EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS
; 262  :   return _mm_loadu_ps(from);
; 263  : #else
; 264  :   __m128d res;
; 265  :   res =  _mm_load_sd((const double*)(from)) ;
; 266  :   res =  _mm_loadh_pd(res, (const double*)(from+2)) ;
; 267  :   return _mm_castpd_ps(res);
; 268  : #endif
; 269  : }
; 270  : template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from)
; 271  : {
; 272  :   EIGEN_DEBUG_UNALIGNED_LOAD
; 273  : #if EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS
; 274  :   return _mm_loadu_pd(from);
; 275  : #else
; 276  :   __m128d res;
; 277  :   res = _mm_load_sd(from) ;
; 278  :   res = _mm_loadh_pd(res,from+1);
; 279  :   return res;
; 280  : #endif
; 281  : }
; 282  : template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int* from)
; 283  : {
; 284  :   EIGEN_DEBUG_UNALIGNED_LOAD
; 285  : #if EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS
; 286  :   return _mm_loadu_si128(reinterpret_cast<const Packet4i*>(from));
; 287  : #else
; 288  :   __m128d res;
; 289  :   res =  _mm_load_sd((const double*)(from)) ;
; 290  :   res =  _mm_loadh_pd(res, (const double*)(from+2)) ;
; 291  :   return _mm_castpd_si128(res);
; 292  : #endif
; 293  : }
; 294  : #endif
; 295  : 
; 296  : template<> EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float*   from)
; 297  : {
; 298  :   return vec4f_swizzle1(_mm_castpd_ps(_mm_load_sd(reinterpret_cast<const double*>(from))), 0, 0, 1, 1);
; 299  : }
; 300  : template<> EIGEN_STRONG_INLINE Packet2d ploaddup<Packet2d>(const double*  from)
; 301  : { return pset1<Packet2d>(from[0]); }
; 302  : template<> EIGEN_STRONG_INLINE Packet4i ploaddup<Packet4i>(const int*     from)
; 303  : {
; 304  :   Packet4i tmp;
; 305  :   tmp = _mm_loadl_epi64(reinterpret_cast<const Packet4i*>(from));
; 306  :   return vec4i_swizzle1(tmp, 0, 0, 1, 1);
; 307  : }
; 308  : 
; 309  : template<> EIGEN_STRONG_INLINE void pstore<float>(float*   to, const Packet4f& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_ps(to, from); }
; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [rcx+r9*8-16], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 464  :       for(Index inner = alignedStart; inner<alignedEnd; inner+=packetSize)

	cmp	r9, rdx
	jl	SHORT $LL6@run
$LN4@run:

; 468  :       for(Index inner = alignedEnd; inner<innerSize ; ++inner)

	cmp	rdx, rbx
	jge	SHORT $LN1@run
$LL3@run:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 480  :       derived().coeffRef(row, col) = other.derived().coeff(row, col);

	mov	rax, QWORD PTR [r11]
	mov	rcx, QWORD PTR [r10]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 468  :       for(Index inner = alignedEnd; inner<innerSize ; ++inner)

	inc	rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 480  :       derived().coeffRef(row, col) = other.derived().coeff(row, col);

	mov	rax, QWORD PTR [rax+rdx*8-8]
	mov	QWORD PTR [rcx+rdx*8-8], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 468  :       for(Index inner = alignedEnd; inner<innerSize ; ++inner)

	cmp	rdx, rbx
	jl	SHORT $LL3@run
$LN1@run:

; 469  :         dst.copyCoeffByOuterInner(outer, inner, src);
; 470  : 
; 471  :       alignedStart = std::min<Index>((alignedStart+alignedStep)%packetSize, innerSize);
; 472  :     }
; 473  :   }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z ENDP ; Eigen::internal::assign_impl<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,Eigen::Matrix<double,-1,1,0,-1,1>,4,0,0>::run
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densebase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densebase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densebase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
;	COMDAT ?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@Z
_TEXT	SEGMENT
$T1 = 0
$T2 = 0
size$ = 8
innerSize$ = 16
__$ArrayPad$ = 24
dst$ = 80
src$ = 88
?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@Z PROC ; Eigen::internal::assign_impl<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,Eigen::Matrix<double,-1,-1,0,-1,-1>,4,0,0>::run, COMDAT

; 441  :   {

$LN746:
	push	rbx
	push	rbp
	push	rsi
	push	r12
	push	r15
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densebase.h

; 210  :            : int(IsRowMajor) ? this->cols() : this->rows();

	mov	rbp, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 452  :     const Index alignedStep = alignable ? (packetSize - dst.outerStride() % packetSize) & packetAlignedMask : 0;

	mov	rax, QWORD PTR [rcx+32]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densebase.h

; 199  :            : int(IsRowMajor) ? this->rows() : this->cols();

	mov	r12, QWORD PTR [rcx+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 441  :   {

	mov	rbx, rdx

; 452  :     const Index alignedStep = alignable ? (packetSize - dst.outerStride() % packetSize) & packetAlignedMask : 0;

	cdq
	mov	r11, rcx

; 453  :     Index alignedStart = ((!alignable) || assign_traits<Derived1,Derived2>::DstIsAligned) ? 0
; 454  :                        : internal::first_aligned(&dst.coeffRef(0,0), innerSize);

	mov	rcx, QWORD PTR [rcx]
	and	eax, 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densebase.h

; 210  :            : int(IsRowMajor) ? this->cols() : this->rows();

	mov	QWORD PTR innerSize$[rsp], rbp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 452  :     const Index alignedStep = alignable ? (packetSize - dst.outerStride() % packetSize) & packetAlignedMask : 0;

	xor	rax, rdx

; 453  :     Index alignedStart = ((!alignable) || assign_traits<Derived1,Derived2>::DstIsAligned) ? 0
; 454  :                        : internal::first_aligned(&dst.coeffRef(0,0), innerSize);

	mov	QWORD PTR size$[rsp], rbp
	sub	rax, rdx
	mov	r15, rax
	neg	r15
	and	r15d, 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 478  :   else if(size_t(array) & (sizeof(Scalar)-1))

	test	cl, 7
	je	SHORT $LN210@run

; 479  :   {
; 480  :     // There is vectorization for this scalar type, but the array is not aligned to the size of a single scalar.
; 481  :     // Consequently, no element of the array is well aligned.
; 482  :     return size;

	mov	rsi, rbp
	jmp	SHORT $LN209@run
$LN210@run:

; 487  :                            & PacketAlignedMask, size);

	shr	rcx, 3
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 4121 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	rax, QWORD PTR size$[rsp]
	lea	rdx, QWORD PTR $T1[rsp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 487  :                            & PacketAlignedMask, size);

	neg	rcx
	and	ecx, 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 4121 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	rbp, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 487  :                            & PacketAlignedMask, size);

	mov	QWORD PTR $T1[rsp], rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 4121 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovge	rax, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 487  :                            & PacketAlignedMask, size);

	mov	rsi, QWORD PTR [rax]
$LN209@run:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 456  :     for(Index outer = 0; outer < outerSize; ++outer)

	xor	r10d, r10d
	test	r12, r12
	jle	$LN10@run
	mov	QWORD PTR [rsp+96], rdi
	mov	QWORD PTR [rsp+104], r14
$LL12@run:

; 457  :     {
; 458  :       const Index alignedEnd = alignedStart + ((innerSize-alignedStart) & ~packetAlignedMask);

	mov	r9, rbp

; 460  :       for(Index inner = 0; inner<alignedStart ; ++inner)

	xor	edi, edi
	sub	r9, rsi
	and	r9, -2
	add	r9, rsi
	cmp	rsi, 4
	jl	$LC738@run
	lea	r14, QWORD PTR [rsi-3]
	npad	3
$LL739@run:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 480  :       derived().coeffRef(row, col) = other.derived().coeff(row, col);

	mov	rdx, QWORD PTR [r11+32]
	mov	rax, QWORD PTR [rbx]
	mov	rcx, QWORD PTR [r11]
	imul	rdx, r10
	add	rdx, rdi
	mov	r8, r10
	imul	r8, QWORD PTR [rbx+8]
	add	r8, rdi
	mov	rax, QWORD PTR [rax+r8*8]
	mov	r8, r10
	mov	QWORD PTR [rcx+rdx*8], rax
	mov	rdx, QWORD PTR [r11+32]
	mov	rax, QWORD PTR [rbx]
	imul	r8, QWORD PTR [rbx+8]
	lea	rcx, QWORD PTR [rdi+1]
	imul	rdx, r10
	add	r8, rcx
	add	rdx, rcx
	mov	rcx, QWORD PTR [r11]
	mov	rax, QWORD PTR [rax+r8*8]
	mov	r8, r10
	mov	QWORD PTR [rcx+rdx*8], rax
	mov	rdx, QWORD PTR [r11+32]
	mov	rax, QWORD PTR [rbx]
	imul	r8, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [r11]
	add	r8, rdi
	imul	rdx, r10
	mov	rax, QWORD PTR [rax+r8*8+16]
	add	rdx, rdi
	mov	r8, r10
	mov	QWORD PTR [rcx+rdx*8+16], rax
	mov	rdx, QWORD PTR [r11+32]
	mov	rax, QWORD PTR [rbx]
	imul	r8, QWORD PTR [rbx+8]
	lea	rcx, QWORD PTR [rdi+3]
	add	rdi, 4
	imul	rdx, r10
	add	r8, rcx
	add	rdx, rcx
	mov	rcx, QWORD PTR [r11]
	mov	rax, QWORD PTR [rax+r8*8]
	mov	QWORD PTR [rcx+rdx*8], rax
	cmp	rdi, r14
	jl	$LL739@run
$LC738@run:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 460  :       for(Index inner = 0; inner<alignedStart ; ++inner)

	cmp	rdi, rsi
	jge	SHORT $LN737@run
$LC9@run:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 480  :       derived().coeffRef(row, col) = other.derived().coeff(row, col);

	mov	rdx, QWORD PTR [r11+32]
	mov	rax, QWORD PTR [rbx]
	mov	rcx, QWORD PTR [r11]
	imul	rdx, r10
	add	rdx, rdi
	mov	r8, r10
	imul	r8, QWORD PTR [rbx+8]
	add	r8, rdi
	inc	rdi
	mov	rax, QWORD PTR [rax+r8*8]
	mov	QWORD PTR [rcx+rdx*8], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 460  :       for(Index inner = 0; inner<alignedStart ; ++inner)

	cmp	rdi, rsi
	jl	SHORT $LC9@run
$LN737@run:

; 464  :       for(Index inner = alignedStart; inner<alignedEnd; inner+=packetSize)

	mov	rdi, rsi
	cmp	rsi, r9
	jge	SHORT $LN4@run
$LL6@run:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	mov	r8, QWORD PTR [r11+32]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 184  :                                    : rowId + colId * m_storage.rows()));

	mov	rax, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 217  :                (this->m_data + (col * colStride() + row * rowStride()), val);

	mov	rdx, QWORD PTR [r11]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	imul	r8, r10
	add	r8, rdi
	mov	rcx, r10
	imul	rcx, QWORD PTR [rbx+8]
	add	rcx, rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 464  :       for(Index inner = alignedStart; inner<alignedEnd; inner+=packetSize)

	add	rdi, 2
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 238  :   template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm_loadu_pd(from); }

	movups	xmm0, XMMWORD PTR [rax+rcx*8]

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [rdx+r8*8], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 464  :       for(Index inner = alignedStart; inner<alignedEnd; inner+=packetSize)

	cmp	rdi, r9
	jl	SHORT $LL6@run
$LN4@run:

; 468  :       for(Index inner = alignedEnd; inner<innerSize ; ++inner)

	cmp	r9, rbp
	jge	SHORT $LN1@run
	npad	13
$LL3@run:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 480  :       derived().coeffRef(row, col) = other.derived().coeff(row, col);

	mov	rdx, QWORD PTR [r11+32]
	mov	rax, QWORD PTR [rbx]
	mov	rcx, QWORD PTR [r11]
	imul	rdx, r10
	add	rdx, r9
	mov	r8, r10
	imul	r8, QWORD PTR [rbx+8]
	add	r8, r9
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 468  :       for(Index inner = alignedEnd; inner<innerSize ; ++inner)

	inc	r9
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 480  :       derived().coeffRef(row, col) = other.derived().coeff(row, col);

	mov	rax, QWORD PTR [rax+r8*8]
	mov	QWORD PTR [rcx+rdx*8], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 468  :       for(Index inner = alignedEnd; inner<innerSize ; ++inner)

	cmp	r9, rbp
	jl	SHORT $LL3@run
$LN1@run:

; 471  :       alignedStart = std::min<Index>((alignedStart+alignedStep)%packetSize, innerSize);

	lea	rax, QWORD PTR [rsi+r15]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 4121 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	rcx, QWORD PTR innerSize$[rsp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 471  :       alignedStart = std::min<Index>((alignedStart+alignedStep)%packetSize, innerSize);

	cdq
	and	eax, 1
	xor	rax, rdx
	sub	rax, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 4121 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	rdx, QWORD PTR $T2[rsp]
	cmp	rbp, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 471  :       alignedStart = std::min<Index>((alignedStart+alignedStep)%packetSize, innerSize);

	mov	QWORD PTR $T2[rsp], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 4121 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovge	rcx, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 456  :     for(Index outer = 0; outer < outerSize; ++outer)

	inc	r10

; 471  :       alignedStart = std::min<Index>((alignedStart+alignedStep)%packetSize, innerSize);

	mov	rsi, QWORD PTR [rcx]
	cmp	r10, r12
	jl	$LL12@run
	mov	r14, QWORD PTR [rsp+104]
	mov	rdi, QWORD PTR [rsp+96]
$LN10@run:

; 472  :     }
; 473  :   }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r12
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@Z ENDP ; Eigen::internal::assign_impl<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,Eigen::Matrix<double,-1,-1,0,-1,-1>,4,0,0>::run
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densebase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
;	COMDAT ?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@$0A@$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Z
_TEXT	SEGMENT
dst$ = 24
src$ = 32
?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@$0A@$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Z PROC ; Eigen::internal::assign_impl<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> >,0,0,0>::run, COMDAT

; 260  :   {

$LN254:
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	push	r15
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densebase.h

; 199  :            : int(IsRowMajor) ? this->rows() : this->cols();

	mov	r15, QWORD PTR [rcx+16]

; 200  :     }
; 201  : 
; 202  :     /** \returns the inner size.
; 203  :       *
; 204  :       * \note For a vector, this is just the size. For a matrix (non-vector), this is the minor dimension
; 205  :       * with respect to the \ref TopicStorageOrders "storage order", i.e., the number of rows for a 
; 206  :       * column-major matrix, and the number of columns for a row-major matrix. */
; 207  :     Index innerSize() const
; 208  :     {
; 209  :       return IsVectorAtCompileTime ? this->size()
; 210  :            : int(IsRowMajor) ? this->cols() : this->rows();

	mov	rdi, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 263  :     for(Index outer = 0; outer < outerSize; ++outer)

	xor	r10d, r10d
	mov	r14, rdx
	mov	r11, rcx
	test	r15, r15
	jle	$LN4@run
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	mov	QWORD PTR [rsp+40], rsi
$LL6@run:

; 264  :       for(Index inner = 0; inner < innerSize; ++inner)

	xor	r9d, r9d
	cmp	rdi, 4
	jl	$LC248@run
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h

; 74   :     nestedExpression() const { return m_matrix; }

	mov	rbx, QWORD PTR [r14]
	lea	rbp, QWORD PTR [rdi-3]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 264  :       for(Index inner = 0; inner < innerSize; ++inner)

	lea	esi, QWORD PTR [r9+2]
	npad	6
$LL249@run:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 480  :       derived().coeffRef(row, col) = other.derived().coeff(row, col);

	mov	r8, QWORD PTR [rbx+8]
	mov	rdx, QWORD PTR [r11+32]
	mov	rax, QWORD PTR [rbx]
	imul	r8, r9
	imul	rdx, r10
	mov	rcx, QWORD PTR [r11]
	add	rdx, r9
	add	r8, r10
	mov	rax, QWORD PTR [rax+r8*8]
	add	r9, 4
	mov	QWORD PTR [rcx+rdx*8], rax
	mov	rdx, QWORD PTR [r11+32]
	mov	rax, QWORD PTR [rbx]
	imul	rdx, r10
	lea	rcx, QWORD PTR [rsi-1]
	add	rdx, rcx
	mov	r8, rcx
	mov	rcx, QWORD PTR [r11]
	imul	r8, QWORD PTR [rbx+8]
	add	r8, r10
	mov	rax, QWORD PTR [rax+r8*8]
	mov	r8, rsi
	mov	QWORD PTR [rcx+rdx*8], rax
	mov	rdx, QWORD PTR [r11+32]
	mov	rax, QWORD PTR [rbx]
	imul	r8, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [r11]
	add	r8, r10
	imul	rdx, r10
	mov	rax, QWORD PTR [rax+r8*8]
	add	rdx, rsi
	mov	QWORD PTR [rcx+rdx*8], rax
	mov	rdx, QWORD PTR [r11+32]
	mov	rax, QWORD PTR [rbx]
	lea	rcx, QWORD PTR [rsi+1]
	imul	rdx, r10
	add	rsi, 4
	add	rdx, rcx
	mov	r8, rcx
	mov	rcx, QWORD PTR [r11]
	imul	r8, QWORD PTR [rbx+8]
	add	r8, r10
	mov	rax, QWORD PTR [rax+r8*8]
	mov	QWORD PTR [rcx+rdx*8], rax
	cmp	r9, rbp
	jl	$LL249@run
$LC248@run:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 264  :       for(Index inner = 0; inner < innerSize; ++inner)

	cmp	r9, rdi
	jge	SHORT $LN5@run
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h

; 74   :     nestedExpression() const { return m_matrix; }

	mov	rbx, QWORD PTR [r14]
$LC3@run:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 480  :       derived().coeffRef(row, col) = other.derived().coeff(row, col);

	mov	r8, QWORD PTR [rbx+8]
	mov	rdx, QWORD PTR [r11+32]
	mov	rax, QWORD PTR [rbx]
	imul	r8, r9
	imul	rdx, r10
	mov	rcx, QWORD PTR [r11]
	add	rdx, r9
	add	r8, r10
	mov	rax, QWORD PTR [rax+r8*8]
	inc	r9
	mov	QWORD PTR [rcx+rdx*8], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 264  :       for(Index inner = 0; inner < innerSize; ++inner)

	cmp	r9, rdi
	jl	SHORT $LC3@run
$LN5@run:

; 263  :     for(Index outer = 0; outer < outerSize; ++outer)

	inc	r10
	cmp	r10, r15
	jl	$LL6@run
	mov	rsi, QWORD PTR [rsp+40]
	mov	rbp, QWORD PTR [rsp+32]
	mov	rbx, QWORD PTR [rsp+24]
$LN4@run:

; 265  :         dst.copyCoeffByOuterInner(outer, inner, src);
; 266  :   }

	mov	rdi, QWORD PTR [rsp+48]
	pop	r15
	pop	r14
	ret	0
?run@?$assign_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@$0A@$0A@$0A@@internal@Eigen@@SAXAEAV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Z ENDP ; Eigen::internal::assign_impl<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> >,0,0,0>::run
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h
;	COMDAT ?outerStride@?$BlockImpl_dense@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@$00@internal@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?outerStride@?$BlockImpl_dense@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@$00@internal@Eigen@@QEBA_JXZ PROC ; Eigen::internal::BlockImpl_dense<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0,1>::outerStride, COMDAT

; 371  :       return m_outerStride;

	mov	rax, QWORD PTR [rcx+32]

; 372  :     }

	ret	0
?outerStride@?$BlockImpl_dense@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@$00@internal@Eigen@@QEBA_JXZ ENDP ; Eigen::internal::BlockImpl_dense<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0,1>::outerStride
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
;	COMDAT ?coeffRef@?$MapBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAAEAN_J0@Z
_TEXT	SEGMENT
this$ = 8
row$ = 16
col$ = 24
?coeffRef@?$MapBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAAEAN_J0@Z PROC ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,1>::coeffRef, COMDAT

; 204  :       return this->m_data[col * colStride() + row * rowStride()];

	mov	r9, QWORD PTR [rcx+32]
	mov	rax, QWORD PTR [rcx]
	imul	r9, r8
	add	r9, rdx
	lea	rax, QWORD PTR [rax+r9*8]

; 205  :     }

	ret	0
?coeffRef@?$MapBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAAEAN_J0@Z ENDP ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,1>::coeffRef
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
;	COMDAT ?rows@?$MapBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?rows@?$MapBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEBA_JXZ PROC ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,0>::rows, COMDAT

; 79   :     inline Index rows() const { return m_rows.value(); }

	mov	rax, QWORD PTR [rcx+8]
	ret	0
?rows@?$MapBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEBA_JXZ ENDP ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,0>::rows
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
;	COMDAT ?cols@?$MapBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?cols@?$MapBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEBA_JXZ PROC ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,0>::cols, COMDAT

; 80   :     inline Index cols() const { return m_cols.value(); }

	mov	rax, QWORD PTR [rcx+16]
	ret	0
?cols@?$MapBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEBA_JXZ ENDP ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,0>::cols
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densebase.h
;	COMDAT ?outerSize@?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$dead$ = 8
?outerSize@?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBA_JXZ PROC ; Eigen::DenseBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::outerSize, COMDAT

; 198  :       return IsVectorAtCompileTime ? 1
; 199  :            : int(IsRowMajor) ? this->rows() : this->cols();

	mov	eax, 1

; 200  :     }

	ret	0
?outerSize@?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBA_JXZ ENDP ; Eigen::DenseBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::outerSize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densebase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densebase.h
;	COMDAT ?innerSize@?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?innerSize@?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBA_JXZ PROC ; Eigen::DenseBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::innerSize, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 49   :   inline Index size() const { return rows() * cols(); }

	mov	rax, QWORD PTR [rcx+16]
	imul	rax, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densebase.h

; 211  :     }

	ret	0
?innerSize@?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBA_JXZ ENDP ; Eigen::DenseBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::innerSize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h
;	COMDAT ?outerStride@?$BlockImpl_dense@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@$00@internal@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?outerStride@?$BlockImpl_dense@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@$00@internal@Eigen@@QEBA_JXZ PROC ; Eigen::internal::BlockImpl_dense<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0,1>::outerStride, COMDAT

; 371  :       return m_outerStride;

	mov	rax, QWORD PTR [rcx+32]

; 372  :     }

	ret	0
?outerStride@?$BlockImpl_dense@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@$00@internal@Eigen@@QEBA_JXZ ENDP ; Eigen::internal::BlockImpl_dense<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0,1>::outerStride
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
;	COMDAT ?coeffRef@?$MapBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAAEAN_J0@Z
_TEXT	SEGMENT
this$ = 8
row$ = 16
col$ = 24
?coeffRef@?$MapBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAAEAN_J0@Z PROC ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,1>::coeffRef, COMDAT

; 204  :       return this->m_data[col * colStride() + row * rowStride()];

	mov	r9, QWORD PTR [rcx+32]
	mov	rax, QWORD PTR [rcx]
	imul	r9, r8
	add	r9, rdx
	lea	rax, QWORD PTR [rax+r9*8]

; 205  :     }

	ret	0
?coeffRef@?$MapBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAAEAN_J0@Z ENDP ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,1>::coeffRef
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
;	COMDAT ?rows@?$MapBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?rows@?$MapBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEBA_JXZ PROC ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,0>::rows, COMDAT

; 79   :     inline Index rows() const { return m_rows.value(); }

	mov	rax, QWORD PTR [rcx+8]
	ret	0
?rows@?$MapBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEBA_JXZ ENDP ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,0>::rows
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
;	COMDAT ?cols@?$MapBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?cols@?$MapBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEBA_JXZ PROC ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,0>::cols, COMDAT

; 80   :     inline Index cols() const { return m_cols.value(); }

	mov	rax, QWORD PTR [rcx+16]
	ret	0
?cols@?$MapBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEBA_JXZ ENDP ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,0>::cols
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densebase.h
;	COMDAT ?outerSize@?$DenseBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?outerSize@?$DenseBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBA_JXZ PROC ; Eigen::DenseBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::outerSize, COMDAT

; 198  :       return IsVectorAtCompileTime ? 1
; 199  :            : int(IsRowMajor) ? this->rows() : this->cols();

	mov	rax, QWORD PTR [rcx+16]

; 200  :     }

	ret	0
?outerSize@?$DenseBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBA_JXZ ENDP ; Eigen::DenseBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::outerSize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densebase.h
;	COMDAT ?innerSize@?$DenseBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?innerSize@?$DenseBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBA_JXZ PROC ; Eigen::DenseBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::innerSize, COMDAT

; 209  :       return IsVectorAtCompileTime ? this->size()
; 210  :            : int(IsRowMajor) ? this->cols() : this->rows();

	mov	rax, QWORD PTR [rcx+8]

; 211  :     }

	ret	0
?innerSize@?$DenseBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBA_JXZ ENDP ; Eigen::DenseBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::innerSize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
;	COMDAT ?derived@?$EigenBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBAAEBV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@2@XZ
_TEXT	SEGMENT
this$ = 8
?derived@?$EigenBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBAAEBV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@2@XZ PROC ; Eigen::EigenBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::derived, COMDAT

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	mov	rax, rcx
	ret	0
?derived@?$EigenBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBAAEBV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@2@XZ ENDP ; Eigen::EigenBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::derived
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
;	COMDAT ?rowStride@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$02@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$dead$ = 8
?rowStride@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$02@Eigen@@QEBA_JXZ PROC ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,3>::rowStride, COMDAT

; 682  :       return Derived::IsRowMajor ? outerStride() : innerStride();

	mov	eax, 1

; 683  :     }

	ret	0
?rowStride@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$02@Eigen@@QEBA_JXZ ENDP ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,3>::rowStride
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
;	COMDAT ?colStride@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$02@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?colStride@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$02@Eigen@@QEBA_JXZ PROC ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,3>::colStride, COMDAT

; 691  :       return Derived::IsRowMajor ? innerStride() : outerStride();

	mov	rax, QWORD PTR [rcx+32]

; 692  :     }

	ret	0
?colStride@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$02@Eigen@@QEBA_JXZ ENDP ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,3>::colStride
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
;	COMDAT ?size@?$EigenBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?size@?$EigenBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBA_JXZ PROC ; Eigen::EigenBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::size, COMDAT

; 49   :   inline Index size() const { return rows() * cols(); }

	mov	rax, QWORD PTR [rcx+16]
	imul	rax, QWORD PTR [rcx+8]
	ret	0
?size@?$EigenBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBA_JXZ ENDP ; Eigen::EigenBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
;	COMDAT ?rowStride@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$02@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$dead$ = 8
?rowStride@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$02@Eigen@@QEBA_JXZ PROC ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,3>::rowStride, COMDAT

; 682  :       return Derived::IsRowMajor ? outerStride() : innerStride();

	mov	eax, 1

; 683  :     }

	ret	0
?rowStride@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$02@Eigen@@QEBA_JXZ ENDP ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,3>::rowStride
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
;	COMDAT ?colStride@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$02@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?colStride@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$02@Eigen@@QEBA_JXZ PROC ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,3>::colStride, COMDAT

; 691  :       return Derived::IsRowMajor ? innerStride() : outerStride();

	mov	rax, QWORD PTR [rcx+32]

; 692  :     }

	ret	0
?colStride@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$02@Eigen@@QEBA_JXZ ENDP ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,3>::colStride
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
;	COMDAT ?size@?$EigenBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?size@?$EigenBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBA_JXZ PROC ; Eigen::EigenBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::size, COMDAT

; 49   :   inline Index size() const { return rows() * cols(); }

	mov	rax, QWORD PTR [rcx+16]
	imul	rax, QWORD PTR [rcx+8]
	ret	0
?size@?$EigenBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBA_JXZ ENDP ; Eigen::EigenBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
;	COMDAT ?innerStride@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$02@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$dead$ = 8
?innerStride@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$02@Eigen@@QEBA_JXZ PROC ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,3>::innerStride, COMDAT

; 657  :       return derived().innerStride();

	mov	eax, 1

; 658  :     }

	ret	0
?innerStride@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$02@Eigen@@QEBA_JXZ ENDP ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,3>::innerStride
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
;	COMDAT ?outerStride@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$02@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?outerStride@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$02@Eigen@@QEBA_JXZ PROC ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,3>::outerStride, COMDAT

; 667  :       return derived().outerStride();

	mov	rax, QWORD PTR [rcx+32]

; 668  :     }

	ret	0
?outerStride@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$02@Eigen@@QEBA_JXZ ENDP ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,3>::outerStride
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
;	COMDAT ?innerStride@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$02@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$dead$ = 8
?innerStride@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$02@Eigen@@QEBA_JXZ PROC ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,3>::innerStride, COMDAT

; 657  :       return derived().innerStride();

	mov	eax, 1

; 658  :     }

	ret	0
?innerStride@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$02@Eigen@@QEBA_JXZ ENDP ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,3>::innerStride
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
;	COMDAT ?outerStride@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$02@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?outerStride@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$02@Eigen@@QEBA_JXZ PROC ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,3>::outerStride, COMDAT

; 667  :       return derived().outerStride();

	mov	rax, QWORD PTR [rcx+32]

; 668  :     }

	ret	0
?outerStride@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$02@Eigen@@QEBA_JXZ ENDP ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,3>::outerStride
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h
;	COMDAT ?innerStride@?$BlockImpl_dense@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@$00@internal@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$dead$ = 8
?innerStride@?$BlockImpl_dense@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@$00@internal@Eigen@@QEBA_JXZ PROC ; Eigen::internal::BlockImpl_dense<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0,1>::innerStride, COMDAT

; 363  :       return internal::traits<BlockType>::HasSameStorageOrderAsXprType
; 364  :              ? m_xpr.innerStride()
; 365  :              : m_xpr.outerStride();

	mov	eax, 1

; 366  :     }

	ret	0
?innerStride@?$BlockImpl_dense@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@$00@internal@Eigen@@QEBA_JXZ ENDP ; Eigen::internal::BlockImpl_dense<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0,1>::innerStride
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\block.h
;	COMDAT ?innerStride@?$BlockImpl_dense@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@$00@internal@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$dead$ = 8
?innerStride@?$BlockImpl_dense@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@$00@internal@Eigen@@QEBA_JXZ PROC ; Eigen::internal::BlockImpl_dense<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0,1>::innerStride, COMDAT

; 363  :       return internal::traits<BlockType>::HasSameStorageOrderAsXprType
; 364  :              ? m_xpr.innerStride()
; 365  :              : m_xpr.outerStride();

	mov	eax, 1

; 366  :     }

	ret	0
?innerStride@?$BlockImpl_dense@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@$00@internal@Eigen@@QEBA_JXZ ENDP ; Eigen::internal::BlockImpl_dense<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0,1>::innerStride
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
;	COMDAT ??$_set_selector@V?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@IEAAXAEBV?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@1@AEBUfalse_type@internal@1@@Z
_TEXT	SEGMENT
this$ = 64
other$ = 72
__formal$dead$ = 80
??$_set_selector@V?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@IEAAXAEBV?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@1@AEBUfalse_type@internal@1@@Z PROC ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,1,0,-1,1> >::_set_selector<Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>,Eigen::ReturnByValue<Eigen::internal::solve_retval_base<Eigen::PartialPivLU<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::Matrix<double,-1,1,0,-1,1> > > const > >, COMDAT

; 606  :     EIGEN_STRONG_INLINE void _set_selector(const OtherDerived& other, const internal::false_type&) { _set_noalias(other); }

$LN370:
	push	rbx
	push	rbp
	push	rsi
	sub	rsp, 32					; 00000020H
	mov	rsi, rcx
	test	rdx, rdx
	je	SHORT $LN9@set_select
	lea	rax, QWORD PTR [rdx+1]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	test	rax, rax
	je	SHORT $LN9@set_select
	dec	rax
	jmp	SHORT $LN10@set_select
$LN9@set_select:
	xor	eax, eax
$LN10@set_select:
	mov	QWORD PTR [rsp+80], rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 520  :   static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }

	inc	rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	je	SHORT $LN15@set_select
	lea	rdi, QWORD PTR [rax-1]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 520  :   static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }

	test	rdi, rdi
	je	SHORT $LN15@set_select
	inc	rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	je	SHORT $LN37@set_select
	lea	rbx, QWORD PTR [rdi-1]
	jmp	SHORT $LN38@set_select
$LN15@set_select:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 520  :   static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }

	xor	edi, edi
$LN37@set_select:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	xor	ebx, ebx
$LN38@set_select:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 313  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rbx, QWORD PTR [rbx+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	mov	rbp, 9223372036854775807		; 7fffffffffffffffH
	test	rbx, rbx
	je	SHORT $LN365@set_select
	cmp	rbx, rbp
	setg	al

; 45   :     if (error)

	test	al, al
	jne	$LN367@set_select

; 47   :   }
; 48   : };
; 49   : 
; 50   : template <typename Derived,
; 51   :           typename OtherDerived = Derived,
; 52   :           bool IsVector = bool(Derived::IsVectorAtCompileTime) && bool(OtherDerived::IsVectorAtCompileTime)>
; 53   : struct conservative_resize_like_impl;
; 54   : 
; 55   : template<typename MatrixTypeA, typename MatrixTypeB, bool SwapPointers> struct matrix_swap_impl;
; 56   : 
; 57   : } // end namespace internal
; 58   : 
; 59   : /** \class PlainObjectBase
; 60   :   * \brief %Dense storage base class for matrices and arrays.
; 61   :   *
; 62   :   * This class can be extended with the help of the plugin mechanism described on the page
; 63   :   * \ref TopicCustomizingEigen by defining the preprocessor symbol \c EIGEN_PLAINOBJECTBASE_PLUGIN.
; 64   :   *
; 65   :   * \sa \ref TopicClassHierarchy
; 66   :   */
; 67   : #ifdef EIGEN_PARSED_BY_DOXYGEN
; 68   : namespace internal {
; 69   : 
; 70   : // this is a warkaround to doxygen not being able to understand the inheritence logic
; 71   : // when it is hidden by the dense_xpr_base helper struct.
; 72   : template<typename Derived> struct dense_xpr_base_dispatcher_for_doxygen;// : public MatrixBase<Derived> {};
; 73   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 74   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 75   : struct dense_xpr_base_dispatcher_for_doxygen<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 76   :     : public MatrixBase<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 77   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 78   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 79   : struct dense_xpr_base_dispatcher_for_doxygen<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 80   :     : public ArrayBase<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 81   : 
; 82   : } // namespace internal
; 83   : 
; 84   : template<typename Derived>
; 85   : class PlainObjectBase : public internal::dense_xpr_base_dispatcher_for_doxygen<Derived>
; 86   : #else
; 87   : template<typename Derived>
; 88   : class PlainObjectBase : public internal::dense_xpr_base<Derived>::type
; 89   : #endif
; 90   : {
; 91   :   public:
; 92   :     enum { Options = internal::traits<Derived>::Options };
; 93   :     typedef typename internal::dense_xpr_base<Derived>::type Base;
; 94   : 
; 95   :     typedef typename internal::traits<Derived>::StorageKind StorageKind;
; 96   :     typedef typename internal::traits<Derived>::Index Index;
; 97   :     typedef typename internal::traits<Derived>::Scalar Scalar;
; 98   :     typedef typename internal::packet_traits<Scalar>::type PacketScalar;
; 99   :     typedef typename NumTraits<Scalar>::Real RealScalar;
; 100  :     typedef Derived DenseType;
; 101  : 
; 102  :     using Base::RowsAtCompileTime;
; 103  :     using Base::ColsAtCompileTime;
; 104  :     using Base::SizeAtCompileTime;
; 105  :     using Base::MaxRowsAtCompileTime;
; 106  :     using Base::MaxColsAtCompileTime;
; 107  :     using Base::MaxSizeAtCompileTime;
; 108  :     using Base::IsVectorAtCompileTime;
; 109  :     using Base::Flags;
; 110  : 
; 111  :     template<typename PlainObjectType, int MapOptions, typename StrideType> friend class Eigen::Map;
; 112  :     friend  class Eigen::Map<Derived, Unaligned>;
; 113  :     typedef Eigen::Map<Derived, Unaligned>  MapType;
; 114  :     friend  class Eigen::Map<const Derived, Unaligned>;
; 115  :     typedef const Eigen::Map<const Derived, Unaligned> ConstMapType;
; 116  :     friend  class Eigen::Map<Derived, Aligned>;
; 117  :     typedef Eigen::Map<Derived, Aligned> AlignedMapType;
; 118  :     friend  class Eigen::Map<const Derived, Aligned>;
; 119  :     typedef const Eigen::Map<const Derived, Aligned> ConstAlignedMapType;
; 120  :     template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };
; 121  :     template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };
; 122  :     template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, Aligned, StrideType> type; };
; 123  :     template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, Aligned, StrideType> type; };
; 124  : 
; 125  :   protected:
; 126  :     DenseStorage<Scalar, Base::MaxSizeAtCompileTime, Base::RowsAtCompileTime, Base::ColsAtCompileTime, Options> m_storage;
; 127  : 
; 128  :   public:
; 129  :     enum { NeedsToAlign = SizeAtCompileTime != Dynamic && (internal::traits<Derived>::Flags & AlignedBit) != 0 };
; 130  :     EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(NeedsToAlign)
; 131  : 
; 132  :     Base& base() { return *static_cast<Base*>(this); }
; 133  :     const Base& base() const { return *static_cast<const Base*>(this); }
; 134  : 
; 135  :     EIGEN_STRONG_INLINE Index rows() const { return m_storage.rows(); }
; 136  :     EIGEN_STRONG_INLINE Index cols() const { return m_storage.cols(); }
; 137  : 
; 138  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index rowId, Index colId) const
; 139  :     {
; 140  :       if(Flags & RowMajorBit)
; 141  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 142  :       else // column-major
; 143  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 144  :     }
; 145  : 
; 146  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index index) const
; 147  :     {
; 148  :       return m_storage.data()[index];
; 149  :     }
; 150  : 
; 151  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index rowId, Index colId)
; 152  :     {
; 153  :       if(Flags & RowMajorBit)
; 154  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 155  :       else // column-major
; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 157  :     }
; 158  : 
; 159  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
; 160  :     {
; 161  :       return m_storage.data()[index];
; 162  :     }
; 163  : 
; 164  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
; 165  :     {
; 166  :       if(Flags & RowMajorBit)
; 167  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 168  :       else // column-major
; 169  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 170  :     }
; 171  : 
; 172  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
; 173  :     {
; 174  :       return m_storage.data()[index];
; 175  :     }
; 176  : 
; 177  :     /** \internal */
; 178  :     template<int LoadMode>
; 179  :     EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const
; 180  :     {
; 181  :       return internal::ploadt<PacketScalar, LoadMode>
; 182  :                (m_storage.data() + (Flags & RowMajorBit
; 183  :                                    ? colId + rowId * m_storage.cols()
; 184  :                                    : rowId + colId * m_storage.rows()));
; 185  :     }
; 186  : 
; 187  :     /** \internal */
; 188  :     template<int LoadMode>
; 189  :     EIGEN_STRONG_INLINE PacketScalar packet(Index index) const
; 190  :     {
; 191  :       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);
; 192  :     }
; 193  : 
; 194  :     /** \internal */
; 195  :     template<int StoreMode>
; 196  :     EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)
; 197  :     {
; 198  :       internal::pstoret<Scalar, PacketScalar, StoreMode>
; 199  :               (m_storage.data() + (Flags & RowMajorBit
; 200  :                                    ? colId + rowId * m_storage.cols()
; 201  :                                    : rowId + colId * m_storage.rows()), val);
; 202  :     }
; 203  : 
; 204  :     /** \internal */
; 205  :     template<int StoreMode>
; 206  :     EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
; 207  :     {
; 208  :       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
; 209  :     }
; 210  : 
; 211  :     /** \returns a const pointer to the data array of this matrix */
; 212  :     EIGEN_STRONG_INLINE const Scalar *data() const
; 213  :     { return m_storage.data(); }
; 214  : 
; 215  :     /** \returns a pointer to the data array of this matrix */
; 216  :     EIGEN_STRONG_INLINE Scalar *data()
; 217  :     { return m_storage.data(); }
; 218  : 
; 219  :     /** Resizes \c *this to a \a rows x \a cols matrix.
; 220  :       *
; 221  :       * This method is intended for dynamic-size matrices, although it is legal to call it on any
; 222  :       * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
; 223  :       * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
; 224  :       *
; 225  :       * If the current number of coefficients of \c *this exactly matches the
; 226  :       * product \a rows * \a cols, then no memory allocation is performed and
; 227  :       * the current values are left unchanged. In all other cases, including
; 228  :       * shrinking, the data is reallocated and all previous values are lost.
; 229  :       *
; 230  :       * Example: \include Matrix_resize_int_int.cpp
; 231  :       * Output: \verbinclude Matrix_resize_int_int.out
; 232  :       *
; 233  :       * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
; 234  :       */
; 235  :     EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)
; 236  :     {
; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rbx, rbx
$LN365@set_select:
	jns	SHORT $LN130@set_select
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	mov	r8d, 241				; 000000f1H
	call	QWORD PTR __imp__wassert
$LN130@set_select:

; 44   :                : (rows > max_index / cols);

	test	rbx, rbx
	je	SHORT $LN137@set_select
	cmp	rbx, rbp
	setg	al

; 45   :     if (error)

	test	al, al
	jne	$LN369@set_select
$LN137@set_select:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 322  :       if(size != m_rows*_Cols)

	cmp	rbx, QWORD PTR [rsi+8]
	je	SHORT $LN142@set_select
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR [rsi]
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 325  :         if (size)

	test	rbx, rbx
	je	SHORT $LN143@set_select

; 326  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

	mov	rcx, rbx
	call	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
	mov	QWORD PTR [rsi], rax

; 327  :         else

	jmp	SHORT $LN142@set_select
$LN143@set_select:

; 328  :           m_data = 0;

	mov	QWORD PTR [rsi], 0
$LN142@set_select:

; 329  :         EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN
; 330  :       }
; 331  :       m_rows = nbRows;

	mov	QWORD PTR [rsi+8], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	test	rdi, rdi
	je	SHORT $LN23@set_select
	dec	rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 414  :       return Base::lazyAssign(other.derived());

	je	SHORT $LN23@set_select
	inc	rdi
	jmp	SHORT $LN24@set_select
$LN23@set_select:
	xor	edi, edi
$LN24@set_select:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	test	rdi, rdi
	je	SHORT $LN226@set_select
	lea	rax, QWORD PTR [rdi-1]
	jmp	SHORT $LN227@set_select
$LN226@set_select:
	xor	eax, eax
$LN227@set_select:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	cmp	rbx, QWORD PTR [rax+16]
	je	SHORT $LN213@set_select
	lea	rdx, OFFSET FLAT:??_C@_1KO@HDGCFKMN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GC@PBCDNLIH@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ@
	mov	r8d, 498				; 000001f2H
	call	QWORD PTR __imp__wassert
$LN213@set_select:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	test	rdi, rdi
	je	SHORT $LN256@set_select
	lea	rcx, QWORD PTR [rdi-1]
	jmp	SHORT $LN257@set_select
$LN256@set_select:
	xor	ecx, ecx
$LN257@set_select:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 395  :     const Index size = dst.size();

	mov	r9, QWORD PTR [rsi+8]

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	xor	r8d, r8d
	mov	rax, r9
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r11, rax
	add	r11, r11
	test	r11, r11
	jle	SHORT $LN260@set_select
	movdqa	xmm1, XMMWORD PTR __xmm@80000000000000008000000000000000
$LL262@set_select:

; 409  :     {
; 410  :       dst.template copyPacket<Derived2, dstAlignment, srcAlignment>(index, src);

	test	rcx, rcx
	je	SHORT $LN305@set_select
	lea	rax, QWORD PTR [rcx+1]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	test	rax, rax
	je	SHORT $LN305@set_select
	dec	rax
	jmp	SHORT $LN306@set_select
$LN305@set_select:
	xor	eax, eax
$LN306@set_select:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 538  :         other.derived().template packet<LoadMode>(index));

	inc	rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	je	SHORT $LN311@set_select
	lea	rdx, QWORD PTR [rax-1]
	jmp	SHORT $LN312@set_select
$LN311@set_select:
	xor	edx, edx
$LN312@set_select:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	mov	rax, QWORD PTR [rsi]
	lea	r10, QWORD PTR [rax+r8*8]
	mov	rax, QWORD PTR [rdx+8]
	add	r8, 2
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 220  : template<> EIGEN_STRONG_INLINE Packet2d pload<Packet2d>(const double*  from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_pd(from); }

	movaps	xmm0, XMMWORD PTR [rax+r8*8-16]

; 138  :   return _mm_xor_pd(a,mask);

	xorps	xmm0, xmm1

; 221  : template<> EIGEN_STRONG_INLINE Packet4i pload<Packet4i>(const int*     from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_si128(reinterpret_cast<const Packet4i*>(from)); }
; 222  : 
; 223  : #if defined(_MSC_VER)
; 224  :   template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float*  from) {
; 225  :     EIGEN_DEBUG_UNALIGNED_LOAD
; 226  :     #if (_MSC_VER==1600)
; 227  :     // NOTE Some version of MSVC10 generates bad code when using _mm_loadu_ps
; 228  :     // (i.e., it does not generate an unaligned load!!
; 229  :     // TODO On most architectures this version should also be faster than a single _mm_loadu_ps
; 230  :     // so we could also enable it for MSVC08 but first we have to make this later does not generate crap when doing so...
; 231  :     __m128 res = _mm_loadl_pi(_mm_set1_ps(0.0f), (const __m64*)(from));
; 232  :     res = _mm_loadh_pi(res, (const __m64*)(from+2));
; 233  :     return res;
; 234  :     #else
; 235  :     return _mm_loadu_ps(from);
; 236  :     #endif
; 237  :   }
; 238  :   template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm_loadu_pd(from); }
; 239  :   template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int*    from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm_loadu_si128(reinterpret_cast<const Packet4i*>(from)); }
; 240  : #else
; 241  : // Fast unaligned loads. Note that here we cannot directly use intrinsics: this would
; 242  : // require pointer casting to incompatible pointer types and leads to invalid code
; 243  : // because of the strict aliasing rule. The "dummy" stuff are required to enforce
; 244  : // a correct instruction dependency.
; 245  : // TODO: do the same for MSVC (ICC is compatible)
; 246  : // NOTE: with the code below, MSVC's compiler crashes!
; 247  : 
; 248  : #if defined(__GNUC__) && defined(__i386__)
; 249  :   // bug 195: gcc/i386 emits weird x87 fldl/fstpl instructions for _mm_load_sd
; 250  :   #define EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS 1
; 251  : #elif defined(__clang__)
; 252  :   // bug 201: Segfaults in __mm_loadh_pd with clang 2.8
; 253  :   #define EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS 1
; 254  : #else
; 255  :   #define EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS 0
; 256  : #endif
; 257  : 
; 258  : template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float* from)
; 259  : {
; 260  :   EIGEN_DEBUG_UNALIGNED_LOAD
; 261  : #if EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS
; 262  :   return _mm_loadu_ps(from);
; 263  : #else
; 264  :   __m128d res;
; 265  :   res =  _mm_load_sd((const double*)(from)) ;
; 266  :   res =  _mm_loadh_pd(res, (const double*)(from+2)) ;
; 267  :   return _mm_castpd_ps(res);
; 268  : #endif
; 269  : }
; 270  : template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from)
; 271  : {
; 272  :   EIGEN_DEBUG_UNALIGNED_LOAD
; 273  : #if EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS
; 274  :   return _mm_loadu_pd(from);
; 275  : #else
; 276  :   __m128d res;
; 277  :   res = _mm_load_sd(from) ;
; 278  :   res = _mm_loadh_pd(res,from+1);
; 279  :   return res;
; 280  : #endif
; 281  : }
; 282  : template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int* from)
; 283  : {
; 284  :   EIGEN_DEBUG_UNALIGNED_LOAD
; 285  : #if EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS
; 286  :   return _mm_loadu_si128(reinterpret_cast<const Packet4i*>(from));
; 287  : #else
; 288  :   __m128d res;
; 289  :   res =  _mm_load_sd((const double*)(from)) ;
; 290  :   res =  _mm_loadh_pd(res, (const double*)(from+2)) ;
; 291  :   return _mm_castpd_si128(res);
; 292  : #endif
; 293  : }
; 294  : #endif
; 295  : 
; 296  : template<> EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float*   from)
; 297  : {
; 298  :   return vec4f_swizzle1(_mm_castpd_ps(_mm_load_sd(reinterpret_cast<const double*>(from))), 0, 0, 1, 1);
; 299  : }
; 300  : template<> EIGEN_STRONG_INLINE Packet2d ploaddup<Packet2d>(const double*  from)
; 301  : { return pset1<Packet2d>(from[0]); }
; 302  : template<> EIGEN_STRONG_INLINE Packet4i ploaddup<Packet4i>(const int*     from)
; 303  : {
; 304  :   Packet4i tmp;
; 305  :   tmp = _mm_loadl_epi64(reinterpret_cast<const Packet4i*>(from));
; 306  :   return vec4i_swizzle1(tmp, 0, 0, 1, 1);
; 307  : }
; 308  : 
; 309  : template<> EIGEN_STRONG_INLINE void pstore<float>(float*   to, const Packet4f& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_ps(to, from); }
; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [r10], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	cmp	r8, r11
	jl	SHORT $LL262@set_select
$LN260@set_select:

; 413  :     unaligned_assign_impl<>::run(src,dst,alignedEnd,size);

	mov	r8, r11
	mov	rdx, rsi
	mov	rdi, QWORD PTR [rsp+80]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 606  :     EIGEN_STRONG_INLINE void _set_selector(const OtherDerived& other, const internal::false_type&) { _set_noalias(other); }

	add	rsp, 32					; 00000020H
	pop	rsi
	pop	rbp
	pop	rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 413  :     unaligned_assign_impl<>::run(src,dst,alignedEnd,size);

	jmp	??$run@V?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@?$unaligned_assign_impl@$0A@@internal@Eigen@@SAXAEBV?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@2@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@_J2@Z ; Eigen::internal::unaligned_assign_impl<0>::run<Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>,Eigen::ReturnByValue<Eigen::internal::solve_retval_base<Eigen::PartialPivLU<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::Matrix<double,-1,1,0,-1,1> > > const >,Eigen::Matrix<double,-1,1,0,-1,1> >
$LN367@set_select:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN369@set_select:
	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN364@set_select:
??$_set_selector@V?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@IEAAXAEBV?$CwiseUnaryOp@U?$scalar_opposite_op@N@internal@Eigen@@$$CBV?$ReturnByValue@U?$solve_retval_base@V?$PartialPivLU@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@internal@Eigen@@@3@@1@AEBUfalse_type@internal@1@@Z ENDP ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,1,0,-1,1> >::_set_selector<Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>,Eigen::ReturnByValue<Eigen::internal::solve_retval_base<Eigen::PartialPivLU<Eigen::Matrix<double,-1,-1,0,-1,-1> >,Eigen::Matrix<double,-1,1,0,-1,1> > > const > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h
;	COMDAT ??$checkTransposeAliasing@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@IEBAXAEBV?$Matrix@N$0?0$00$0A@$0?0$00@1@@Z
_TEXT	SEGMENT
this$dead$ = 8
other$dead$ = 16
??$checkTransposeAliasing@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@IEBAXAEBV?$Matrix@N$0?0$00$0A@$0?0$00@1@@Z PROC ; Eigen::DenseBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::checkTransposeAliasing<Eigen::Matrix<double,-1,1,0,-1,1> >, COMDAT

; 413  :     internal::checkTransposeAliasing_impl<Derived, OtherDerived>::run(derived(), other);
; 414  : }

	ret	0
??$checkTransposeAliasing@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@IEBAXAEBV?$Matrix@N$0?0$00$0A@$0?0$00@1@@Z ENDP ; Eigen::DenseBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::checkTransposeAliasing<Eigen::Matrix<double,-1,1,0,-1,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h
;	COMDAT ??$checkTransposeAliasing@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@?$DenseBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@IEBAXAEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@@Z
_TEXT	SEGMENT
this$dead$ = 8
other$dead$ = 16
??$checkTransposeAliasing@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@?$DenseBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@IEBAXAEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@@Z PROC ; Eigen::DenseBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::checkTransposeAliasing<Eigen::Matrix<double,-1,-1,0,-1,-1> >, COMDAT

; 413  :     internal::checkTransposeAliasing_impl<Derived, OtherDerived>::run(derived(), other);
; 414  : }

	ret	0
??$checkTransposeAliasing@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@?$DenseBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@IEBAXAEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@@Z ENDP ; Eigen::DenseBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::checkTransposeAliasing<Eigen::Matrix<double,-1,-1,0,-1,-1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h
;	COMDAT ??$checkTransposeAliasing@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@?$DenseBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@IEBAXAEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 8
other$ = 16
??$checkTransposeAliasing@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@?$DenseBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@IEBAXAEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@1@@Z PROC ; Eigen::DenseBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::checkTransposeAliasing<Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> > >, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 199  :     inline const Scalar* data() const { return this->m_data; }

	mov	r8, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h

; 361  :     return (bool(blas_traits<OtherDerived>::IsTransposed) != DestIsTransposed) && (dest!=0 && dest==(const Scalar*)extract_data(src));

	test	r8, r8
	je	SHORT $LN8@checkTrans
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 262  :     inline T *data() { return m_data; }

	mov	rax, QWORD PTR [rdx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h

; 361  :     return (bool(blas_traits<OtherDerived>::IsTransposed) != DestIsTransposed) && (dest!=0 && dest==(const Scalar*)extract_data(src));

	cmp	r8, QWORD PTR [rax]
	jne	SHORT $LN8@checkTrans

; 362  :   }
; 363  : };
; 364  : 
; 365  : template<typename Scalar, bool DestIsTransposed, typename BinOp, typename DerivedA, typename DerivedB>
; 366  : struct check_transpose_aliasing_run_time_selector<Scalar,DestIsTransposed,CwiseBinaryOp<BinOp,DerivedA,DerivedB> >
; 367  : {
; 368  :   static bool run(const Scalar* dest, const CwiseBinaryOp<BinOp,DerivedA,DerivedB>& src)
; 369  :   {
; 370  :     return ((blas_traits<DerivedA>::IsTransposed != DestIsTransposed) && (dest!=0 && dest==(const Scalar*)extract_data(src.lhs())))
; 371  :         || ((blas_traits<DerivedB>::IsTransposed != DestIsTransposed) && (dest!=0 && dest==(const Scalar*)extract_data(src.rhs())));
; 372  :   }
; 373  : };
; 374  : 
; 375  : // the following selector, checkTransposeAliasing_impl, based on MightHaveTransposeAliasing,
; 376  : // is because when the condition controlling the assert is known at compile time, ICC emits a warning.
; 377  : // This is actually a good warning: in expressions that don't have any transposing, the condition is
; 378  : // known at compile time to be false, and using that, we can avoid generating the code of the assert again
; 379  : // and again for all these expressions that don't need it.
; 380  : 
; 381  : template<typename Derived, typename OtherDerived,
; 382  :          bool MightHaveTransposeAliasing
; 383  :                  = check_transpose_aliasing_compile_time_selector
; 384  :                      <blas_traits<Derived>::IsTransposed,OtherDerived>::ret
; 385  :         >
; 386  : struct checkTransposeAliasing_impl
; 387  : {
; 388  :     static void run(const Derived& dst, const OtherDerived& other)
; 389  :     {
; 390  :         eigen_assert((!check_transpose_aliasing_run_time_selector

	lea	rdx, OFFSET FLAT:??_C@_1LE@ODIDILMJ@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1CCG@OOFKGNBC@?$AA?$CI?$AA?$CB?$AAc?$AAh?$AAe?$AAc?$AAk?$AA_?$AAt?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AA_?$AAa?$AAl?$AAi?$AAa?$AAs?$AAi?$AAn?$AAg?$AA_?$AAr?$AAu?$AAn?$AA_?$AAt@
	mov	r8d, 394				; 0000018aH
	rex_jmp	QWORD PTR __imp__wassert
$LN8@checkTrans:

; 413  :     internal::checkTransposeAliasing_impl<Derived, OtherDerived>::run(derived(), other);
; 414  : }

	ret	0
??$checkTransposeAliasing@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@?$DenseBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@IEBAXAEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@1@@Z ENDP ; Eigen::DenseBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::checkTransposeAliasing<Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
;	COMDAT ??$lazyAssign@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$DenseBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 48
other$ = 56
??$lazyAssign@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$DenseBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z PROC ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,1,0,-1,1> >::lazyAssign<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const >,4> >, COMDAT

; 411  :     EIGEN_STRONG_INLINE Derived& lazyAssign(const DenseBase<OtherDerived>& other)

$LN228:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rax, QWORD PTR [rdx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 411  :     EIGEN_STRONG_INLINE Derived& lazyAssign(const DenseBase<OtherDerived>& other)

	mov	rsi, rdx
	mov	rdi, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rbx, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	mov	rbp, 9223372036854775807		; 7fffffffffffffffH
	test	rbx, rbx
	je	SHORT $LN223@lazyAssign
	cmp	rbx, rbp
	setg	al

; 45   :     if (error)

	test	al, al
	jne	SHORT $LN225@lazyAssign

; 47   :   }
; 48   : };
; 49   : 
; 50   : template <typename Derived,
; 51   :           typename OtherDerived = Derived,
; 52   :           bool IsVector = bool(Derived::IsVectorAtCompileTime) && bool(OtherDerived::IsVectorAtCompileTime)>
; 53   : struct conservative_resize_like_impl;
; 54   : 
; 55   : template<typename MatrixTypeA, typename MatrixTypeB, bool SwapPointers> struct matrix_swap_impl;
; 56   : 
; 57   : } // end namespace internal
; 58   : 
; 59   : /** \class PlainObjectBase
; 60   :   * \brief %Dense storage base class for matrices and arrays.
; 61   :   *
; 62   :   * This class can be extended with the help of the plugin mechanism described on the page
; 63   :   * \ref TopicCustomizingEigen by defining the preprocessor symbol \c EIGEN_PLAINOBJECTBASE_PLUGIN.
; 64   :   *
; 65   :   * \sa \ref TopicClassHierarchy
; 66   :   */
; 67   : #ifdef EIGEN_PARSED_BY_DOXYGEN
; 68   : namespace internal {
; 69   : 
; 70   : // this is a warkaround to doxygen not being able to understand the inheritence logic
; 71   : // when it is hidden by the dense_xpr_base helper struct.
; 72   : template<typename Derived> struct dense_xpr_base_dispatcher_for_doxygen;// : public MatrixBase<Derived> {};
; 73   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 74   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 75   : struct dense_xpr_base_dispatcher_for_doxygen<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 76   :     : public MatrixBase<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 77   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 78   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 79   : struct dense_xpr_base_dispatcher_for_doxygen<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 80   :     : public ArrayBase<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 81   : 
; 82   : } // namespace internal
; 83   : 
; 84   : template<typename Derived>
; 85   : class PlainObjectBase : public internal::dense_xpr_base_dispatcher_for_doxygen<Derived>
; 86   : #else
; 87   : template<typename Derived>
; 88   : class PlainObjectBase : public internal::dense_xpr_base<Derived>::type
; 89   : #endif
; 90   : {
; 91   :   public:
; 92   :     enum { Options = internal::traits<Derived>::Options };
; 93   :     typedef typename internal::dense_xpr_base<Derived>::type Base;
; 94   : 
; 95   :     typedef typename internal::traits<Derived>::StorageKind StorageKind;
; 96   :     typedef typename internal::traits<Derived>::Index Index;
; 97   :     typedef typename internal::traits<Derived>::Scalar Scalar;
; 98   :     typedef typename internal::packet_traits<Scalar>::type PacketScalar;
; 99   :     typedef typename NumTraits<Scalar>::Real RealScalar;
; 100  :     typedef Derived DenseType;
; 101  : 
; 102  :     using Base::RowsAtCompileTime;
; 103  :     using Base::ColsAtCompileTime;
; 104  :     using Base::SizeAtCompileTime;
; 105  :     using Base::MaxRowsAtCompileTime;
; 106  :     using Base::MaxColsAtCompileTime;
; 107  :     using Base::MaxSizeAtCompileTime;
; 108  :     using Base::IsVectorAtCompileTime;
; 109  :     using Base::Flags;
; 110  : 
; 111  :     template<typename PlainObjectType, int MapOptions, typename StrideType> friend class Eigen::Map;
; 112  :     friend  class Eigen::Map<Derived, Unaligned>;
; 113  :     typedef Eigen::Map<Derived, Unaligned>  MapType;
; 114  :     friend  class Eigen::Map<const Derived, Unaligned>;
; 115  :     typedef const Eigen::Map<const Derived, Unaligned> ConstMapType;
; 116  :     friend  class Eigen::Map<Derived, Aligned>;
; 117  :     typedef Eigen::Map<Derived, Aligned> AlignedMapType;
; 118  :     friend  class Eigen::Map<const Derived, Aligned>;
; 119  :     typedef const Eigen::Map<const Derived, Aligned> ConstAlignedMapType;
; 120  :     template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };
; 121  :     template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };
; 122  :     template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, Aligned, StrideType> type; };
; 123  :     template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, Aligned, StrideType> type; };
; 124  : 
; 125  :   protected:
; 126  :     DenseStorage<Scalar, Base::MaxSizeAtCompileTime, Base::RowsAtCompileTime, Base::ColsAtCompileTime, Options> m_storage;
; 127  : 
; 128  :   public:
; 129  :     enum { NeedsToAlign = SizeAtCompileTime != Dynamic && (internal::traits<Derived>::Flags & AlignedBit) != 0 };
; 130  :     EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(NeedsToAlign)
; 131  : 
; 132  :     Base& base() { return *static_cast<Base*>(this); }
; 133  :     const Base& base() const { return *static_cast<const Base*>(this); }
; 134  : 
; 135  :     EIGEN_STRONG_INLINE Index rows() const { return m_storage.rows(); }
; 136  :     EIGEN_STRONG_INLINE Index cols() const { return m_storage.cols(); }
; 137  : 
; 138  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index rowId, Index colId) const
; 139  :     {
; 140  :       if(Flags & RowMajorBit)
; 141  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 142  :       else // column-major
; 143  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 144  :     }
; 145  : 
; 146  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index index) const
; 147  :     {
; 148  :       return m_storage.data()[index];
; 149  :     }
; 150  : 
; 151  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index rowId, Index colId)
; 152  :     {
; 153  :       if(Flags & RowMajorBit)
; 154  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 155  :       else // column-major
; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 157  :     }
; 158  : 
; 159  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
; 160  :     {
; 161  :       return m_storage.data()[index];
; 162  :     }
; 163  : 
; 164  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
; 165  :     {
; 166  :       if(Flags & RowMajorBit)
; 167  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 168  :       else // column-major
; 169  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 170  :     }
; 171  : 
; 172  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
; 173  :     {
; 174  :       return m_storage.data()[index];
; 175  :     }
; 176  : 
; 177  :     /** \internal */
; 178  :     template<int LoadMode>
; 179  :     EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const
; 180  :     {
; 181  :       return internal::ploadt<PacketScalar, LoadMode>
; 182  :                (m_storage.data() + (Flags & RowMajorBit
; 183  :                                    ? colId + rowId * m_storage.cols()
; 184  :                                    : rowId + colId * m_storage.rows()));
; 185  :     }
; 186  : 
; 187  :     /** \internal */
; 188  :     template<int LoadMode>
; 189  :     EIGEN_STRONG_INLINE PacketScalar packet(Index index) const
; 190  :     {
; 191  :       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);
; 192  :     }
; 193  : 
; 194  :     /** \internal */
; 195  :     template<int StoreMode>
; 196  :     EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)
; 197  :     {
; 198  :       internal::pstoret<Scalar, PacketScalar, StoreMode>
; 199  :               (m_storage.data() + (Flags & RowMajorBit
; 200  :                                    ? colId + rowId * m_storage.cols()
; 201  :                                    : rowId + colId * m_storage.rows()), val);
; 202  :     }
; 203  : 
; 204  :     /** \internal */
; 205  :     template<int StoreMode>
; 206  :     EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
; 207  :     {
; 208  :       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
; 209  :     }
; 210  : 
; 211  :     /** \returns a const pointer to the data array of this matrix */
; 212  :     EIGEN_STRONG_INLINE const Scalar *data() const
; 213  :     { return m_storage.data(); }
; 214  : 
; 215  :     /** \returns a pointer to the data array of this matrix */
; 216  :     EIGEN_STRONG_INLINE Scalar *data()
; 217  :     { return m_storage.data(); }
; 218  : 
; 219  :     /** Resizes \c *this to a \a rows x \a cols matrix.
; 220  :       *
; 221  :       * This method is intended for dynamic-size matrices, although it is legal to call it on any
; 222  :       * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
; 223  :       * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
; 224  :       *
; 225  :       * If the current number of coefficients of \c *this exactly matches the
; 226  :       * product \a rows * \a cols, then no memory allocation is performed and
; 227  :       * the current values are left unchanged. In all other cases, including
; 228  :       * shrinking, the data is reallocated and all previous values are lost.
; 229  :       *
; 230  :       * Example: \include Matrix_resize_int_int.cpp
; 231  :       * Output: \verbinclude Matrix_resize_int_int.out
; 232  :       *
; 233  :       * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
; 234  :       */
; 235  :     EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)
; 236  :     {
; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rbx, rbx
$LN223@lazyAssign:
	jns	SHORT $LN130@lazyAssign
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	mov	r8d, 241				; 000000f1H
	call	QWORD PTR __imp__wassert
$LN130@lazyAssign:

; 44   :                : (rows > max_index / cols);

	test	rbx, rbx
	je	SHORT $LN137@lazyAssign
	cmp	rbx, rbp
	setg	al

; 45   :     if (error)

	test	al, al
	jne	SHORT $LN227@lazyAssign
$LN137@lazyAssign:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 322  :       if(size != m_rows*_Cols)

	cmp	rbx, QWORD PTR [rdi+8]
	je	SHORT $LN142@lazyAssign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR [rdi]
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 325  :         if (size)

	test	rbx, rbx
	je	SHORT $LN143@lazyAssign

; 326  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

	mov	rcx, rbx
	call	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
	mov	QWORD PTR [rdi], rax

; 327  :         else

	jmp	SHORT $LN142@lazyAssign
$LN143@lazyAssign:

; 328  :           m_data = 0;

	mov	QWORD PTR [rdi], 0
$LN142@lazyAssign:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h

; 284  :   other.derived().evalTo(derived());

	mov	rdx, rdi
	mov	rcx, rsi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 331  :       m_rows = nbRows;

	mov	QWORD PTR [rdi+8], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h

; 284  :   other.derived().evalTo(derived());

	call	??$evalTo@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEBAXAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@@Z ; Eigen::ProductBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const > >::evalTo<Eigen::Matrix<double,-1,1,0,-1,1> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 415  :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN225@lazyAssign:

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN227@lazyAssign:
	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN222@lazyAssign:
??$lazyAssign@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$DenseBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z ENDP ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,1,0,-1,1> >::lazyAssign<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const >,4> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
;	COMDAT ??$lazyAssign@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$DenseBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 48
other$ = 56
??$lazyAssign@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$DenseBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z PROC ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,1,0,-1,1> >::lazyAssign<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4> >, COMDAT

; 411  :     EIGEN_STRONG_INLINE Derived& lazyAssign(const DenseBase<OtherDerived>& other)

$LN228:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rax, QWORD PTR [rdx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 411  :     EIGEN_STRONG_INLINE Derived& lazyAssign(const DenseBase<OtherDerived>& other)

	mov	rsi, rdx
	mov	rdi, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rbx, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	mov	rbp, 9223372036854775807		; 7fffffffffffffffH
	test	rbx, rbx
	je	SHORT $LN223@lazyAssign
	cmp	rbx, rbp
	setg	al

; 45   :     if (error)

	test	al, al
	jne	SHORT $LN225@lazyAssign

; 47   :   }
; 48   : };
; 49   : 
; 50   : template <typename Derived,
; 51   :           typename OtherDerived = Derived,
; 52   :           bool IsVector = bool(Derived::IsVectorAtCompileTime) && bool(OtherDerived::IsVectorAtCompileTime)>
; 53   : struct conservative_resize_like_impl;
; 54   : 
; 55   : template<typename MatrixTypeA, typename MatrixTypeB, bool SwapPointers> struct matrix_swap_impl;
; 56   : 
; 57   : } // end namespace internal
; 58   : 
; 59   : /** \class PlainObjectBase
; 60   :   * \brief %Dense storage base class for matrices and arrays.
; 61   :   *
; 62   :   * This class can be extended with the help of the plugin mechanism described on the page
; 63   :   * \ref TopicCustomizingEigen by defining the preprocessor symbol \c EIGEN_PLAINOBJECTBASE_PLUGIN.
; 64   :   *
; 65   :   * \sa \ref TopicClassHierarchy
; 66   :   */
; 67   : #ifdef EIGEN_PARSED_BY_DOXYGEN
; 68   : namespace internal {
; 69   : 
; 70   : // this is a warkaround to doxygen not being able to understand the inheritence logic
; 71   : // when it is hidden by the dense_xpr_base helper struct.
; 72   : template<typename Derived> struct dense_xpr_base_dispatcher_for_doxygen;// : public MatrixBase<Derived> {};
; 73   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 74   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 75   : struct dense_xpr_base_dispatcher_for_doxygen<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 76   :     : public MatrixBase<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 77   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 78   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 79   : struct dense_xpr_base_dispatcher_for_doxygen<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 80   :     : public ArrayBase<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 81   : 
; 82   : } // namespace internal
; 83   : 
; 84   : template<typename Derived>
; 85   : class PlainObjectBase : public internal::dense_xpr_base_dispatcher_for_doxygen<Derived>
; 86   : #else
; 87   : template<typename Derived>
; 88   : class PlainObjectBase : public internal::dense_xpr_base<Derived>::type
; 89   : #endif
; 90   : {
; 91   :   public:
; 92   :     enum { Options = internal::traits<Derived>::Options };
; 93   :     typedef typename internal::dense_xpr_base<Derived>::type Base;
; 94   : 
; 95   :     typedef typename internal::traits<Derived>::StorageKind StorageKind;
; 96   :     typedef typename internal::traits<Derived>::Index Index;
; 97   :     typedef typename internal::traits<Derived>::Scalar Scalar;
; 98   :     typedef typename internal::packet_traits<Scalar>::type PacketScalar;
; 99   :     typedef typename NumTraits<Scalar>::Real RealScalar;
; 100  :     typedef Derived DenseType;
; 101  : 
; 102  :     using Base::RowsAtCompileTime;
; 103  :     using Base::ColsAtCompileTime;
; 104  :     using Base::SizeAtCompileTime;
; 105  :     using Base::MaxRowsAtCompileTime;
; 106  :     using Base::MaxColsAtCompileTime;
; 107  :     using Base::MaxSizeAtCompileTime;
; 108  :     using Base::IsVectorAtCompileTime;
; 109  :     using Base::Flags;
; 110  : 
; 111  :     template<typename PlainObjectType, int MapOptions, typename StrideType> friend class Eigen::Map;
; 112  :     friend  class Eigen::Map<Derived, Unaligned>;
; 113  :     typedef Eigen::Map<Derived, Unaligned>  MapType;
; 114  :     friend  class Eigen::Map<const Derived, Unaligned>;
; 115  :     typedef const Eigen::Map<const Derived, Unaligned> ConstMapType;
; 116  :     friend  class Eigen::Map<Derived, Aligned>;
; 117  :     typedef Eigen::Map<Derived, Aligned> AlignedMapType;
; 118  :     friend  class Eigen::Map<const Derived, Aligned>;
; 119  :     typedef const Eigen::Map<const Derived, Aligned> ConstAlignedMapType;
; 120  :     template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };
; 121  :     template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };
; 122  :     template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, Aligned, StrideType> type; };
; 123  :     template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, Aligned, StrideType> type; };
; 124  : 
; 125  :   protected:
; 126  :     DenseStorage<Scalar, Base::MaxSizeAtCompileTime, Base::RowsAtCompileTime, Base::ColsAtCompileTime, Options> m_storage;
; 127  : 
; 128  :   public:
; 129  :     enum { NeedsToAlign = SizeAtCompileTime != Dynamic && (internal::traits<Derived>::Flags & AlignedBit) != 0 };
; 130  :     EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(NeedsToAlign)
; 131  : 
; 132  :     Base& base() { return *static_cast<Base*>(this); }
; 133  :     const Base& base() const { return *static_cast<const Base*>(this); }
; 134  : 
; 135  :     EIGEN_STRONG_INLINE Index rows() const { return m_storage.rows(); }
; 136  :     EIGEN_STRONG_INLINE Index cols() const { return m_storage.cols(); }
; 137  : 
; 138  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index rowId, Index colId) const
; 139  :     {
; 140  :       if(Flags & RowMajorBit)
; 141  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 142  :       else // column-major
; 143  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 144  :     }
; 145  : 
; 146  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index index) const
; 147  :     {
; 148  :       return m_storage.data()[index];
; 149  :     }
; 150  : 
; 151  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index rowId, Index colId)
; 152  :     {
; 153  :       if(Flags & RowMajorBit)
; 154  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 155  :       else // column-major
; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 157  :     }
; 158  : 
; 159  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
; 160  :     {
; 161  :       return m_storage.data()[index];
; 162  :     }
; 163  : 
; 164  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
; 165  :     {
; 166  :       if(Flags & RowMajorBit)
; 167  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 168  :       else // column-major
; 169  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 170  :     }
; 171  : 
; 172  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
; 173  :     {
; 174  :       return m_storage.data()[index];
; 175  :     }
; 176  : 
; 177  :     /** \internal */
; 178  :     template<int LoadMode>
; 179  :     EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const
; 180  :     {
; 181  :       return internal::ploadt<PacketScalar, LoadMode>
; 182  :                (m_storage.data() + (Flags & RowMajorBit
; 183  :                                    ? colId + rowId * m_storage.cols()
; 184  :                                    : rowId + colId * m_storage.rows()));
; 185  :     }
; 186  : 
; 187  :     /** \internal */
; 188  :     template<int LoadMode>
; 189  :     EIGEN_STRONG_INLINE PacketScalar packet(Index index) const
; 190  :     {
; 191  :       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);
; 192  :     }
; 193  : 
; 194  :     /** \internal */
; 195  :     template<int StoreMode>
; 196  :     EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)
; 197  :     {
; 198  :       internal::pstoret<Scalar, PacketScalar, StoreMode>
; 199  :               (m_storage.data() + (Flags & RowMajorBit
; 200  :                                    ? colId + rowId * m_storage.cols()
; 201  :                                    : rowId + colId * m_storage.rows()), val);
; 202  :     }
; 203  : 
; 204  :     /** \internal */
; 205  :     template<int StoreMode>
; 206  :     EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
; 207  :     {
; 208  :       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
; 209  :     }
; 210  : 
; 211  :     /** \returns a const pointer to the data array of this matrix */
; 212  :     EIGEN_STRONG_INLINE const Scalar *data() const
; 213  :     { return m_storage.data(); }
; 214  : 
; 215  :     /** \returns a pointer to the data array of this matrix */
; 216  :     EIGEN_STRONG_INLINE Scalar *data()
; 217  :     { return m_storage.data(); }
; 218  : 
; 219  :     /** Resizes \c *this to a \a rows x \a cols matrix.
; 220  :       *
; 221  :       * This method is intended for dynamic-size matrices, although it is legal to call it on any
; 222  :       * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
; 223  :       * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
; 224  :       *
; 225  :       * If the current number of coefficients of \c *this exactly matches the
; 226  :       * product \a rows * \a cols, then no memory allocation is performed and
; 227  :       * the current values are left unchanged. In all other cases, including
; 228  :       * shrinking, the data is reallocated and all previous values are lost.
; 229  :       *
; 230  :       * Example: \include Matrix_resize_int_int.cpp
; 231  :       * Output: \verbinclude Matrix_resize_int_int.out
; 232  :       *
; 233  :       * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
; 234  :       */
; 235  :     EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)
; 236  :     {
; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rbx, rbx
$LN223@lazyAssign:
	jns	SHORT $LN130@lazyAssign
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	mov	r8d, 241				; 000000f1H
	call	QWORD PTR __imp__wassert
$LN130@lazyAssign:

; 44   :                : (rows > max_index / cols);

	test	rbx, rbx
	je	SHORT $LN137@lazyAssign
	cmp	rbx, rbp
	setg	al

; 45   :     if (error)

	test	al, al
	jne	SHORT $LN227@lazyAssign
$LN137@lazyAssign:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 322  :       if(size != m_rows*_Cols)

	cmp	rbx, QWORD PTR [rdi+8]
	je	SHORT $LN142@lazyAssign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR [rdi]
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 325  :         if (size)

	test	rbx, rbx
	je	SHORT $LN143@lazyAssign

; 326  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

	mov	rcx, rbx
	call	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
	mov	QWORD PTR [rdi], rax

; 327  :         else

	jmp	SHORT $LN142@lazyAssign
$LN143@lazyAssign:

; 328  :           m_data = 0;

	mov	QWORD PTR [rdi], 0
$LN142@lazyAssign:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h

; 284  :   other.derived().evalTo(derived());

	mov	rdx, rdi
	mov	rcx, rsi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 331  :       m_rows = nbRows;

	mov	QWORD PTR [rdi+8], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h

; 284  :   other.derived().evalTo(derived());

	call	??$evalTo@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEBAXAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@@Z ; Eigen::ProductBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >::evalTo<Eigen::Matrix<double,-1,1,0,-1,1> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 415  :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN225@lazyAssign:

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN227@lazyAssign:
	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN222@lazyAssign:
??$lazyAssign@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$DenseBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z ENDP ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,1,0,-1,1> >::lazyAssign<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
;	COMDAT ??$lazyAssign@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 64
other$ = 72
??$lazyAssign@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z PROC ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::lazyAssign<Eigen::Matrix<double,-1,1,0,-1,1> >, COMDAT

; 411  :     EIGEN_STRONG_INLINE Derived& lazyAssign(const DenseBase<OtherDerived>& other)

$LN284:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 313  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rsi, QWORD PTR [rdx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 411  :     EIGEN_STRONG_INLINE Derived& lazyAssign(const DenseBase<OtherDerived>& other)

	mov	r14, rdx
	mov	rbx, rcx

; 44   :                : (rows > max_index / cols);

	mov	rdi, 9223372036854775807		; 7fffffffffffffffH
	test	rsi, rsi
	je	SHORT $LN279@lazyAssign
	cmp	rsi, rdi
	setg	al

; 45   :     if (error)

	test	al, al
	jne	$LN281@lazyAssign

; 47   :   }
; 48   : };
; 49   : 
; 50   : template <typename Derived,
; 51   :           typename OtherDerived = Derived,
; 52   :           bool IsVector = bool(Derived::IsVectorAtCompileTime) && bool(OtherDerived::IsVectorAtCompileTime)>
; 53   : struct conservative_resize_like_impl;
; 54   : 
; 55   : template<typename MatrixTypeA, typename MatrixTypeB, bool SwapPointers> struct matrix_swap_impl;
; 56   : 
; 57   : } // end namespace internal
; 58   : 
; 59   : /** \class PlainObjectBase
; 60   :   * \brief %Dense storage base class for matrices and arrays.
; 61   :   *
; 62   :   * This class can be extended with the help of the plugin mechanism described on the page
; 63   :   * \ref TopicCustomizingEigen by defining the preprocessor symbol \c EIGEN_PLAINOBJECTBASE_PLUGIN.
; 64   :   *
; 65   :   * \sa \ref TopicClassHierarchy
; 66   :   */
; 67   : #ifdef EIGEN_PARSED_BY_DOXYGEN
; 68   : namespace internal {
; 69   : 
; 70   : // this is a warkaround to doxygen not being able to understand the inheritence logic
; 71   : // when it is hidden by the dense_xpr_base helper struct.
; 72   : template<typename Derived> struct dense_xpr_base_dispatcher_for_doxygen;// : public MatrixBase<Derived> {};
; 73   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 74   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 75   : struct dense_xpr_base_dispatcher_for_doxygen<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 76   :     : public MatrixBase<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 77   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 78   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 79   : struct dense_xpr_base_dispatcher_for_doxygen<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 80   :     : public ArrayBase<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 81   : 
; 82   : } // namespace internal
; 83   : 
; 84   : template<typename Derived>
; 85   : class PlainObjectBase : public internal::dense_xpr_base_dispatcher_for_doxygen<Derived>
; 86   : #else
; 87   : template<typename Derived>
; 88   : class PlainObjectBase : public internal::dense_xpr_base<Derived>::type
; 89   : #endif
; 90   : {
; 91   :   public:
; 92   :     enum { Options = internal::traits<Derived>::Options };
; 93   :     typedef typename internal::dense_xpr_base<Derived>::type Base;
; 94   : 
; 95   :     typedef typename internal::traits<Derived>::StorageKind StorageKind;
; 96   :     typedef typename internal::traits<Derived>::Index Index;
; 97   :     typedef typename internal::traits<Derived>::Scalar Scalar;
; 98   :     typedef typename internal::packet_traits<Scalar>::type PacketScalar;
; 99   :     typedef typename NumTraits<Scalar>::Real RealScalar;
; 100  :     typedef Derived DenseType;
; 101  : 
; 102  :     using Base::RowsAtCompileTime;
; 103  :     using Base::ColsAtCompileTime;
; 104  :     using Base::SizeAtCompileTime;
; 105  :     using Base::MaxRowsAtCompileTime;
; 106  :     using Base::MaxColsAtCompileTime;
; 107  :     using Base::MaxSizeAtCompileTime;
; 108  :     using Base::IsVectorAtCompileTime;
; 109  :     using Base::Flags;
; 110  : 
; 111  :     template<typename PlainObjectType, int MapOptions, typename StrideType> friend class Eigen::Map;
; 112  :     friend  class Eigen::Map<Derived, Unaligned>;
; 113  :     typedef Eigen::Map<Derived, Unaligned>  MapType;
; 114  :     friend  class Eigen::Map<const Derived, Unaligned>;
; 115  :     typedef const Eigen::Map<const Derived, Unaligned> ConstMapType;
; 116  :     friend  class Eigen::Map<Derived, Aligned>;
; 117  :     typedef Eigen::Map<Derived, Aligned> AlignedMapType;
; 118  :     friend  class Eigen::Map<const Derived, Aligned>;
; 119  :     typedef const Eigen::Map<const Derived, Aligned> ConstAlignedMapType;
; 120  :     template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };
; 121  :     template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };
; 122  :     template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, Aligned, StrideType> type; };
; 123  :     template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, Aligned, StrideType> type; };
; 124  : 
; 125  :   protected:
; 126  :     DenseStorage<Scalar, Base::MaxSizeAtCompileTime, Base::RowsAtCompileTime, Base::ColsAtCompileTime, Options> m_storage;
; 127  : 
; 128  :   public:
; 129  :     enum { NeedsToAlign = SizeAtCompileTime != Dynamic && (internal::traits<Derived>::Flags & AlignedBit) != 0 };
; 130  :     EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(NeedsToAlign)
; 131  : 
; 132  :     Base& base() { return *static_cast<Base*>(this); }
; 133  :     const Base& base() const { return *static_cast<const Base*>(this); }
; 134  : 
; 135  :     EIGEN_STRONG_INLINE Index rows() const { return m_storage.rows(); }
; 136  :     EIGEN_STRONG_INLINE Index cols() const { return m_storage.cols(); }
; 137  : 
; 138  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index rowId, Index colId) const
; 139  :     {
; 140  :       if(Flags & RowMajorBit)
; 141  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 142  :       else // column-major
; 143  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 144  :     }
; 145  : 
; 146  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index index) const
; 147  :     {
; 148  :       return m_storage.data()[index];
; 149  :     }
; 150  : 
; 151  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index rowId, Index colId)
; 152  :     {
; 153  :       if(Flags & RowMajorBit)
; 154  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 155  :       else // column-major
; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 157  :     }
; 158  : 
; 159  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
; 160  :     {
; 161  :       return m_storage.data()[index];
; 162  :     }
; 163  : 
; 164  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
; 165  :     {
; 166  :       if(Flags & RowMajorBit)
; 167  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 168  :       else // column-major
; 169  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 170  :     }
; 171  : 
; 172  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
; 173  :     {
; 174  :       return m_storage.data()[index];
; 175  :     }
; 176  : 
; 177  :     /** \internal */
; 178  :     template<int LoadMode>
; 179  :     EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const
; 180  :     {
; 181  :       return internal::ploadt<PacketScalar, LoadMode>
; 182  :                (m_storage.data() + (Flags & RowMajorBit
; 183  :                                    ? colId + rowId * m_storage.cols()
; 184  :                                    : rowId + colId * m_storage.rows()));
; 185  :     }
; 186  : 
; 187  :     /** \internal */
; 188  :     template<int LoadMode>
; 189  :     EIGEN_STRONG_INLINE PacketScalar packet(Index index) const
; 190  :     {
; 191  :       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);
; 192  :     }
; 193  : 
; 194  :     /** \internal */
; 195  :     template<int StoreMode>
; 196  :     EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)
; 197  :     {
; 198  :       internal::pstoret<Scalar, PacketScalar, StoreMode>
; 199  :               (m_storage.data() + (Flags & RowMajorBit
; 200  :                                    ? colId + rowId * m_storage.cols()
; 201  :                                    : rowId + colId * m_storage.rows()), val);
; 202  :     }
; 203  : 
; 204  :     /** \internal */
; 205  :     template<int StoreMode>
; 206  :     EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
; 207  :     {
; 208  :       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
; 209  :     }
; 210  : 
; 211  :     /** \returns a const pointer to the data array of this matrix */
; 212  :     EIGEN_STRONG_INLINE const Scalar *data() const
; 213  :     { return m_storage.data(); }
; 214  : 
; 215  :     /** \returns a pointer to the data array of this matrix */
; 216  :     EIGEN_STRONG_INLINE Scalar *data()
; 217  :     { return m_storage.data(); }
; 218  : 
; 219  :     /** Resizes \c *this to a \a rows x \a cols matrix.
; 220  :       *
; 221  :       * This method is intended for dynamic-size matrices, although it is legal to call it on any
; 222  :       * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
; 223  :       * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
; 224  :       *
; 225  :       * If the current number of coefficients of \c *this exactly matches the
; 226  :       * product \a rows * \a cols, then no memory allocation is performed and
; 227  :       * the current values are left unchanged. In all other cases, including
; 228  :       * shrinking, the data is reallocated and all previous values are lost.
; 229  :       *
; 230  :       * Example: \include Matrix_resize_int_int.cpp
; 231  :       * Output: \verbinclude Matrix_resize_int_int.out
; 232  :       *
; 233  :       * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
; 234  :       */
; 235  :     EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)
; 236  :     {
; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rsi, rsi
$LN279@lazyAssign:
	jns	SHORT $LN128@lazyAssign
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	mov	r8d, 241				; 000000f1H
	call	QWORD PTR __imp__wassert
$LN128@lazyAssign:

; 44   :                : (rows > max_index / cols);

	test	rsi, rsi
	je	SHORT $LN135@lazyAssign
	cmp	rsi, rdi
	setg	al

; 45   :     if (error)

	test	al, al
	jne	$LN283@lazyAssign
$LN135@lazyAssign:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 249  :       if(size != m_rows*m_cols)

	mov	rax, QWORD PTR [rbx+16]
	xor	edi, edi
	imul	rax, QWORD PTR [rbx+8]
	cmp	rsi, rax
	je	SHORT $LN140@lazyAssign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR [rbx]
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 252  :         if (size)

	test	rsi, rsi
	je	SHORT $LN141@lazyAssign

; 253  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

	mov	rcx, rsi
	call	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
	mov	QWORD PTR [rbx], rax

; 254  :         else

	jmp	SHORT $LN140@lazyAssign
$LN141@lazyAssign:

; 255  :           m_data = 0;

	mov	QWORD PTR [rbx], rdi
$LN140@lazyAssign:

; 256  :         EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN
; 257  :       }
; 258  :       m_rows = nbRows;

	mov	QWORD PTR [rbx+8], rsi

; 259  :       m_cols = nbCols;

	mov	QWORD PTR [rbx+16], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	cmp	rsi, QWORD PTR [r14+8]
	je	SHORT $LN164@lazyAssign
	lea	rdx, OFFSET FLAT:??_C@_1KO@HDGCFKMN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GC@PBCDNLIH@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ@
	mov	r8d, 498				; 000001f2H
	call	QWORD PTR __imp__wassert
$LN164@lazyAssign:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 49   :   inline Index size() const { return rows() * cols(); }

	mov	r9, QWORD PTR [rbx+16]
	imul	r9, QWORD PTR [rbx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 404  :     const Index alignedEnd = alignedStart + ((size-alignedStart)/packetSize)*packetSize;

	mov	rax, r9
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r8, rax
	add	r8, r8

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	test	r8, r8
	jle	SHORT $LN201@lazyAssign
	npad	1
$LL203@lazyAssign:
	mov	rdx, QWORD PTR [r14]
	mov	rax, QWORD PTR [rbx]
	add	rdi, 2
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 220  : template<> EIGEN_STRONG_INLINE Packet2d pload<Packet2d>(const double*  from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_pd(from); }

	movaps	xmm0, XMMWORD PTR [rdx+rdi*8-16]

; 221  : template<> EIGEN_STRONG_INLINE Packet4i pload<Packet4i>(const int*     from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_si128(reinterpret_cast<const Packet4i*>(from)); }
; 222  : 
; 223  : #if defined(_MSC_VER)
; 224  :   template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float*  from) {
; 225  :     EIGEN_DEBUG_UNALIGNED_LOAD
; 226  :     #if (_MSC_VER==1600)
; 227  :     // NOTE Some version of MSVC10 generates bad code when using _mm_loadu_ps
; 228  :     // (i.e., it does not generate an unaligned load!!
; 229  :     // TODO On most architectures this version should also be faster than a single _mm_loadu_ps
; 230  :     // so we could also enable it for MSVC08 but first we have to make this later does not generate crap when doing so...
; 231  :     __m128 res = _mm_loadl_pi(_mm_set1_ps(0.0f), (const __m64*)(from));
; 232  :     res = _mm_loadh_pi(res, (const __m64*)(from+2));
; 233  :     return res;
; 234  :     #else
; 235  :     return _mm_loadu_ps(from);
; 236  :     #endif
; 237  :   }
; 238  :   template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm_loadu_pd(from); }
; 239  :   template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int*    from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm_loadu_si128(reinterpret_cast<const Packet4i*>(from)); }
; 240  : #else
; 241  : // Fast unaligned loads. Note that here we cannot directly use intrinsics: this would
; 242  : // require pointer casting to incompatible pointer types and leads to invalid code
; 243  : // because of the strict aliasing rule. The "dummy" stuff are required to enforce
; 244  : // a correct instruction dependency.
; 245  : // TODO: do the same for MSVC (ICC is compatible)
; 246  : // NOTE: with the code below, MSVC's compiler crashes!
; 247  : 
; 248  : #if defined(__GNUC__) && defined(__i386__)
; 249  :   // bug 195: gcc/i386 emits weird x87 fldl/fstpl instructions for _mm_load_sd
; 250  :   #define EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS 1
; 251  : #elif defined(__clang__)
; 252  :   // bug 201: Segfaults in __mm_loadh_pd with clang 2.8
; 253  :   #define EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS 1
; 254  : #else
; 255  :   #define EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS 0
; 256  : #endif
; 257  : 
; 258  : template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float* from)
; 259  : {
; 260  :   EIGEN_DEBUG_UNALIGNED_LOAD
; 261  : #if EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS
; 262  :   return _mm_loadu_ps(from);
; 263  : #else
; 264  :   __m128d res;
; 265  :   res =  _mm_load_sd((const double*)(from)) ;
; 266  :   res =  _mm_loadh_pd(res, (const double*)(from+2)) ;
; 267  :   return _mm_castpd_ps(res);
; 268  : #endif
; 269  : }
; 270  : template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from)
; 271  : {
; 272  :   EIGEN_DEBUG_UNALIGNED_LOAD
; 273  : #if EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS
; 274  :   return _mm_loadu_pd(from);
; 275  : #else
; 276  :   __m128d res;
; 277  :   res = _mm_load_sd(from) ;
; 278  :   res = _mm_loadh_pd(res,from+1);
; 279  :   return res;
; 280  : #endif
; 281  : }
; 282  : template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int* from)
; 283  : {
; 284  :   EIGEN_DEBUG_UNALIGNED_LOAD
; 285  : #if EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS
; 286  :   return _mm_loadu_si128(reinterpret_cast<const Packet4i*>(from));
; 287  : #else
; 288  :   __m128d res;
; 289  :   res =  _mm_load_sd((const double*)(from)) ;
; 290  :   res =  _mm_loadh_pd(res, (const double*)(from+2)) ;
; 291  :   return _mm_castpd_si128(res);
; 292  : #endif
; 293  : }
; 294  : #endif
; 295  : 
; 296  : template<> EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float*   from)
; 297  : {
; 298  :   return vec4f_swizzle1(_mm_castpd_ps(_mm_load_sd(reinterpret_cast<const double*>(from))), 0, 0, 1, 1);
; 299  : }
; 300  : template<> EIGEN_STRONG_INLINE Packet2d ploaddup<Packet2d>(const double*  from)
; 301  : { return pset1<Packet2d>(from[0]); }
; 302  : template<> EIGEN_STRONG_INLINE Packet4i ploaddup<Packet4i>(const int*     from)
; 303  : {
; 304  :   Packet4i tmp;
; 305  :   tmp = _mm_loadl_epi64(reinterpret_cast<const Packet4i*>(from));
; 306  :   return vec4i_swizzle1(tmp, 0, 0, 1, 1);
; 307  : }
; 308  : 
; 309  : template<> EIGEN_STRONG_INLINE void pstore<float>(float*   to, const Packet4f& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_ps(to, from); }
; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [rax+rdi*8-16], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	cmp	rdi, r8
	jl	SHORT $LL203@lazyAssign
$LN201@lazyAssign:

; 409  :     {
; 410  :       dst.template copyPacket<Derived2, dstAlignment, srcAlignment>(index, src);
; 411  :     }
; 412  : 
; 413  :     unaligned_assign_impl<>::run(src,dst,alignedEnd,size);

	mov	rdx, rbx
	mov	rcx, r14
	call	??$run@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@@?$unaligned_assign_impl@$0A@@internal@Eigen@@SAXAEBV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@_J2@Z ; Eigen::internal::unaligned_assign_impl<0>::run<Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Matrix<double,-1,-1,0,-1,-1> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 414  :       return Base::lazyAssign(other.derived());

	mov	rax, rbx

; 415  :     }

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN281@lazyAssign:

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN283@lazyAssign:
	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN278@lazyAssign:
??$lazyAssign@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z ENDP ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::lazyAssign<Eigen::Matrix<double,-1,1,0,-1,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h
;	COMDAT ??$lazyAssign@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@QEAAAEAV01@AEBV?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 48
rhs$ = 56
??$lazyAssign@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@QEAAAEAV01@AEBV?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@1@@Z PROC ; Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::lazyAssign<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >, COMDAT

; 128  :     EIGEN_STRONG_INLINE SelfCwiseBinaryOp& lazyAssign(const DenseBase<RhsDerived>& rhs)

$LN38:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 129  :     {
; 130  :       EIGEN_STATIC_ASSERT_SAME_MATRIX_SIZE(Lhs,RhsDerived)
; 131  :       EIGEN_CHECK_BINARY_COMPATIBILIY(BinaryOp,typename Lhs::Scalar,typename RhsDerived::Scalar);
; 132  :       
; 133  :     #ifdef EIGEN_DEBUG_ASSIGN
; 134  :       internal::assign_traits<SelfCwiseBinaryOp, RhsDerived>::debug();
; 135  :     #endif
; 136  :       eigen_assert(rows() == rhs.rows() && cols() == rhs.cols());

	mov	r8, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rdx+8]
	mov	rbx, rdx
	mov	rdi, rcx
	cmp	QWORD PTR [r8+8], rax
	jne	SHORT $LN3@lazyAssign
	cmp	QWORD PTR [rdx+16], 1
	je	SHORT $LN4@lazyAssign
$LN3@lazyAssign:
	lea	rdx, OFFSET FLAT:??_C@_1ME@CGCHACLK@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1FK@JAKLMIFJ@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAr?$AAh?$AAs?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN@
	mov	r8d, 136				; 00000088H
	call	QWORD PTR __imp__wassert
$LN4@lazyAssign:

; 137  :       internal::assign_impl<SelfCwiseBinaryOp, RhsDerived>::run(*this,rhs.derived());

	mov	rdx, rbx
	mov	rcx, rdi
	call	?run@?$assign_impl@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@3@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Z ; Eigen::internal::assign_impl<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,4,0,0>::run

; 138  :     #ifndef EIGEN_NO_DEBUG
; 139  :       this->checkTransposeAliasing(rhs.derived());
; 140  :     #endif
; 141  :       return *this;
; 142  :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$lazyAssign@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@QEAAAEAV01@AEBV?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@1@@Z ENDP ; Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::lazyAssign<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
;	COMDAT ??$first_aligned@N_J@internal@Eigen@@YA_JPEBN_J@Z
_TEXT	SEGMENT
$T1 = 8
array$ = 8
size$ = 16
??$first_aligned@N_J@internal@Eigen@@YA_JPEBN_J@Z PROC	; Eigen::internal::first_aligned<double,__int64>, COMDAT

; 468  : {

	mov	QWORD PTR [rsp+16], rdx

; 469  :   static const Index PacketSize = packet_traits<Scalar>::size;
; 470  :   static const Index PacketAlignedMask = PacketSize-1;
; 471  : 
; 472  :   if(PacketSize==1)
; 473  :   {
; 474  :     // Either there is no vectorization, or a packet consists of exactly 1 scalar so that all elements
; 475  :     // of the array have the same alignment.
; 476  :     return 0;
; 477  :   }
; 478  :   else if(size_t(array) & (sizeof(Scalar)-1))

	test	cl, 7
	je	SHORT $LN2@first_alig

; 479  :   {
; 480  :     // There is vectorization for this scalar type, but the array is not aligned to the size of a single scalar.
; 481  :     // Consequently, no element of the array is well aligned.
; 482  :     return size;

	mov	rax, rdx

; 488  :   }
; 489  : }

	ret	0
$LN2@first_alig:

; 487  :                            & PacketAlignedMask, size);

	shr	rcx, 3
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 4121 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	rax, QWORD PTR size$[rsp]
	lea	r8, QWORD PTR $T1[rsp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 487  :                            & PacketAlignedMask, size);

	neg	rcx
	and	ecx, 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 4121 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	rdx, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 487  :                            & PacketAlignedMask, size);

	mov	QWORD PTR $T1[rsp], rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 4121 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovge	rax, r8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 487  :                            & PacketAlignedMask, size);

	mov	rax, QWORD PTR [rax]

; 488  :   }
; 489  : }

	ret	0
??$first_aligned@N_J@internal@Eigen@@YA_JPEBN_J@Z ENDP	; Eigen::internal::first_aligned<double,__int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
;	COMDAT ??$copyCoeffByOuterInner@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 8
outer$ = 16
inner$ = 24
other$ = 32
??$copyCoeffByOuterInner@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z PROC ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,1>::copyCoeffByOuterInner<Eigen::Matrix<double,-1,1,0,-1,1> >, COMDAT

; 480  :       derived().coeffRef(row, col) = other.derived().coeff(row, col);

	mov	r10, QWORD PTR [r9+8]
	mov	rax, QWORD PTR [r9]
	mov	r9, QWORD PTR [rcx+32]
	imul	r10, rdx
	imul	r9, rdx
	mov	rcx, QWORD PTR [rcx]
	add	r10, r8
	add	r9, r8
	mov	rax, QWORD PTR [rax+r10*8]
	mov	QWORD PTR [rcx+r9*8], rax

; 501  :     {
; 502  :       const Index row = rowIndexByOuterInner(outer,inner);
; 503  :       const Index col = colIndexByOuterInner(outer,inner);
; 504  :       // derived() is important here: copyCoeff() may be reimplemented in Derived!
; 505  :       derived().copyCoeff(row, col, other);
; 506  :     }

	ret	0
??$copyCoeffByOuterInner@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z ENDP ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,1>::copyCoeffByOuterInner<Eigen::Matrix<double,-1,1,0,-1,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
;	COMDAT ??$copyPacketByOuterInner@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$00$0A@@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 8
outer$ = 16
inner$ = 24
other$ = 32
??$copyPacketByOuterInner@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$00$0A@@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z PROC ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,1>::copyPacketByOuterInner<Eigen::Matrix<double,-1,1,0,-1,1>,1,0>, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 217  :                (this->m_data + (col * colStride() + row * rowStride()), val);

	mov	rax, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	mov	r10, QWORD PTR [rcx+32]
	mov	rcx, QWORD PTR [r9+8]
	imul	r10, rdx
	imul	rcx, rdx
	add	r10, r8
	add	rcx, r8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 217  :                (this->m_data + (col * colStride() + row * rowStride()), val);

	lea	r11, QWORD PTR [rax+r10*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 184  :                                    : rowId + colId * m_storage.rows()));

	mov	rax, QWORD PTR [r9]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 238  :   template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm_loadu_pd(from); }

	movups	xmm0, XMMWORD PTR [rax+rcx*8]

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [r11], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 549  :     }

	ret	0
??$copyPacketByOuterInner@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$00$0A@@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z ENDP ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,1>::copyPacketByOuterInner<Eigen::Matrix<double,-1,1,0,-1,1>,1,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
;	COMDAT ??$copyCoeffByOuterInner@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 8
outer$ = 16
inner$ = 24
other$ = 32
??$copyCoeffByOuterInner@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@1@@Z PROC ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,1>::copyCoeffByOuterInner<Eigen::Matrix<double,-1,-1,0,-1,-1> >, COMDAT

; 480  :       derived().coeffRef(row, col) = other.derived().coeff(row, col);

	mov	r10, QWORD PTR [r9+8]
	mov	rax, QWORD PTR [r9]
	mov	r9, QWORD PTR [rcx+32]
	imul	r10, rdx
	imul	r9, rdx
	mov	rcx, QWORD PTR [rcx]
	add	r10, r8
	add	r9, r8
	mov	rax, QWORD PTR [rax+r10*8]
	mov	QWORD PTR [rcx+r9*8], rax

; 501  :     {
; 502  :       const Index row = rowIndexByOuterInner(outer,inner);
; 503  :       const Index col = colIndexByOuterInner(outer,inner);
; 504  :       // derived() is important here: copyCoeff() may be reimplemented in Derived!
; 505  :       derived().copyCoeff(row, col, other);
; 506  :     }

	ret	0
??$copyCoeffByOuterInner@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@1@@Z ENDP ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,1>::copyCoeffByOuterInner<Eigen::Matrix<double,-1,-1,0,-1,-1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
;	COMDAT ??$copyPacketByOuterInner@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$00$0A@@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 8
outer$ = 16
inner$ = 24
other$ = 32
??$copyPacketByOuterInner@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$00$0A@@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@1@@Z PROC ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,1>::copyPacketByOuterInner<Eigen::Matrix<double,-1,-1,0,-1,-1>,1,0>, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 217  :                (this->m_data + (col * colStride() + row * rowStride()), val);

	mov	rax, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	mov	r10, QWORD PTR [rcx+32]
	mov	rcx, QWORD PTR [r9+8]
	imul	r10, rdx
	imul	rcx, rdx
	add	r10, r8
	add	rcx, r8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 217  :                (this->m_data + (col * colStride() + row * rowStride()), val);

	lea	r11, QWORD PTR [rax+r10*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 184  :                                    : rowId + colId * m_storage.rows()));

	mov	rax, QWORD PTR [r9]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 238  :   template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm_loadu_pd(from); }

	movups	xmm0, XMMWORD PTR [rax+rcx*8]

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [r11], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 549  :     }

	ret	0
??$copyPacketByOuterInner@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$00$0A@@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@1@@Z ENDP ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,1>::copyPacketByOuterInner<Eigen::Matrix<double,-1,-1,0,-1,-1>,1,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
;	COMDAT ??$copyCoeffByOuterInner@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 8
outer$ = 16
inner$ = 24
other$ = 32
??$copyCoeffByOuterInner@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@1@@Z PROC ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,1>::copyCoeffByOuterInner<Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> > >, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h

; 74   :     nestedExpression() const { return m_matrix; }

	mov	rax, QWORD PTR [r9]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 480  :       derived().coeffRef(row, col) = other.derived().coeff(row, col);

	mov	r9, QWORD PTR [rcx+32]
	mov	rcx, QWORD PTR [rcx]
	imul	r9, rdx
	mov	r10, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax]
	add	r9, r8
	imul	r10, r8
	add	r10, rdx
	mov	rax, QWORD PTR [rax+r10*8]
	mov	QWORD PTR [rcx+r9*8], rax

; 501  :     {
; 502  :       const Index row = rowIndexByOuterInner(outer,inner);
; 503  :       const Index col = colIndexByOuterInner(outer,inner);
; 504  :       // derived() is important here: copyCoeff() may be reimplemented in Derived!
; 505  :       derived().copyCoeff(row, col, other);
; 506  :     }

	ret	0
??$copyCoeffByOuterInner@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@1@@Z ENDP ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,1>::copyCoeffByOuterInner<Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
;	COMDAT ?rowIndexByOuterInner@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEBA_J_J0@Z
_TEXT	SEGMENT
this$dead$ = 8
outer$dead$ = 16
inner$ = 24
?rowIndexByOuterInner@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEBA_J_J0@Z PROC ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,0>::rowIndexByOuterInner, COMDAT

; 66   :       return int(Derived::RowsAtCompileTime) == 1 ? 0
; 67   :           : int(Derived::ColsAtCompileTime) == 1 ? inner
; 68   :           : int(Derived::Flags)&RowMajorBit ? outer
; 69   :           : inner;

	mov	rax, r8

; 70   :     }

	ret	0
?rowIndexByOuterInner@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEBA_J_J0@Z ENDP ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,0>::rowIndexByOuterInner
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
;	COMDAT ?colIndexByOuterInner@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEBA_J_J0@Z
_TEXT	SEGMENT
this$dead$ = 8
outer$ = 16
inner$dead$ = 24
?colIndexByOuterInner@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEBA_J_J0@Z PROC ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,0>::colIndexByOuterInner, COMDAT

; 74   :       return int(Derived::ColsAtCompileTime) == 1 ? 0
; 75   :           : int(Derived::RowsAtCompileTime) == 1 ? inner
; 76   :           : int(Derived::Flags)&RowMajorBit ? inner
; 77   :           : outer;

	mov	rax, rdx

; 78   :     }

	ret	0
?colIndexByOuterInner@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEBA_J_J0@Z ENDP ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,0>::colIndexByOuterInner
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
;	COMDAT ?rowIndexByOuterInner@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEBA_J_J0@Z
_TEXT	SEGMENT
this$dead$ = 8
outer$dead$ = 16
inner$ = 24
?rowIndexByOuterInner@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEBA_J_J0@Z PROC ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,0>::rowIndexByOuterInner, COMDAT

; 66   :       return int(Derived::RowsAtCompileTime) == 1 ? 0
; 67   :           : int(Derived::ColsAtCompileTime) == 1 ? inner
; 68   :           : int(Derived::Flags)&RowMajorBit ? outer
; 69   :           : inner;

	mov	rax, r8

; 70   :     }

	ret	0
?rowIndexByOuterInner@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEBA_J_J0@Z ENDP ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,0>::rowIndexByOuterInner
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
;	COMDAT ?colIndexByOuterInner@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEBA_J_J0@Z
_TEXT	SEGMENT
this$dead$ = 8
outer$ = 16
inner$dead$ = 24
?colIndexByOuterInner@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEBA_J_J0@Z PROC ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,0>::colIndexByOuterInner, COMDAT

; 74   :       return int(Derived::ColsAtCompileTime) == 1 ? 0
; 75   :           : int(Derived::RowsAtCompileTime) == 1 ? inner
; 76   :           : int(Derived::Flags)&RowMajorBit ? inner
; 77   :           : outer;

	mov	rax, rdx

; 78   :     }

	ret	0
?colIndexByOuterInner@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEBA_J_J0@Z ENDP ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,0>::colIndexByOuterInner
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h
;	COMDAT ?rows@?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?rows@?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@QEBA_JXZ PROC ; Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::rows, COMDAT

; 57   :     inline Index rows() const { return m_matrix.rows(); }

	mov	rax, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+8]
	ret	0
?rows@?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@QEBA_JXZ ENDP ; Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::rows
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h
;	COMDAT ?cols@?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$dead$ = 8
?cols@?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@QEBA_JXZ PROC ; Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::cols, COMDAT

; 58   :     inline Index cols() const { return m_matrix.cols(); }

	mov	eax, 1
	ret	0
?cols@?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@QEBA_JXZ ENDP ; Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::cols
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h
;	COMDAT ?run@?$checkTransposeAliasing_impl@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$0A@@internal@Eigen@@SAXAEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
__formal$dead$ = 16
?run@?$checkTransposeAliasing_impl@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$0A@@internal@Eigen@@SAXAEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z PROC ; Eigen::internal::checkTransposeAliasing_impl<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,Eigen::Matrix<double,-1,1,0,-1,1>,0>::run, COMDAT

; 404  :     }

	ret	0
?run@?$checkTransposeAliasing_impl@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$0A@@internal@Eigen@@SAXAEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z ENDP ; Eigen::internal::checkTransposeAliasing_impl<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,Eigen::Matrix<double,-1,1,0,-1,1>,0>::run
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h
;	COMDAT ?run@?$checkTransposeAliasing_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$0A@@internal@Eigen@@SAXAEBV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
__formal$dead$ = 16
?run@?$checkTransposeAliasing_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$0A@@internal@Eigen@@SAXAEBV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@Z PROC ; Eigen::internal::checkTransposeAliasing_impl<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,Eigen::Matrix<double,-1,-1,0,-1,-1>,0>::run, COMDAT

; 404  :     }

	ret	0
?run@?$checkTransposeAliasing_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@$0A@@internal@Eigen@@SAXAEBV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@@Z ENDP ; Eigen::internal::checkTransposeAliasing_impl<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,Eigen::Matrix<double,-1,-1,0,-1,-1>,0>::run
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h
;	COMDAT ?run@?$checkTransposeAliasing_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@$00@internal@Eigen@@SAXAEBV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Z
_TEXT	SEGMENT
dst$ = 8
other$ = 16
?run@?$checkTransposeAliasing_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@$00@internal@Eigen@@SAXAEBV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Z PROC ; Eigen::internal::checkTransposeAliasing_impl<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> >,1>::run, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 199  :     inline const Scalar* data() const { return this->m_data; }

	mov	r8, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h

; 361  :     return (bool(blas_traits<OtherDerived>::IsTransposed) != DestIsTransposed) && (dest!=0 && dest==(const Scalar*)extract_data(src));

	test	r8, r8
	je	SHORT $LN4@run
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 262  :     inline T *data() { return m_data; }

	mov	rax, QWORD PTR [rdx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h

; 361  :     return (bool(blas_traits<OtherDerived>::IsTransposed) != DestIsTransposed) && (dest!=0 && dest==(const Scalar*)extract_data(src));

	cmp	r8, QWORD PTR [rax]
	jne	SHORT $LN4@run

; 390  :         eigen_assert((!check_transpose_aliasing_run_time_selector

	lea	rdx, OFFSET FLAT:??_C@_1LE@ODIDILMJ@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1CCG@OOFKGNBC@?$AA?$CI?$AA?$CB?$AAc?$AAh?$AAe?$AAc?$AAk?$AA_?$AAt?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AA_?$AAa?$AAl?$AAi?$AAa?$AAs?$AAi?$AAn?$AAg?$AA_?$AAr?$AAu?$AAn?$AA_?$AAt@
	mov	r8d, 394				; 0000018aH
	rex_jmp	QWORD PTR __imp__wassert
$LN4@run:

; 391  :                       <typename Derived::Scalar,blas_traits<Derived>::IsTransposed,OtherDerived>
; 392  :                       ::run(extract_data(dst), other))
; 393  :           && "aliasing detected during transposition, use transposeInPlace() "
; 394  :              "or evaluate the rhs into a temporary using .eval()");
; 395  : 
; 396  :     }

	ret	0
?run@?$checkTransposeAliasing_impl@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@$00@internal@Eigen@@SAXAEBV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Z ENDP ; Eigen::internal::checkTransposeAliasing_impl<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> >,1>::run
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densebase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
;	COMDAT ?run@?$assign_impl@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@3@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Z
_TEXT	SEGMENT
$T1 = 0
size$ = 8
__$ArrayPad$ = 16
dst$ = 64
src$ = 72
?run@?$assign_impl@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@3@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Z PROC ; Eigen::internal::assign_impl<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,4,0,0>::run, COMDAT

; 441  :   {

$LN710:
	push	rdi
	push	r14
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	QWORD PTR [rsp+80], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 313  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rbx, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 441  :   {

	mov	r10, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];

	mov	rdx, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densebase.h

; 210  :            : int(IsRowMajor) ? this->cols() : this->rows();

	mov	rdi, QWORD PTR [rbx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 441  :   {

	mov	r14, rcx

; 442  :     typedef packet_traits<typename Derived1::Scalar> PacketTraits;
; 443  :     enum {
; 444  :       packetSize = PacketTraits::size,
; 445  :       alignable = PacketTraits::AlignedOnScalar,
; 446  :       dstAlignment = alignable ? Aligned : int(assign_traits<Derived1,Derived2>::DstIsAligned) ,
; 447  :       srcAlignment = assign_traits<Derived1,Derived2>::JointAlignment
; 448  :     };
; 449  :     const Index packetAlignedMask = packetSize - 1;
; 450  :     const Index innerSize = dst.innerSize();
; 451  :     const Index outerSize = dst.outerSize();
; 452  :     const Index alignedStep = alignable ? (packetSize - dst.outerStride() % packetSize) & packetAlignedMask : 0;
; 453  :     Index alignedStart = ((!alignable) || assign_traits<Derived1,Derived2>::DstIsAligned) ? 0
; 454  :                        : internal::first_aligned(&dst.coeffRef(0,0), innerSize);

	mov	QWORD PTR size$[rsp], rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 478  :   else if(size_t(array) & (sizeof(Scalar)-1))

	test	dl, 7
	je	SHORT $LN154@run

; 479  :   {
; 480  :     // There is vectorization for this scalar type, but the array is not aligned to the size of a single scalar.
; 481  :     // Consequently, no element of the array is well aligned.
; 482  :     return size;

	mov	r9, rdi
	jmp	SHORT $LN153@run
$LN154@run:

; 487  :                            & PacketAlignedMask, size);

	shr	rdx, 3
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 4121 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	rax, QWORD PTR size$[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 487  :                            & PacketAlignedMask, size);

	neg	rdx
	and	edx, 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 4121 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	rdi, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 487  :                            & PacketAlignedMask, size);

	mov	QWORD PTR $T1[rsp], rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 4121 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovge	rax, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 487  :                            & PacketAlignedMask, size);

	mov	r9, QWORD PTR [rax]
$LN153@run:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 458  :       const Index alignedEnd = alignedStart + ((innerSize-alignedStart) & ~packetAlignedMask);

	mov	r8, rdi

; 460  :       for(Index inner = 0; inner<alignedStart ; ++inner)

	xor	edx, edx
	sub	r8, r9
	and	r8, -2
	add	r8, r9
	cmp	r9, 4
	jl	$LC702@run

; 458  :       const Index alignedEnd = alignedStart + ((innerSize-alignedStart) & ~packetAlignedMask);

	mov	QWORD PTR [rsp+32], rsi
	lea	rsi, QWORD PTR [r9-4]
	lea	r11d, QWORD PTR [rdx+16]
	shr	rsi, 2
	inc	rsi
	lea	rdx, QWORD PTR [rsi*4]

; 460  :       for(Index inner = 0; inner<alignedStart ; ++inner)

$LL703@run:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h

; 26   :   EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& b) const { return a + b; }

	mov	rax, QWORD PTR [r10]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];

	mov	rcx, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h

; 94   :       tmp = m_functor(tmp, _other.coeff(row,col));

	add	r11, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h

; 26   :   EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& b) const { return a + b; }

	movsdx	xmm0, QWORD PTR [r11+rax-48]
	addsd	xmm0, QWORD PTR [r11+rcx-48]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h

; 94   :       tmp = m_functor(tmp, _other.coeff(row,col));

	movsdx	QWORD PTR [r11+rcx-48], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h

; 26   :   EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& b) const { return a + b; }

	mov	rax, QWORD PTR [r10]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];

	mov	rcx, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h

; 26   :   EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& b) const { return a + b; }

	movsdx	xmm0, QWORD PTR [r11+rax-40]
	addsd	xmm0, QWORD PTR [r11+rcx-40]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h

; 94   :       tmp = m_functor(tmp, _other.coeff(row,col));

	movsdx	QWORD PTR [r11+rcx-40], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h

; 26   :   EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& b) const { return a + b; }

	mov	rax, QWORD PTR [r10]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];

	mov	rcx, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h

; 26   :   EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& b) const { return a + b; }

	movsdx	xmm0, QWORD PTR [r11+rax-32]
	addsd	xmm0, QWORD PTR [r11+rcx-32]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h

; 94   :       tmp = m_functor(tmp, _other.coeff(row,col));

	movsdx	QWORD PTR [r11+rcx-32], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h

; 26   :   EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& b) const { return a + b; }

	mov	rax, QWORD PTR [r10]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];

	mov	rcx, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h

; 26   :   EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& b) const { return a + b; }

	movsdx	xmm0, QWORD PTR [r11+rax-24]
	addsd	xmm0, QWORD PTR [r11+rcx-24]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h

; 94   :       tmp = m_functor(tmp, _other.coeff(row,col));

	movsdx	QWORD PTR [r11+rcx-24], xmm0
	dec	rsi
	jne	SHORT $LL703@run
	mov	rsi, QWORD PTR [rsp+32]
$LC702@run:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 460  :       for(Index inner = 0; inner<alignedStart ; ++inner)

	cmp	rdx, r9
	jge	SHORT $LN701@run
$LC9@run:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h

; 26   :   EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& b) const { return a + b; }

	mov	rax, QWORD PTR [r10]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 460  :       for(Index inner = 0; inner<alignedStart ; ++inner)

	mov	rcx, QWORD PTR [rbx]
	inc	rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h

; 26   :   EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& b) const { return a + b; }

	movsdx	xmm0, QWORD PTR [rax+rdx*8-8]
	addsd	xmm0, QWORD PTR [rcx+rdx*8-8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h

; 94   :       tmp = m_functor(tmp, _other.coeff(row,col));

	movsdx	QWORD PTR [rcx+rdx*8-8], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 460  :       for(Index inner = 0; inner<alignedStart ; ++inner)

	cmp	rdx, r9
	jl	SHORT $LC9@run
$LN701@run:
	mov	rbx, QWORD PTR [rsp+80]

; 464  :       for(Index inner = alignedStart; inner<alignedEnd; inner+=packetSize)

	cmp	r9, r8
	jge	SHORT $LN4@run
	npad	6
$LL6@run:
	mov	rax, QWORD PTR [r10]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h

; 113  :         m_functor.packetOp(m_matrix.template packet<StoreMode>(row, col),_other.template packet<LoadMode>(row, col)) );

	mov	rcx, QWORD PTR [r14]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 464  :       for(Index inner = alignedStart; inner<alignedEnd; inner+=packetSize)

	add	r9, 2
	mov	rdx, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 238  :   template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm_loadu_pd(from); }

	movups	xmm0, XMMWORD PTR [rax+r9*8-16]

; 123  : template<> EIGEN_STRONG_INLINE Packet2d padd<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_add_pd(a,b); }

	addpd	xmm0, XMMWORD PTR [rdx+r9*8-16]

; 239  :   template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int*    from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm_loadu_si128(reinterpret_cast<const Packet4i*>(from)); }
; 240  : #else
; 241  : // Fast unaligned loads. Note that here we cannot directly use intrinsics: this would
; 242  : // require pointer casting to incompatible pointer types and leads to invalid code
; 243  : // because of the strict aliasing rule. The "dummy" stuff are required to enforce
; 244  : // a correct instruction dependency.
; 245  : // TODO: do the same for MSVC (ICC is compatible)
; 246  : // NOTE: with the code below, MSVC's compiler crashes!
; 247  : 
; 248  : #if defined(__GNUC__) && defined(__i386__)
; 249  :   // bug 195: gcc/i386 emits weird x87 fldl/fstpl instructions for _mm_load_sd
; 250  :   #define EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS 1
; 251  : #elif defined(__clang__)
; 252  :   // bug 201: Segfaults in __mm_loadh_pd with clang 2.8
; 253  :   #define EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS 1
; 254  : #else
; 255  :   #define EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS 0
; 256  : #endif
; 257  : 
; 258  : template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float* from)
; 259  : {
; 260  :   EIGEN_DEBUG_UNALIGNED_LOAD
; 261  : #if EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS
; 262  :   return _mm_loadu_ps(from);
; 263  : #else
; 264  :   __m128d res;
; 265  :   res =  _mm_load_sd((const double*)(from)) ;
; 266  :   res =  _mm_loadh_pd(res, (const double*)(from+2)) ;
; 267  :   return _mm_castpd_ps(res);
; 268  : #endif
; 269  : }
; 270  : template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from)
; 271  : {
; 272  :   EIGEN_DEBUG_UNALIGNED_LOAD
; 273  : #if EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS
; 274  :   return _mm_loadu_pd(from);
; 275  : #else
; 276  :   __m128d res;
; 277  :   res = _mm_load_sd(from) ;
; 278  :   res = _mm_loadh_pd(res,from+1);
; 279  :   return res;
; 280  : #endif
; 281  : }
; 282  : template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int* from)
; 283  : {
; 284  :   EIGEN_DEBUG_UNALIGNED_LOAD
; 285  : #if EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS
; 286  :   return _mm_loadu_si128(reinterpret_cast<const Packet4i*>(from));
; 287  : #else
; 288  :   __m128d res;
; 289  :   res =  _mm_load_sd((const double*)(from)) ;
; 290  :   res =  _mm_loadh_pd(res, (const double*)(from+2)) ;
; 291  :   return _mm_castpd_si128(res);
; 292  : #endif
; 293  : }
; 294  : #endif
; 295  : 
; 296  : template<> EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float*   from)
; 297  : {
; 298  :   return vec4f_swizzle1(_mm_castpd_ps(_mm_load_sd(reinterpret_cast<const double*>(from))), 0, 0, 1, 1);
; 299  : }
; 300  : template<> EIGEN_STRONG_INLINE Packet2d ploaddup<Packet2d>(const double*  from)
; 301  : { return pset1<Packet2d>(from[0]); }
; 302  : template<> EIGEN_STRONG_INLINE Packet4i ploaddup<Packet4i>(const int*     from)
; 303  : {
; 304  :   Packet4i tmp;
; 305  :   tmp = _mm_loadl_epi64(reinterpret_cast<const Packet4i*>(from));
; 306  :   return vec4i_swizzle1(tmp, 0, 0, 1, 1);
; 307  : }
; 308  : 
; 309  : template<> EIGEN_STRONG_INLINE void pstore<float>(float*   to, const Packet4f& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_ps(to, from); }
; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [rdx+r9*8-16], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 464  :       for(Index inner = alignedStart; inner<alignedEnd; inner+=packetSize)

	cmp	r9, r8
	jl	SHORT $LL6@run
$LN4@run:

; 468  :       for(Index inner = alignedEnd; inner<innerSize ; ++inner)

	cmp	r8, rdi
	jge	SHORT $LN1@run
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h

; 93   :       Scalar& tmp = m_matrix.coeffRef(row,col);

	mov	rdx, QWORD PTR [r14]
	npad	3
$LL3@run:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h

; 26   :   EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& b) const { return a + b; }

	mov	rax, QWORD PTR [r10]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 468  :       for(Index inner = alignedEnd; inner<innerSize ; ++inner)

	mov	rcx, QWORD PTR [rdx]
	inc	r8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h

; 26   :   EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& b) const { return a + b; }

	movsdx	xmm0, QWORD PTR [rax+r8*8-8]
	addsd	xmm0, QWORD PTR [rcx+r8*8-8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h

; 94   :       tmp = m_functor(tmp, _other.coeff(row,col));

	movsdx	QWORD PTR [rcx+r8*8-8], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 468  :       for(Index inner = alignedEnd; inner<innerSize ; ++inner)

	cmp	r8, rdi
	jl	SHORT $LL3@run
$LN1@run:

; 469  :         dst.copyCoeffByOuterInner(outer, inner, src);
; 470  : 
; 471  :       alignedStart = std::min<Index>((alignedStart+alignedStep)%packetSize, innerSize);
; 472  :     }
; 473  :   }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 40					; 00000028H
	pop	r14
	pop	rdi
	ret	0
?run@?$assign_impl@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@$03$0A@$0A@@internal@Eigen@@SAXAEAV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@3@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Z ENDP ; Eigen::internal::assign_impl<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,4,0,0>::run
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h
;	COMDAT ?outerStride@?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?outerStride@?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@QEBA_JXZ PROC ; Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::outerStride, COMDAT

; 59   :     inline Index outerStride() const { return m_matrix.outerStride(); }

	mov	rax, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+8]
	ret	0
?outerStride@?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@QEBA_JXZ ENDP ; Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::outerStride
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h
;	COMDAT ?coeffRef@?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@QEAAAEAN_J0@Z
_TEXT	SEGMENT
this$ = 8
row$dead$ = 16
col$dead$ = 24
?coeffRef@?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@QEAAAEAN_J0@Z PROC ; Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::coeffRef, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 39   :   { return *static_cast<Derived*>(const_cast<EigenBase*>(this)); }

	mov	rax, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h

; 68   :       return m_matrix.const_cast_derived().coeffRef(row, col);

	mov	rax, QWORD PTR [rax]

; 69   :     }

	ret	0
?coeffRef@?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@QEAAAEAN_J0@Z ENDP ; Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::coeffRef
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densebase.h
;	COMDAT ?outerSize@?$DenseBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$dead$ = 8
?outerSize@?$DenseBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@QEBA_JXZ PROC ; Eigen::DenseBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> > >::outerSize, COMDAT

; 198  :       return IsVectorAtCompileTime ? 1
; 199  :            : int(IsRowMajor) ? this->rows() : this->cols();

	mov	eax, 1

; 200  :     }

	ret	0
?outerSize@?$DenseBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@QEBA_JXZ ENDP ; Eigen::DenseBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> > >::outerSize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densebase.h
;	COMDAT ?innerSize@?$DenseBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?innerSize@?$DenseBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@QEBA_JXZ PROC ; Eigen::DenseBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> > >::innerSize, COMDAT

; 209  :       return IsVectorAtCompileTime ? this->size()
; 210  :            : int(IsRowMajor) ? this->cols() : this->rows();

	mov	rax, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+8]

; 211  :     }

	ret	0
?innerSize@?$DenseBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@QEBA_JXZ ENDP ; Eigen::DenseBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> > >::innerSize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h
;	COMDAT ?run@?$check_transpose_aliasing_run_time_selector@N$0A@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@SA_NPEBNAEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Z
_TEXT	SEGMENT
dest$ = 8
src$ = 16
?run@?$check_transpose_aliasing_run_time_selector@N$0A@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@SA_NPEBNAEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Z PROC ; Eigen::internal::check_transpose_aliasing_run_time_selector<double,0,Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> > >::run, COMDAT

; 361  :     return (bool(blas_traits<OtherDerived>::IsTransposed) != DestIsTransposed) && (dest!=0 && dest==(const Scalar*)extract_data(src));

	test	rcx, rcx
	je	SHORT $LN3@run
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 262  :     inline T *data() { return m_data; }

	mov	rax, QWORD PTR [rdx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h

; 361  :     return (bool(blas_traits<OtherDerived>::IsTransposed) != DestIsTransposed) && (dest!=0 && dest==(const Scalar*)extract_data(src));

	cmp	rcx, QWORD PTR [rax]
	jne	SHORT $LN3@run
	mov	al, 1

; 362  :   }

	ret	0
$LN3@run:

; 361  :     return (bool(blas_traits<OtherDerived>::IsTransposed) != DestIsTransposed) && (dest!=0 && dest==(const Scalar*)extract_data(src));

	xor	al, al

; 362  :   }

	ret	0
?run@?$check_transpose_aliasing_run_time_selector@N$0A@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@SA_NPEBNAEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Z ENDP ; Eigen::internal::check_transpose_aliasing_run_time_selector<double,0,Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> > >::run
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
;	COMDAT ?rows@?$EigenBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?rows@?$EigenBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@QEBA_JXZ PROC ; Eigen::EigenBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> > >::rows, COMDAT

; 44   :   inline Index rows() const { return derived().rows(); }

	mov	rax, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+8]
	ret	0
?rows@?$EigenBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@QEBA_JXZ ENDP ; Eigen::EigenBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> > >::rows
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
;	COMDAT ?cols@?$EigenBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$dead$ = 8
?cols@?$EigenBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@QEBA_JXZ PROC ; Eigen::EigenBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> > >::cols, COMDAT

; 46   :   inline Index cols() const { return derived().cols(); }

	mov	eax, 1
	ret	0
?cols@?$EigenBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@QEBA_JXZ ENDP ; Eigen::EigenBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> > >::cols
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
;	COMDAT ?size@?$EigenBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?size@?$EigenBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@QEBA_JXZ PROC ; Eigen::EigenBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> > >::size, COMDAT

; 49   :   inline Index size() const { return rows() * cols(); }

	mov	rax, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+8]
	ret	0
?size@?$EigenBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@QEBA_JXZ ENDP ; Eigen::EigenBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> > >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
;	COMDAT ?derived@?$EigenBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@QEBAAEBV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@2@XZ
_TEXT	SEGMENT
this$ = 8
?derived@?$EigenBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@QEBAAEBV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@2@XZ PROC ; Eigen::EigenBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> > >::derived, COMDAT

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	mov	rax, rcx
	ret	0
?derived@?$EigenBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@QEBAAEBV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@2@XZ ENDP ; Eigen::EigenBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> > >::derived
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
;	COMDAT ??$_resize_to_match@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@IEAAXAEBU?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 48
other$ = 56
??$_resize_to_match@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@IEAAXAEBU?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z PROC ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,1,0,-1,1> >::_resize_to_match<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const >,4> >, COMDAT

; 569  :     EIGEN_STRONG_INLINE void _resize_to_match(const EigenBase<OtherDerived>& other)

$LN215:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rax, QWORD PTR [rdx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 569  :     EIGEN_STRONG_INLINE void _resize_to_match(const EigenBase<OtherDerived>& other)

	mov	rdi, rcx

; 44   :                : (rows > max_index / cols);

	mov	rsi, 9223372036854775807		; 7fffffffffffffffH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rbx, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	test	rbx, rbx
	je	SHORT $LN210@resize_to_
	cmp	rbx, rsi
	setg	al

; 45   :     if (error)

	test	al, al
	jne	SHORT $LN212@resize_to_

; 47   :   }
; 48   : };
; 49   : 
; 50   : template <typename Derived,
; 51   :           typename OtherDerived = Derived,
; 52   :           bool IsVector = bool(Derived::IsVectorAtCompileTime) && bool(OtherDerived::IsVectorAtCompileTime)>
; 53   : struct conservative_resize_like_impl;
; 54   : 
; 55   : template<typename MatrixTypeA, typename MatrixTypeB, bool SwapPointers> struct matrix_swap_impl;
; 56   : 
; 57   : } // end namespace internal
; 58   : 
; 59   : /** \class PlainObjectBase
; 60   :   * \brief %Dense storage base class for matrices and arrays.
; 61   :   *
; 62   :   * This class can be extended with the help of the plugin mechanism described on the page
; 63   :   * \ref TopicCustomizingEigen by defining the preprocessor symbol \c EIGEN_PLAINOBJECTBASE_PLUGIN.
; 64   :   *
; 65   :   * \sa \ref TopicClassHierarchy
; 66   :   */
; 67   : #ifdef EIGEN_PARSED_BY_DOXYGEN
; 68   : namespace internal {
; 69   : 
; 70   : // this is a warkaround to doxygen not being able to understand the inheritence logic
; 71   : // when it is hidden by the dense_xpr_base helper struct.
; 72   : template<typename Derived> struct dense_xpr_base_dispatcher_for_doxygen;// : public MatrixBase<Derived> {};
; 73   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 74   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 75   : struct dense_xpr_base_dispatcher_for_doxygen<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 76   :     : public MatrixBase<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 77   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 78   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 79   : struct dense_xpr_base_dispatcher_for_doxygen<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 80   :     : public ArrayBase<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 81   : 
; 82   : } // namespace internal
; 83   : 
; 84   : template<typename Derived>
; 85   : class PlainObjectBase : public internal::dense_xpr_base_dispatcher_for_doxygen<Derived>
; 86   : #else
; 87   : template<typename Derived>
; 88   : class PlainObjectBase : public internal::dense_xpr_base<Derived>::type
; 89   : #endif
; 90   : {
; 91   :   public:
; 92   :     enum { Options = internal::traits<Derived>::Options };
; 93   :     typedef typename internal::dense_xpr_base<Derived>::type Base;
; 94   : 
; 95   :     typedef typename internal::traits<Derived>::StorageKind StorageKind;
; 96   :     typedef typename internal::traits<Derived>::Index Index;
; 97   :     typedef typename internal::traits<Derived>::Scalar Scalar;
; 98   :     typedef typename internal::packet_traits<Scalar>::type PacketScalar;
; 99   :     typedef typename NumTraits<Scalar>::Real RealScalar;
; 100  :     typedef Derived DenseType;
; 101  : 
; 102  :     using Base::RowsAtCompileTime;
; 103  :     using Base::ColsAtCompileTime;
; 104  :     using Base::SizeAtCompileTime;
; 105  :     using Base::MaxRowsAtCompileTime;
; 106  :     using Base::MaxColsAtCompileTime;
; 107  :     using Base::MaxSizeAtCompileTime;
; 108  :     using Base::IsVectorAtCompileTime;
; 109  :     using Base::Flags;
; 110  : 
; 111  :     template<typename PlainObjectType, int MapOptions, typename StrideType> friend class Eigen::Map;
; 112  :     friend  class Eigen::Map<Derived, Unaligned>;
; 113  :     typedef Eigen::Map<Derived, Unaligned>  MapType;
; 114  :     friend  class Eigen::Map<const Derived, Unaligned>;
; 115  :     typedef const Eigen::Map<const Derived, Unaligned> ConstMapType;
; 116  :     friend  class Eigen::Map<Derived, Aligned>;
; 117  :     typedef Eigen::Map<Derived, Aligned> AlignedMapType;
; 118  :     friend  class Eigen::Map<const Derived, Aligned>;
; 119  :     typedef const Eigen::Map<const Derived, Aligned> ConstAlignedMapType;
; 120  :     template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };
; 121  :     template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };
; 122  :     template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, Aligned, StrideType> type; };
; 123  :     template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, Aligned, StrideType> type; };
; 124  : 
; 125  :   protected:
; 126  :     DenseStorage<Scalar, Base::MaxSizeAtCompileTime, Base::RowsAtCompileTime, Base::ColsAtCompileTime, Options> m_storage;
; 127  : 
; 128  :   public:
; 129  :     enum { NeedsToAlign = SizeAtCompileTime != Dynamic && (internal::traits<Derived>::Flags & AlignedBit) != 0 };
; 130  :     EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(NeedsToAlign)
; 131  : 
; 132  :     Base& base() { return *static_cast<Base*>(this); }
; 133  :     const Base& base() const { return *static_cast<const Base*>(this); }
; 134  : 
; 135  :     EIGEN_STRONG_INLINE Index rows() const { return m_storage.rows(); }
; 136  :     EIGEN_STRONG_INLINE Index cols() const { return m_storage.cols(); }
; 137  : 
; 138  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index rowId, Index colId) const
; 139  :     {
; 140  :       if(Flags & RowMajorBit)
; 141  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 142  :       else // column-major
; 143  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 144  :     }
; 145  : 
; 146  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index index) const
; 147  :     {
; 148  :       return m_storage.data()[index];
; 149  :     }
; 150  : 
; 151  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index rowId, Index colId)
; 152  :     {
; 153  :       if(Flags & RowMajorBit)
; 154  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 155  :       else // column-major
; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 157  :     }
; 158  : 
; 159  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
; 160  :     {
; 161  :       return m_storage.data()[index];
; 162  :     }
; 163  : 
; 164  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
; 165  :     {
; 166  :       if(Flags & RowMajorBit)
; 167  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 168  :       else // column-major
; 169  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 170  :     }
; 171  : 
; 172  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
; 173  :     {
; 174  :       return m_storage.data()[index];
; 175  :     }
; 176  : 
; 177  :     /** \internal */
; 178  :     template<int LoadMode>
; 179  :     EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const
; 180  :     {
; 181  :       return internal::ploadt<PacketScalar, LoadMode>
; 182  :                (m_storage.data() + (Flags & RowMajorBit
; 183  :                                    ? colId + rowId * m_storage.cols()
; 184  :                                    : rowId + colId * m_storage.rows()));
; 185  :     }
; 186  : 
; 187  :     /** \internal */
; 188  :     template<int LoadMode>
; 189  :     EIGEN_STRONG_INLINE PacketScalar packet(Index index) const
; 190  :     {
; 191  :       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);
; 192  :     }
; 193  : 
; 194  :     /** \internal */
; 195  :     template<int StoreMode>
; 196  :     EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)
; 197  :     {
; 198  :       internal::pstoret<Scalar, PacketScalar, StoreMode>
; 199  :               (m_storage.data() + (Flags & RowMajorBit
; 200  :                                    ? colId + rowId * m_storage.cols()
; 201  :                                    : rowId + colId * m_storage.rows()), val);
; 202  :     }
; 203  : 
; 204  :     /** \internal */
; 205  :     template<int StoreMode>
; 206  :     EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
; 207  :     {
; 208  :       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
; 209  :     }
; 210  : 
; 211  :     /** \returns a const pointer to the data array of this matrix */
; 212  :     EIGEN_STRONG_INLINE const Scalar *data() const
; 213  :     { return m_storage.data(); }
; 214  : 
; 215  :     /** \returns a pointer to the data array of this matrix */
; 216  :     EIGEN_STRONG_INLINE Scalar *data()
; 217  :     { return m_storage.data(); }
; 218  : 
; 219  :     /** Resizes \c *this to a \a rows x \a cols matrix.
; 220  :       *
; 221  :       * This method is intended for dynamic-size matrices, although it is legal to call it on any
; 222  :       * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
; 223  :       * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
; 224  :       *
; 225  :       * If the current number of coefficients of \c *this exactly matches the
; 226  :       * product \a rows * \a cols, then no memory allocation is performed and
; 227  :       * the current values are left unchanged. In all other cases, including
; 228  :       * shrinking, the data is reallocated and all previous values are lost.
; 229  :       *
; 230  :       * Example: \include Matrix_resize_int_int.cpp
; 231  :       * Output: \verbinclude Matrix_resize_int_int.out
; 232  :       *
; 233  :       * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
; 234  :       */
; 235  :     EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)
; 236  :     {
; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rbx, rbx
$LN210@resize_to_:
	jns	SHORT $LN128@resize_to_
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	mov	r8d, 241				; 000000f1H
	call	QWORD PTR __imp__wassert
$LN128@resize_to_:

; 44   :                : (rows > max_index / cols);

	test	rbx, rbx
	je	SHORT $LN135@resize_to_
	cmp	rbx, rsi
	setg	al

; 45   :     if (error)

	test	al, al
	jne	SHORT $LN214@resize_to_
$LN135@resize_to_:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 322  :       if(size != m_rows*_Cols)

	cmp	rbx, QWORD PTR [rdi+8]
	je	SHORT $LN140@resize_to_
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR [rdi]
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 325  :         if (size)

	test	rbx, rbx
	je	SHORT $LN141@resize_to_

; 326  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

	mov	rcx, rbx
	call	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
	mov	QWORD PTR [rdi], rax

; 327  :         else

	jmp	SHORT $LN140@resize_to_
$LN141@resize_to_:

; 328  :           m_data = 0;

	mov	QWORD PTR [rdi], 0
$LN140@resize_to_:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 579  :     }

	mov	rsi, QWORD PTR [rsp+56]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 331  :       m_rows = nbRows;

	mov	QWORD PTR [rdi+8], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 579  :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN212@resize_to_:

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN214@resize_to_:
	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN209@resize_to_:
??$_resize_to_match@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@IEAAXAEBU?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z ENDP ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,1,0,-1,1> >::_resize_to_match<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const >,4> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h
;	COMDAT ??$lazyAssign@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@?$MatrixBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@1@@Z
_TEXT	SEGMENT
this$ = 48
other$ = 56
??$lazyAssign@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@?$MatrixBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@1@@Z PROC ; Eigen::MatrixBase<Eigen::Matrix<double,-1,1,0,-1,1> >::lazyAssign<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const > >, COMDAT

; 283  : {

$LN10:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rax, rdx
	mov	rbx, rcx

; 284  :   other.derived().evalTo(derived());

	mov	rdx, rcx
	mov	rcx, rax
	call	??$evalTo@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEBAXAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@@Z ; Eigen::ProductBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const > >::evalTo<Eigen::Matrix<double,-1,1,0,-1,1> >

; 285  :   return derived();

	mov	rax, rbx

; 286  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$lazyAssign@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@?$MatrixBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@1@@Z ENDP ; Eigen::MatrixBase<Eigen::Matrix<double,-1,1,0,-1,1> >::lazyAssign<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
;	COMDAT ??$_resize_to_match@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@IEAAXAEBU?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 48
other$ = 56
??$_resize_to_match@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@IEAAXAEBU?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z PROC ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,1,0,-1,1> >::_resize_to_match<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4> >, COMDAT

; 569  :     EIGEN_STRONG_INLINE void _resize_to_match(const EigenBase<OtherDerived>& other)

$LN215:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rax, QWORD PTR [rdx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 569  :     EIGEN_STRONG_INLINE void _resize_to_match(const EigenBase<OtherDerived>& other)

	mov	rdi, rcx

; 44   :                : (rows > max_index / cols);

	mov	rsi, 9223372036854775807		; 7fffffffffffffffH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rbx, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	test	rbx, rbx
	je	SHORT $LN210@resize_to_
	cmp	rbx, rsi
	setg	al

; 45   :     if (error)

	test	al, al
	jne	SHORT $LN212@resize_to_

; 47   :   }
; 48   : };
; 49   : 
; 50   : template <typename Derived,
; 51   :           typename OtherDerived = Derived,
; 52   :           bool IsVector = bool(Derived::IsVectorAtCompileTime) && bool(OtherDerived::IsVectorAtCompileTime)>
; 53   : struct conservative_resize_like_impl;
; 54   : 
; 55   : template<typename MatrixTypeA, typename MatrixTypeB, bool SwapPointers> struct matrix_swap_impl;
; 56   : 
; 57   : } // end namespace internal
; 58   : 
; 59   : /** \class PlainObjectBase
; 60   :   * \brief %Dense storage base class for matrices and arrays.
; 61   :   *
; 62   :   * This class can be extended with the help of the plugin mechanism described on the page
; 63   :   * \ref TopicCustomizingEigen by defining the preprocessor symbol \c EIGEN_PLAINOBJECTBASE_PLUGIN.
; 64   :   *
; 65   :   * \sa \ref TopicClassHierarchy
; 66   :   */
; 67   : #ifdef EIGEN_PARSED_BY_DOXYGEN
; 68   : namespace internal {
; 69   : 
; 70   : // this is a warkaround to doxygen not being able to understand the inheritence logic
; 71   : // when it is hidden by the dense_xpr_base helper struct.
; 72   : template<typename Derived> struct dense_xpr_base_dispatcher_for_doxygen;// : public MatrixBase<Derived> {};
; 73   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 74   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 75   : struct dense_xpr_base_dispatcher_for_doxygen<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 76   :     : public MatrixBase<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 77   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 78   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 79   : struct dense_xpr_base_dispatcher_for_doxygen<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 80   :     : public ArrayBase<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 81   : 
; 82   : } // namespace internal
; 83   : 
; 84   : template<typename Derived>
; 85   : class PlainObjectBase : public internal::dense_xpr_base_dispatcher_for_doxygen<Derived>
; 86   : #else
; 87   : template<typename Derived>
; 88   : class PlainObjectBase : public internal::dense_xpr_base<Derived>::type
; 89   : #endif
; 90   : {
; 91   :   public:
; 92   :     enum { Options = internal::traits<Derived>::Options };
; 93   :     typedef typename internal::dense_xpr_base<Derived>::type Base;
; 94   : 
; 95   :     typedef typename internal::traits<Derived>::StorageKind StorageKind;
; 96   :     typedef typename internal::traits<Derived>::Index Index;
; 97   :     typedef typename internal::traits<Derived>::Scalar Scalar;
; 98   :     typedef typename internal::packet_traits<Scalar>::type PacketScalar;
; 99   :     typedef typename NumTraits<Scalar>::Real RealScalar;
; 100  :     typedef Derived DenseType;
; 101  : 
; 102  :     using Base::RowsAtCompileTime;
; 103  :     using Base::ColsAtCompileTime;
; 104  :     using Base::SizeAtCompileTime;
; 105  :     using Base::MaxRowsAtCompileTime;
; 106  :     using Base::MaxColsAtCompileTime;
; 107  :     using Base::MaxSizeAtCompileTime;
; 108  :     using Base::IsVectorAtCompileTime;
; 109  :     using Base::Flags;
; 110  : 
; 111  :     template<typename PlainObjectType, int MapOptions, typename StrideType> friend class Eigen::Map;
; 112  :     friend  class Eigen::Map<Derived, Unaligned>;
; 113  :     typedef Eigen::Map<Derived, Unaligned>  MapType;
; 114  :     friend  class Eigen::Map<const Derived, Unaligned>;
; 115  :     typedef const Eigen::Map<const Derived, Unaligned> ConstMapType;
; 116  :     friend  class Eigen::Map<Derived, Aligned>;
; 117  :     typedef Eigen::Map<Derived, Aligned> AlignedMapType;
; 118  :     friend  class Eigen::Map<const Derived, Aligned>;
; 119  :     typedef const Eigen::Map<const Derived, Aligned> ConstAlignedMapType;
; 120  :     template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };
; 121  :     template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };
; 122  :     template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, Aligned, StrideType> type; };
; 123  :     template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, Aligned, StrideType> type; };
; 124  : 
; 125  :   protected:
; 126  :     DenseStorage<Scalar, Base::MaxSizeAtCompileTime, Base::RowsAtCompileTime, Base::ColsAtCompileTime, Options> m_storage;
; 127  : 
; 128  :   public:
; 129  :     enum { NeedsToAlign = SizeAtCompileTime != Dynamic && (internal::traits<Derived>::Flags & AlignedBit) != 0 };
; 130  :     EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(NeedsToAlign)
; 131  : 
; 132  :     Base& base() { return *static_cast<Base*>(this); }
; 133  :     const Base& base() const { return *static_cast<const Base*>(this); }
; 134  : 
; 135  :     EIGEN_STRONG_INLINE Index rows() const { return m_storage.rows(); }
; 136  :     EIGEN_STRONG_INLINE Index cols() const { return m_storage.cols(); }
; 137  : 
; 138  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index rowId, Index colId) const
; 139  :     {
; 140  :       if(Flags & RowMajorBit)
; 141  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 142  :       else // column-major
; 143  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 144  :     }
; 145  : 
; 146  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index index) const
; 147  :     {
; 148  :       return m_storage.data()[index];
; 149  :     }
; 150  : 
; 151  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index rowId, Index colId)
; 152  :     {
; 153  :       if(Flags & RowMajorBit)
; 154  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 155  :       else // column-major
; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 157  :     }
; 158  : 
; 159  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
; 160  :     {
; 161  :       return m_storage.data()[index];
; 162  :     }
; 163  : 
; 164  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
; 165  :     {
; 166  :       if(Flags & RowMajorBit)
; 167  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 168  :       else // column-major
; 169  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 170  :     }
; 171  : 
; 172  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
; 173  :     {
; 174  :       return m_storage.data()[index];
; 175  :     }
; 176  : 
; 177  :     /** \internal */
; 178  :     template<int LoadMode>
; 179  :     EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const
; 180  :     {
; 181  :       return internal::ploadt<PacketScalar, LoadMode>
; 182  :                (m_storage.data() + (Flags & RowMajorBit
; 183  :                                    ? colId + rowId * m_storage.cols()
; 184  :                                    : rowId + colId * m_storage.rows()));
; 185  :     }
; 186  : 
; 187  :     /** \internal */
; 188  :     template<int LoadMode>
; 189  :     EIGEN_STRONG_INLINE PacketScalar packet(Index index) const
; 190  :     {
; 191  :       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);
; 192  :     }
; 193  : 
; 194  :     /** \internal */
; 195  :     template<int StoreMode>
; 196  :     EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)
; 197  :     {
; 198  :       internal::pstoret<Scalar, PacketScalar, StoreMode>
; 199  :               (m_storage.data() + (Flags & RowMajorBit
; 200  :                                    ? colId + rowId * m_storage.cols()
; 201  :                                    : rowId + colId * m_storage.rows()), val);
; 202  :     }
; 203  : 
; 204  :     /** \internal */
; 205  :     template<int StoreMode>
; 206  :     EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
; 207  :     {
; 208  :       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
; 209  :     }
; 210  : 
; 211  :     /** \returns a const pointer to the data array of this matrix */
; 212  :     EIGEN_STRONG_INLINE const Scalar *data() const
; 213  :     { return m_storage.data(); }
; 214  : 
; 215  :     /** \returns a pointer to the data array of this matrix */
; 216  :     EIGEN_STRONG_INLINE Scalar *data()
; 217  :     { return m_storage.data(); }
; 218  : 
; 219  :     /** Resizes \c *this to a \a rows x \a cols matrix.
; 220  :       *
; 221  :       * This method is intended for dynamic-size matrices, although it is legal to call it on any
; 222  :       * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
; 223  :       * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
; 224  :       *
; 225  :       * If the current number of coefficients of \c *this exactly matches the
; 226  :       * product \a rows * \a cols, then no memory allocation is performed and
; 227  :       * the current values are left unchanged. In all other cases, including
; 228  :       * shrinking, the data is reallocated and all previous values are lost.
; 229  :       *
; 230  :       * Example: \include Matrix_resize_int_int.cpp
; 231  :       * Output: \verbinclude Matrix_resize_int_int.out
; 232  :       *
; 233  :       * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
; 234  :       */
; 235  :     EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)
; 236  :     {
; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rbx, rbx
$LN210@resize_to_:
	jns	SHORT $LN128@resize_to_
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	mov	r8d, 241				; 000000f1H
	call	QWORD PTR __imp__wassert
$LN128@resize_to_:

; 44   :                : (rows > max_index / cols);

	test	rbx, rbx
	je	SHORT $LN135@resize_to_
	cmp	rbx, rsi
	setg	al

; 45   :     if (error)

	test	al, al
	jne	SHORT $LN214@resize_to_
$LN135@resize_to_:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 322  :       if(size != m_rows*_Cols)

	cmp	rbx, QWORD PTR [rdi+8]
	je	SHORT $LN140@resize_to_
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR [rdi]
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 325  :         if (size)

	test	rbx, rbx
	je	SHORT $LN141@resize_to_

; 326  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

	mov	rcx, rbx
	call	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
	mov	QWORD PTR [rdi], rax

; 327  :         else

	jmp	SHORT $LN140@resize_to_
$LN141@resize_to_:

; 328  :           m_data = 0;

	mov	QWORD PTR [rdi], 0
$LN140@resize_to_:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 579  :     }

	mov	rsi, QWORD PTR [rsp+56]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 331  :       m_rows = nbRows;

	mov	QWORD PTR [rdi+8], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 579  :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN212@resize_to_:

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN214@resize_to_:
	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN209@resize_to_:
??$_resize_to_match@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@IEAAXAEBU?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z ENDP ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,1,0,-1,1> >::_resize_to_match<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h
;	COMDAT ??$lazyAssign@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@?$MatrixBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@1@@Z
_TEXT	SEGMENT
this$ = 48
other$ = 56
??$lazyAssign@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@?$MatrixBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@1@@Z PROC ; Eigen::MatrixBase<Eigen::Matrix<double,-1,1,0,-1,1> >::lazyAssign<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >, COMDAT

; 283  : {

$LN10:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rax, rdx
	mov	rbx, rcx

; 284  :   other.derived().evalTo(derived());

	mov	rdx, rcx
	mov	rcx, rax
	call	??$evalTo@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEBAXAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@@Z ; Eigen::ProductBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >::evalTo<Eigen::Matrix<double,-1,1,0,-1,1> >

; 285  :   return derived();

	mov	rax, rbx

; 286  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$lazyAssign@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@?$MatrixBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBV?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@1@@Z ENDP ; Eigen::MatrixBase<Eigen::Matrix<double,-1,1,0,-1,1> >::lazyAssign<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
;	COMDAT ??$_resize_to_match@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAAXAEBU?$EigenBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 48
other$ = 56
??$_resize_to_match@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAAXAEBU?$EigenBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z PROC ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::_resize_to_match<Eigen::Matrix<double,-1,1,0,-1,1> >, COMDAT

; 569  :     EIGEN_STRONG_INLINE void _resize_to_match(const EigenBase<OtherDerived>& other)

$LN162:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 313  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rbx, QWORD PTR [rdx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 569  :     EIGEN_STRONG_INLINE void _resize_to_match(const EigenBase<OtherDerived>& other)

	mov	rdi, rcx

; 44   :                : (rows > max_index / cols);

	mov	rsi, 9223372036854775807		; 7fffffffffffffffH
	test	rbx, rbx
	je	SHORT $LN157@resize_to_
	cmp	rbx, rsi
	setg	al

; 45   :     if (error)

	test	al, al
	jne	SHORT $LN159@resize_to_

; 47   :   }
; 48   : };
; 49   : 
; 50   : template <typename Derived,
; 51   :           typename OtherDerived = Derived,
; 52   :           bool IsVector = bool(Derived::IsVectorAtCompileTime) && bool(OtherDerived::IsVectorAtCompileTime)>
; 53   : struct conservative_resize_like_impl;
; 54   : 
; 55   : template<typename MatrixTypeA, typename MatrixTypeB, bool SwapPointers> struct matrix_swap_impl;
; 56   : 
; 57   : } // end namespace internal
; 58   : 
; 59   : /** \class PlainObjectBase
; 60   :   * \brief %Dense storage base class for matrices and arrays.
; 61   :   *
; 62   :   * This class can be extended with the help of the plugin mechanism described on the page
; 63   :   * \ref TopicCustomizingEigen by defining the preprocessor symbol \c EIGEN_PLAINOBJECTBASE_PLUGIN.
; 64   :   *
; 65   :   * \sa \ref TopicClassHierarchy
; 66   :   */
; 67   : #ifdef EIGEN_PARSED_BY_DOXYGEN
; 68   : namespace internal {
; 69   : 
; 70   : // this is a warkaround to doxygen not being able to understand the inheritence logic
; 71   : // when it is hidden by the dense_xpr_base helper struct.
; 72   : template<typename Derived> struct dense_xpr_base_dispatcher_for_doxygen;// : public MatrixBase<Derived> {};
; 73   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 74   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 75   : struct dense_xpr_base_dispatcher_for_doxygen<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 76   :     : public MatrixBase<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 77   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 78   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 79   : struct dense_xpr_base_dispatcher_for_doxygen<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 80   :     : public ArrayBase<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 81   : 
; 82   : } // namespace internal
; 83   : 
; 84   : template<typename Derived>
; 85   : class PlainObjectBase : public internal::dense_xpr_base_dispatcher_for_doxygen<Derived>
; 86   : #else
; 87   : template<typename Derived>
; 88   : class PlainObjectBase : public internal::dense_xpr_base<Derived>::type
; 89   : #endif
; 90   : {
; 91   :   public:
; 92   :     enum { Options = internal::traits<Derived>::Options };
; 93   :     typedef typename internal::dense_xpr_base<Derived>::type Base;
; 94   : 
; 95   :     typedef typename internal::traits<Derived>::StorageKind StorageKind;
; 96   :     typedef typename internal::traits<Derived>::Index Index;
; 97   :     typedef typename internal::traits<Derived>::Scalar Scalar;
; 98   :     typedef typename internal::packet_traits<Scalar>::type PacketScalar;
; 99   :     typedef typename NumTraits<Scalar>::Real RealScalar;
; 100  :     typedef Derived DenseType;
; 101  : 
; 102  :     using Base::RowsAtCompileTime;
; 103  :     using Base::ColsAtCompileTime;
; 104  :     using Base::SizeAtCompileTime;
; 105  :     using Base::MaxRowsAtCompileTime;
; 106  :     using Base::MaxColsAtCompileTime;
; 107  :     using Base::MaxSizeAtCompileTime;
; 108  :     using Base::IsVectorAtCompileTime;
; 109  :     using Base::Flags;
; 110  : 
; 111  :     template<typename PlainObjectType, int MapOptions, typename StrideType> friend class Eigen::Map;
; 112  :     friend  class Eigen::Map<Derived, Unaligned>;
; 113  :     typedef Eigen::Map<Derived, Unaligned>  MapType;
; 114  :     friend  class Eigen::Map<const Derived, Unaligned>;
; 115  :     typedef const Eigen::Map<const Derived, Unaligned> ConstMapType;
; 116  :     friend  class Eigen::Map<Derived, Aligned>;
; 117  :     typedef Eigen::Map<Derived, Aligned> AlignedMapType;
; 118  :     friend  class Eigen::Map<const Derived, Aligned>;
; 119  :     typedef const Eigen::Map<const Derived, Aligned> ConstAlignedMapType;
; 120  :     template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };
; 121  :     template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };
; 122  :     template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, Aligned, StrideType> type; };
; 123  :     template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, Aligned, StrideType> type; };
; 124  : 
; 125  :   protected:
; 126  :     DenseStorage<Scalar, Base::MaxSizeAtCompileTime, Base::RowsAtCompileTime, Base::ColsAtCompileTime, Options> m_storage;
; 127  : 
; 128  :   public:
; 129  :     enum { NeedsToAlign = SizeAtCompileTime != Dynamic && (internal::traits<Derived>::Flags & AlignedBit) != 0 };
; 130  :     EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(NeedsToAlign)
; 131  : 
; 132  :     Base& base() { return *static_cast<Base*>(this); }
; 133  :     const Base& base() const { return *static_cast<const Base*>(this); }
; 134  : 
; 135  :     EIGEN_STRONG_INLINE Index rows() const { return m_storage.rows(); }
; 136  :     EIGEN_STRONG_INLINE Index cols() const { return m_storage.cols(); }
; 137  : 
; 138  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index rowId, Index colId) const
; 139  :     {
; 140  :       if(Flags & RowMajorBit)
; 141  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 142  :       else // column-major
; 143  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 144  :     }
; 145  : 
; 146  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index index) const
; 147  :     {
; 148  :       return m_storage.data()[index];
; 149  :     }
; 150  : 
; 151  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index rowId, Index colId)
; 152  :     {
; 153  :       if(Flags & RowMajorBit)
; 154  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 155  :       else // column-major
; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 157  :     }
; 158  : 
; 159  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
; 160  :     {
; 161  :       return m_storage.data()[index];
; 162  :     }
; 163  : 
; 164  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
; 165  :     {
; 166  :       if(Flags & RowMajorBit)
; 167  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 168  :       else // column-major
; 169  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 170  :     }
; 171  : 
; 172  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
; 173  :     {
; 174  :       return m_storage.data()[index];
; 175  :     }
; 176  : 
; 177  :     /** \internal */
; 178  :     template<int LoadMode>
; 179  :     EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const
; 180  :     {
; 181  :       return internal::ploadt<PacketScalar, LoadMode>
; 182  :                (m_storage.data() + (Flags & RowMajorBit
; 183  :                                    ? colId + rowId * m_storage.cols()
; 184  :                                    : rowId + colId * m_storage.rows()));
; 185  :     }
; 186  : 
; 187  :     /** \internal */
; 188  :     template<int LoadMode>
; 189  :     EIGEN_STRONG_INLINE PacketScalar packet(Index index) const
; 190  :     {
; 191  :       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);
; 192  :     }
; 193  : 
; 194  :     /** \internal */
; 195  :     template<int StoreMode>
; 196  :     EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)
; 197  :     {
; 198  :       internal::pstoret<Scalar, PacketScalar, StoreMode>
; 199  :               (m_storage.data() + (Flags & RowMajorBit
; 200  :                                    ? colId + rowId * m_storage.cols()
; 201  :                                    : rowId + colId * m_storage.rows()), val);
; 202  :     }
; 203  : 
; 204  :     /** \internal */
; 205  :     template<int StoreMode>
; 206  :     EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
; 207  :     {
; 208  :       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
; 209  :     }
; 210  : 
; 211  :     /** \returns a const pointer to the data array of this matrix */
; 212  :     EIGEN_STRONG_INLINE const Scalar *data() const
; 213  :     { return m_storage.data(); }
; 214  : 
; 215  :     /** \returns a pointer to the data array of this matrix */
; 216  :     EIGEN_STRONG_INLINE Scalar *data()
; 217  :     { return m_storage.data(); }
; 218  : 
; 219  :     /** Resizes \c *this to a \a rows x \a cols matrix.
; 220  :       *
; 221  :       * This method is intended for dynamic-size matrices, although it is legal to call it on any
; 222  :       * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
; 223  :       * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
; 224  :       *
; 225  :       * If the current number of coefficients of \c *this exactly matches the
; 226  :       * product \a rows * \a cols, then no memory allocation is performed and
; 227  :       * the current values are left unchanged. In all other cases, including
; 228  :       * shrinking, the data is reallocated and all previous values are lost.
; 229  :       *
; 230  :       * Example: \include Matrix_resize_int_int.cpp
; 231  :       * Output: \verbinclude Matrix_resize_int_int.out
; 232  :       *
; 233  :       * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
; 234  :       */
; 235  :     EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)
; 236  :     {
; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rbx, rbx
$LN157@resize_to_:
	jns	SHORT $LN126@resize_to_
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	mov	r8d, 241				; 000000f1H
	call	QWORD PTR __imp__wassert
$LN126@resize_to_:

; 44   :                : (rows > max_index / cols);

	test	rbx, rbx
	je	SHORT $LN133@resize_to_
	cmp	rbx, rsi
	setg	al

; 45   :     if (error)

	test	al, al
	jne	SHORT $LN161@resize_to_
$LN133@resize_to_:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 249  :       if(size != m_rows*m_cols)

	mov	rax, QWORD PTR [rdi+16]
	imul	rax, QWORD PTR [rdi+8]
	cmp	rbx, rax
	je	SHORT $LN138@resize_to_
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR [rdi]
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 252  :         if (size)

	test	rbx, rbx
	je	SHORT $LN139@resize_to_

; 253  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

	mov	rcx, rbx
	call	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
	mov	QWORD PTR [rdi], rax

; 254  :         else

	jmp	SHORT $LN138@resize_to_
$LN139@resize_to_:

; 255  :           m_data = 0;

	mov	QWORD PTR [rdi], 0
$LN138@resize_to_:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 579  :     }

	mov	rsi, QWORD PTR [rsp+56]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 258  :       m_rows = nbRows;

	mov	QWORD PTR [rdi+8], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 579  :     }

	mov	rbx, QWORD PTR [rsp+48]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 259  :       m_cols = nbCols;

	mov	QWORD PTR [rdi+16], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 579  :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN159@resize_to_:

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN161@resize_to_:
	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN156@resize_to_:
??$_resize_to_match@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEAAXAEBU?$EigenBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z ENDP ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::_resize_to_match<Eigen::Matrix<double,-1,1,0,-1,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
;	COMDAT ??$lazyAssign@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 48
other$ = 56
??$lazyAssign@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z PROC ; Eigen::DenseBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::lazyAssign<Eigen::Matrix<double,-1,1,0,-1,1> >, COMDAT

; 486  : {

$LN119:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 487  :   enum{
; 488  :     SameType = internal::is_same<typename Derived::Scalar,typename OtherDerived::Scalar>::value
; 489  :   };
; 490  : 
; 491  :   EIGEN_STATIC_ASSERT_LVALUE(Derived)
; 492  :   EIGEN_STATIC_ASSERT_SAME_MATRIX_SIZE(Derived,OtherDerived)
; 493  :   EIGEN_STATIC_ASSERT(SameType,YOU_MIXED_DIFFERENT_NUMERIC_TYPES__YOU_NEED_TO_USE_THE_CAST_METHOD_OF_MATRIXBASE_TO_CAST_NUMERIC_TYPES_EXPLICITLY)
; 494  : 
; 495  : #ifdef EIGEN_DEBUG_ASSIGN
; 496  :   internal::assign_traits<Derived, OtherDerived>::debug();
; 497  : #endif
; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	mov	rax, QWORD PTR [rdx+8]
	mov	rdi, rdx
	mov	rbx, rcx
	cmp	QWORD PTR [rcx+8], rax
	jne	SHORT $LN3@lazyAssign
	cmp	QWORD PTR [rcx+16], 1
	je	SHORT $LN4@lazyAssign
$LN3@lazyAssign:
	lea	rdx, OFFSET FLAT:??_C@_1KO@HDGCFKMN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GC@PBCDNLIH@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ@
	mov	r8d, 498				; 000001f2H
	call	QWORD PTR __imp__wassert
$LN4@lazyAssign:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 49   :   inline Index size() const { return rows() * cols(); }

	mov	r9, QWORD PTR [rbx+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	xor	r10d, r10d
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 49   :   inline Index size() const { return rows() * cols(); }

	imul	r9, QWORD PTR [rbx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 404  :     const Index alignedEnd = alignedStart + ((size-alignedStart)/packetSize)*packetSize;

	mov	rax, r9
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r8, rax
	add	r8, r8

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	test	r8, r8
	jle	SHORT $LN41@lazyAssign
	npad	3
$LL43@lazyAssign:
	mov	rdx, QWORD PTR [rdi]
	mov	rax, QWORD PTR [rbx]
	add	r10, 2
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 220  : template<> EIGEN_STRONG_INLINE Packet2d pload<Packet2d>(const double*  from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_pd(from); }

	movaps	xmm0, XMMWORD PTR [rdx+r10*8-16]

; 221  : template<> EIGEN_STRONG_INLINE Packet4i pload<Packet4i>(const int*     from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_si128(reinterpret_cast<const Packet4i*>(from)); }
; 222  : 
; 223  : #if defined(_MSC_VER)
; 224  :   template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float*  from) {
; 225  :     EIGEN_DEBUG_UNALIGNED_LOAD
; 226  :     #if (_MSC_VER==1600)
; 227  :     // NOTE Some version of MSVC10 generates bad code when using _mm_loadu_ps
; 228  :     // (i.e., it does not generate an unaligned load!!
; 229  :     // TODO On most architectures this version should also be faster than a single _mm_loadu_ps
; 230  :     // so we could also enable it for MSVC08 but first we have to make this later does not generate crap when doing so...
; 231  :     __m128 res = _mm_loadl_pi(_mm_set1_ps(0.0f), (const __m64*)(from));
; 232  :     res = _mm_loadh_pi(res, (const __m64*)(from+2));
; 233  :     return res;
; 234  :     #else
; 235  :     return _mm_loadu_ps(from);
; 236  :     #endif
; 237  :   }
; 238  :   template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm_loadu_pd(from); }
; 239  :   template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int*    from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm_loadu_si128(reinterpret_cast<const Packet4i*>(from)); }
; 240  : #else
; 241  : // Fast unaligned loads. Note that here we cannot directly use intrinsics: this would
; 242  : // require pointer casting to incompatible pointer types and leads to invalid code
; 243  : // because of the strict aliasing rule. The "dummy" stuff are required to enforce
; 244  : // a correct instruction dependency.
; 245  : // TODO: do the same for MSVC (ICC is compatible)
; 246  : // NOTE: with the code below, MSVC's compiler crashes!
; 247  : 
; 248  : #if defined(__GNUC__) && defined(__i386__)
; 249  :   // bug 195: gcc/i386 emits weird x87 fldl/fstpl instructions for _mm_load_sd
; 250  :   #define EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS 1
; 251  : #elif defined(__clang__)
; 252  :   // bug 201: Segfaults in __mm_loadh_pd with clang 2.8
; 253  :   #define EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS 1
; 254  : #else
; 255  :   #define EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS 0
; 256  : #endif
; 257  : 
; 258  : template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float* from)
; 259  : {
; 260  :   EIGEN_DEBUG_UNALIGNED_LOAD
; 261  : #if EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS
; 262  :   return _mm_loadu_ps(from);
; 263  : #else
; 264  :   __m128d res;
; 265  :   res =  _mm_load_sd((const double*)(from)) ;
; 266  :   res =  _mm_loadh_pd(res, (const double*)(from+2)) ;
; 267  :   return _mm_castpd_ps(res);
; 268  : #endif
; 269  : }
; 270  : template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from)
; 271  : {
; 272  :   EIGEN_DEBUG_UNALIGNED_LOAD
; 273  : #if EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS
; 274  :   return _mm_loadu_pd(from);
; 275  : #else
; 276  :   __m128d res;
; 277  :   res = _mm_load_sd(from) ;
; 278  :   res = _mm_loadh_pd(res,from+1);
; 279  :   return res;
; 280  : #endif
; 281  : }
; 282  : template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int* from)
; 283  : {
; 284  :   EIGEN_DEBUG_UNALIGNED_LOAD
; 285  : #if EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS
; 286  :   return _mm_loadu_si128(reinterpret_cast<const Packet4i*>(from));
; 287  : #else
; 288  :   __m128d res;
; 289  :   res =  _mm_load_sd((const double*)(from)) ;
; 290  :   res =  _mm_loadh_pd(res, (const double*)(from+2)) ;
; 291  :   return _mm_castpd_si128(res);
; 292  : #endif
; 293  : }
; 294  : #endif
; 295  : 
; 296  : template<> EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float*   from)
; 297  : {
; 298  :   return vec4f_swizzle1(_mm_castpd_ps(_mm_load_sd(reinterpret_cast<const double*>(from))), 0, 0, 1, 1);
; 299  : }
; 300  : template<> EIGEN_STRONG_INLINE Packet2d ploaddup<Packet2d>(const double*  from)
; 301  : { return pset1<Packet2d>(from[0]); }
; 302  : template<> EIGEN_STRONG_INLINE Packet4i ploaddup<Packet4i>(const int*     from)
; 303  : {
; 304  :   Packet4i tmp;
; 305  :   tmp = _mm_loadl_epi64(reinterpret_cast<const Packet4i*>(from));
; 306  :   return vec4i_swizzle1(tmp, 0, 0, 1, 1);
; 307  : }
; 308  : 
; 309  : template<> EIGEN_STRONG_INLINE void pstore<float>(float*   to, const Packet4f& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_ps(to, from); }
; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [rax+r10*8-16], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	cmp	r10, r8
	jl	SHORT $LL43@lazyAssign
$LN41@lazyAssign:

; 409  :     {
; 410  :       dst.template copyPacket<Derived2, dstAlignment, srcAlignment>(index, src);
; 411  :     }
; 412  : 
; 413  :     unaligned_assign_impl<>::run(src,dst,alignedEnd,size);

	mov	rdx, rbx
	mov	rcx, rdi
	call	??$run@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@@?$unaligned_assign_impl@$0A@@internal@Eigen@@SAXAEBV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@_J2@Z ; Eigen::internal::unaligned_assign_impl<0>::run<Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Matrix<double,-1,-1,0,-1,-1> >

; 499  :   internal::assign_impl<Derived, OtherDerived, int(SameType) ? int(internal::assign_traits<Derived, OtherDerived>::Traversal)
; 500  :                                                        : int(InvalidTraversal)>::run(derived(),other.derived());
; 501  : #ifndef EIGEN_NO_DEBUG
; 502  :   checkTransposeAliasing(other.derived());
; 503  : #endif
; 504  :   return derived();

	mov	rax, rbx

; 505  : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$lazyAssign@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@1@AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z ENDP ; Eigen::DenseBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::lazyAssign<Eigen::Matrix<double,-1,1,0,-1,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h
;	COMDAT ??$checkTransposeAliasing@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@?$DenseBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@IEBAXAEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@1@@Z
_TEXT	SEGMENT
this$dead$ = 8
other$dead$ = 16
??$checkTransposeAliasing@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@?$DenseBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@IEBAXAEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@1@@Z PROC ; Eigen::DenseBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> > >::checkTransposeAliasing<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >, COMDAT

; 413  :     internal::checkTransposeAliasing_impl<Derived, OtherDerived>::run(derived(), other);
; 414  : }

	ret	0
??$checkTransposeAliasing@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@?$DenseBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@@Eigen@@IEBAXAEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@1@@Z ENDP ; Eigen::DenseBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> > >::checkTransposeAliasing<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
;	COMDAT ??$copyCoeff@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 8
row$ = 16
col$ = 24
other$ = 32
??$copyCoeff@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z PROC ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,1>::copyCoeff<Eigen::Matrix<double,-1,1,0,-1,1> >, COMDAT

; 477  :     {
; 478  :       eigen_internal_assert(row >= 0 && row < rows()
; 479  :                         && col >= 0 && col < cols());
; 480  :       derived().coeffRef(row, col) = other.derived().coeff(row, col);

	mov	r10, QWORD PTR [r9+8]
	mov	rax, QWORD PTR [r9]
	mov	r9, QWORD PTR [rcx+32]
	imul	r10, r8
	imul	r9, r8
	mov	rcx, QWORD PTR [rcx]
	add	r10, rdx
	add	r9, rdx
	mov	rax, QWORD PTR [rax+r10*8]
	mov	QWORD PTR [rcx+r9*8], rax

; 481  :     }

	ret	0
??$copyCoeff@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z ENDP ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,1>::copyCoeff<Eigen::Matrix<double,-1,1,0,-1,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
;	COMDAT ??$copyPacket@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$00$0A@@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 8
row$ = 16
col$ = 24
other$ = 32
??$copyPacket@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$00$0A@@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z PROC ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,1>::copyPacket<Eigen::Matrix<double,-1,1,0,-1,1>,1,0>, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 217  :                (this->m_data + (col * colStride() + row * rowStride()), val);

	mov	rax, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	mov	r10, QWORD PTR [rcx+32]
	mov	rcx, QWORD PTR [r9+8]
	imul	r10, r8
	imul	rcx, r8
	add	r10, rdx
	add	rcx, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 217  :                (this->m_data + (col * colStride() + row * rowStride()), val);

	lea	r11, QWORD PTR [rax+r10*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 184  :                                    : rowId + colId * m_storage.rows()));

	mov	rax, QWORD PTR [r9]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 238  :   template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm_loadu_pd(from); }

	movups	xmm0, XMMWORD PTR [rax+rcx*8]

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [r11], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 523  :     }

	ret	0
??$copyPacket@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$00$0A@@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z ENDP ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,1>::copyPacket<Eigen::Matrix<double,-1,1,0,-1,1>,1,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
;	COMDAT ??$copyCoeff@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 8
row$ = 16
col$ = 24
other$ = 32
??$copyCoeff@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@1@@Z PROC ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,1>::copyCoeff<Eigen::Matrix<double,-1,-1,0,-1,-1> >, COMDAT

; 477  :     {
; 478  :       eigen_internal_assert(row >= 0 && row < rows()
; 479  :                         && col >= 0 && col < cols());
; 480  :       derived().coeffRef(row, col) = other.derived().coeff(row, col);

	mov	r10, QWORD PTR [r9+8]
	mov	rax, QWORD PTR [r9]
	mov	r9, QWORD PTR [rcx+32]
	imul	r10, r8
	imul	r9, r8
	mov	rcx, QWORD PTR [rcx]
	add	r10, rdx
	add	r9, rdx
	mov	rax, QWORD PTR [rax+r10*8]
	mov	QWORD PTR [rcx+r9*8], rax

; 481  :     }

	ret	0
??$copyCoeff@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@1@@Z ENDP ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,1>::copyCoeff<Eigen::Matrix<double,-1,-1,0,-1,-1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
;	COMDAT ??$copyPacket@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$00$0A@@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 8
row$ = 16
col$ = 24
other$ = 32
??$copyPacket@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$00$0A@@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@1@@Z PROC ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,1>::copyPacket<Eigen::Matrix<double,-1,-1,0,-1,-1>,1,0>, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 217  :                (this->m_data + (col * colStride() + row * rowStride()), val);

	mov	rax, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	mov	r10, QWORD PTR [rcx+32]
	mov	rcx, QWORD PTR [r9+8]
	imul	r10, r8
	imul	rcx, r8
	add	r10, rdx
	add	rcx, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 217  :                (this->m_data + (col * colStride() + row * rowStride()), val);

	lea	r11, QWORD PTR [rax+r10*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 184  :                                    : rowId + colId * m_storage.rows()));

	mov	rax, QWORD PTR [r9]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 238  :   template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm_loadu_pd(from); }

	movups	xmm0, XMMWORD PTR [rax+rcx*8]

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [r11], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 523  :     }

	ret	0
??$copyPacket@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$00$0A@@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@1@@Z ENDP ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,1>::copyPacket<Eigen::Matrix<double,-1,-1,0,-1,-1>,1,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
;	COMDAT ??$copyCoeff@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 8
row$ = 16
col$ = 24
other$ = 32
??$copyCoeff@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@1@@Z PROC ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,1>::copyCoeff<Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> > >, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h

; 74   :     nestedExpression() const { return m_matrix; }

	mov	rax, QWORD PTR [r9]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 480  :       derived().coeffRef(row, col) = other.derived().coeff(row, col);

	mov	r9, QWORD PTR [rcx+32]
	mov	rcx, QWORD PTR [rcx]
	imul	r9, r8
	mov	r10, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax]
	add	r9, rdx
	imul	r10, rdx
	add	r10, r8
	mov	rax, QWORD PTR [rax+r10*8]
	mov	QWORD PTR [rcx+r9*8], rax

; 481  :     }

	ret	0
??$copyCoeff@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@?$DenseCoeffsBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@1@@Z ENDP ; Eigen::DenseCoeffsBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,1>::copyCoeff<Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\blasutil.h
;	COMDAT ??$extract_data@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@internal@Eigen@@YAPEBNAEBV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@1@@Z
_TEXT	SEGMENT
m$ = 8
??$extract_data@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@internal@Eigen@@YAPEBNAEBV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@1@@Z PROC ; Eigen::internal::extract_data<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >, COMDAT

; 257  :   return extract_data_selector<T>::run(m);

	mov	rax, QWORD PTR [rcx]

; 258  : }

	ret	0
??$extract_data@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@internal@Eigen@@YAPEBNAEBV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@1@@Z ENDP ; Eigen::internal::extract_data<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
;	COMDAT ??$copyCoeffByOuterInner@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@?$DenseCoeffsBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 8
outer$dead$ = 16
inner$ = 24
other$ = 32
??$copyCoeffByOuterInner@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@?$DenseCoeffsBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@1@@Z PROC ; Eigen::DenseCoeffsBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >,1>::copyCoeffByOuterInner<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h

; 93   :       Scalar& tmp = m_matrix.coeffRef(row,col);

	mov	rax, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];

	mov	rcx, QWORD PTR [rax]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h

; 26   :   EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& b) const { return a + b; }

	mov	rax, QWORD PTR [r9]
	movsdx	xmm0, QWORD PTR [rax+r8*8]
	addsd	xmm0, QWORD PTR [rcx+r8*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h

; 94   :       tmp = m_functor(tmp, _other.coeff(row,col));

	movsdx	QWORD PTR [rcx+r8*8], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 506  :     }

	ret	0
??$copyCoeffByOuterInner@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@?$DenseCoeffsBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@1@@Z ENDP ; Eigen::DenseCoeffsBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >,1>::copyCoeffByOuterInner<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
;	COMDAT ??$copyPacketByOuterInner@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$00$0A@@?$DenseCoeffsBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 8
outer$dead$ = 16
inner$ = 24
other$ = 32
??$copyPacketByOuterInner@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$00$0A@@?$DenseCoeffsBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@1@@Z PROC ; Eigen::DenseCoeffsBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >,1>::copyPacketByOuterInner<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,1,0>, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h

; 113  :         m_functor.packetOp(m_matrix.template packet<StoreMode>(row, col),_other.template packet<LoadMode>(row, col)) );

	mov	rdx, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 201  :                                    : rowId + colId * m_storage.rows()), val);

	mov	rax, QWORD PTR [rdx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 220  : template<> EIGEN_STRONG_INLINE Packet2d pload<Packet2d>(const double*  from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_pd(from); }

	movaps	xmm1, XMMWORD PTR [rax+r8*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 201  :                                    : rowId + colId * m_storage.rows()), val);

	lea	rcx, QWORD PTR [rax+r8*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 116  :                (m_data + (colId * colStride() + rowId * rowStride()));

	mov	rax, QWORD PTR [r9]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 238  :   template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm_loadu_pd(from); }

	movups	xmm0, XMMWORD PTR [rax+r8*8]

; 123  : template<> EIGEN_STRONG_INLINE Packet2d padd<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_add_pd(a,b); }

	addpd	xmm1, xmm0

; 239  :   template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int*    from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm_loadu_si128(reinterpret_cast<const Packet4i*>(from)); }
; 240  : #else
; 241  : // Fast unaligned loads. Note that here we cannot directly use intrinsics: this would
; 242  : // require pointer casting to incompatible pointer types and leads to invalid code
; 243  : // because of the strict aliasing rule. The "dummy" stuff are required to enforce
; 244  : // a correct instruction dependency.
; 245  : // TODO: do the same for MSVC (ICC is compatible)
; 246  : // NOTE: with the code below, MSVC's compiler crashes!
; 247  : 
; 248  : #if defined(__GNUC__) && defined(__i386__)
; 249  :   // bug 195: gcc/i386 emits weird x87 fldl/fstpl instructions for _mm_load_sd
; 250  :   #define EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS 1
; 251  : #elif defined(__clang__)
; 252  :   // bug 201: Segfaults in __mm_loadh_pd with clang 2.8
; 253  :   #define EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS 1
; 254  : #else
; 255  :   #define EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS 0
; 256  : #endif
; 257  : 
; 258  : template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float* from)
; 259  : {
; 260  :   EIGEN_DEBUG_UNALIGNED_LOAD
; 261  : #if EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS
; 262  :   return _mm_loadu_ps(from);
; 263  : #else
; 264  :   __m128d res;
; 265  :   res =  _mm_load_sd((const double*)(from)) ;
; 266  :   res =  _mm_loadh_pd(res, (const double*)(from+2)) ;
; 267  :   return _mm_castpd_ps(res);
; 268  : #endif
; 269  : }
; 270  : template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from)
; 271  : {
; 272  :   EIGEN_DEBUG_UNALIGNED_LOAD
; 273  : #if EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS
; 274  :   return _mm_loadu_pd(from);
; 275  : #else
; 276  :   __m128d res;
; 277  :   res = _mm_load_sd(from) ;
; 278  :   res = _mm_loadh_pd(res,from+1);
; 279  :   return res;
; 280  : #endif
; 281  : }
; 282  : template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int* from)
; 283  : {
; 284  :   EIGEN_DEBUG_UNALIGNED_LOAD
; 285  : #if EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS
; 286  :   return _mm_loadu_si128(reinterpret_cast<const Packet4i*>(from));
; 287  : #else
; 288  :   __m128d res;
; 289  :   res =  _mm_load_sd((const double*)(from)) ;
; 290  :   res =  _mm_loadh_pd(res, (const double*)(from+2)) ;
; 291  :   return _mm_castpd_si128(res);
; 292  : #endif
; 293  : }
; 294  : #endif
; 295  : 
; 296  : template<> EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float*   from)
; 297  : {
; 298  :   return vec4f_swizzle1(_mm_castpd_ps(_mm_load_sd(reinterpret_cast<const double*>(from))), 0, 0, 1, 1);
; 299  : }
; 300  : template<> EIGEN_STRONG_INLINE Packet2d ploaddup<Packet2d>(const double*  from)
; 301  : { return pset1<Packet2d>(from[0]); }
; 302  : template<> EIGEN_STRONG_INLINE Packet4i ploaddup<Packet4i>(const int*     from)
; 303  : {
; 304  :   Packet4i tmp;
; 305  :   tmp = _mm_loadl_epi64(reinterpret_cast<const Packet4i*>(from));
; 306  :   return vec4i_swizzle1(tmp, 0, 0, 1, 1);
; 307  : }
; 308  : 
; 309  : template<> EIGEN_STRONG_INLINE void pstore<float>(float*   to, const Packet4f& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_ps(to, from); }
; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [rcx], xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 549  :     }

	ret	0
??$copyPacketByOuterInner@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$00$0A@@?$DenseCoeffsBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@$00@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@1@@Z ENDP ; Eigen::DenseCoeffsBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >,1>::copyPacketByOuterInner<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,1,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\blasutil.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\blasutil.h
;	COMDAT ??$extract_data@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@YAPEBNAEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@1@@Z
_TEXT	SEGMENT
m$ = 8
??$extract_data@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@YAPEBNAEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@1@@Z PROC ; Eigen::internal::extract_data<Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> > >, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 262  :     inline T *data() { return m_data; }

	mov	rax, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\blasutil.h

; 257  :   return extract_data_selector<T>::run(m);

	mov	rax, QWORD PTR [rax]

; 258  : }

	ret	0
??$extract_data@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@internal@Eigen@@YAPEBNAEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@1@@Z ENDP ; Eigen::internal::extract_data<Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h
;	COMDAT ?coeff@?$TransposeImpl@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@UDense@2@@Eigen@@QEBAAEBN_J0@Z
_TEXT	SEGMENT
this$ = 8
rowId$ = 16
colId$ = 24
?coeff@?$TransposeImpl@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@UDense@2@@Eigen@@QEBAAEBN_J0@Z PROC ; Eigen::TransposeImpl<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::Dense>::coeff, COMDAT

; 74   :     nestedExpression() const { return m_matrix; }

	mov	rax, QWORD PTR [rcx]

; 145  :       return derived().nestedExpression().coeff(colId, rowId);

	mov	rcx, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 143  :         return m_storage.data()[rowId + colId * m_storage.rows()];

	mov	rax, QWORD PTR [rax]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h

; 145  :       return derived().nestedExpression().coeff(colId, rowId);

	imul	rcx, rdx
	add	rcx, r8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 143  :         return m_storage.data()[rowId + colId * m_storage.rows()];

	lea	rax, QWORD PTR [rax+rcx*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h

; 146  :     }

	ret	0
?coeff@?$TransposeImpl@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@UDense@2@@Eigen@@QEBAAEBN_J0@Z ENDP ; Eigen::TransposeImpl<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::Dense>::coeff
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
;	COMDAT ?rowIndexByOuterInner@?$DenseCoeffsBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@$0A@@Eigen@@QEBA_J_J0@Z
_TEXT	SEGMENT
this$dead$ = 8
outer$dead$ = 16
inner$ = 24
?rowIndexByOuterInner@?$DenseCoeffsBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@$0A@@Eigen@@QEBA_J_J0@Z PROC ; Eigen::DenseCoeffsBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >,0>::rowIndexByOuterInner, COMDAT

; 66   :       return int(Derived::RowsAtCompileTime) == 1 ? 0
; 67   :           : int(Derived::ColsAtCompileTime) == 1 ? inner
; 68   :           : int(Derived::Flags)&RowMajorBit ? outer
; 69   :           : inner;

	mov	rax, r8

; 70   :     }

	ret	0
?rowIndexByOuterInner@?$DenseCoeffsBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@$0A@@Eigen@@QEBA_J_J0@Z ENDP ; Eigen::DenseCoeffsBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >,0>::rowIndexByOuterInner
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
;	COMDAT ?colIndexByOuterInner@?$DenseCoeffsBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@$0A@@Eigen@@QEBA_J_J0@Z
_TEXT	SEGMENT
this$dead$ = 8
outer$dead$ = 16
inner$dead$ = 24
?colIndexByOuterInner@?$DenseCoeffsBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@$0A@@Eigen@@QEBA_J_J0@Z PROC ; Eigen::DenseCoeffsBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >,0>::colIndexByOuterInner, COMDAT

; 74   :       return int(Derived::ColsAtCompileTime) == 1 ? 0
; 75   :           : int(Derived::RowsAtCompileTime) == 1 ? inner
; 76   :           : int(Derived::Flags)&RowMajorBit ? inner
; 77   :           : outer;

	xor	eax, eax

; 78   :     }

	ret	0
?colIndexByOuterInner@?$DenseCoeffsBase@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@$0A@@Eigen@@QEBA_J_J0@Z ENDP ; Eigen::DenseCoeffsBase<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >,0>::colIndexByOuterInner
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
;	COMDAT ?run@?$assign_impl@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$02$0A@$0A@@internal@Eigen@@SAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z
_TEXT	SEGMENT
dst$ = 48
src$ = 56
?run@?$assign_impl@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$02$0A@$0A@@internal@Eigen@@SAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z PROC ; Eigen::internal::assign_impl<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::Matrix<double,-1,1,0,-1,1>,3,0,0>::run, COMDAT

; 394  :   {

$LN75:
	push	rbx
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 49   :   inline Index size() const { return rows() * cols(); }

	mov	r9, QWORD PTR [rcx+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 394  :   {

	mov	rbx, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 49   :   inline Index size() const { return rows() * cols(); }

	imul	r9, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 404  :     const Index alignedEnd = alignedStart + ((size-alignedStart)/packetSize)*packetSize;

	mov	rax, r9
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r8, rax

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	xor	eax, eax
	add	r8, r8
	test	r8, r8
	jle	SHORT $LN1@run
	npad	6
$LL3@run:
	mov	r10, QWORD PTR [rcx]
	lea	r11, QWORD PTR [r10+rax*8]
	mov	r10, QWORD PTR [rbx]
	add	rax, 2
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 220  : template<> EIGEN_STRONG_INLINE Packet2d pload<Packet2d>(const double*  from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_pd(from); }

	movaps	xmm0, XMMWORD PTR [r10+rax*8-16]

; 221  : template<> EIGEN_STRONG_INLINE Packet4i pload<Packet4i>(const int*     from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_si128(reinterpret_cast<const Packet4i*>(from)); }
; 222  : 
; 223  : #if defined(_MSC_VER)
; 224  :   template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float*  from) {
; 225  :     EIGEN_DEBUG_UNALIGNED_LOAD
; 226  :     #if (_MSC_VER==1600)
; 227  :     // NOTE Some version of MSVC10 generates bad code when using _mm_loadu_ps
; 228  :     // (i.e., it does not generate an unaligned load!!
; 229  :     // TODO On most architectures this version should also be faster than a single _mm_loadu_ps
; 230  :     // so we could also enable it for MSVC08 but first we have to make this later does not generate crap when doing so...
; 231  :     __m128 res = _mm_loadl_pi(_mm_set1_ps(0.0f), (const __m64*)(from));
; 232  :     res = _mm_loadh_pi(res, (const __m64*)(from+2));
; 233  :     return res;
; 234  :     #else
; 235  :     return _mm_loadu_ps(from);
; 236  :     #endif
; 237  :   }
; 238  :   template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm_loadu_pd(from); }
; 239  :   template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int*    from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm_loadu_si128(reinterpret_cast<const Packet4i*>(from)); }
; 240  : #else
; 241  : // Fast unaligned loads. Note that here we cannot directly use intrinsics: this would
; 242  : // require pointer casting to incompatible pointer types and leads to invalid code
; 243  : // because of the strict aliasing rule. The "dummy" stuff are required to enforce
; 244  : // a correct instruction dependency.
; 245  : // TODO: do the same for MSVC (ICC is compatible)
; 246  : // NOTE: with the code below, MSVC's compiler crashes!
; 247  : 
; 248  : #if defined(__GNUC__) && defined(__i386__)
; 249  :   // bug 195: gcc/i386 emits weird x87 fldl/fstpl instructions for _mm_load_sd
; 250  :   #define EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS 1
; 251  : #elif defined(__clang__)
; 252  :   // bug 201: Segfaults in __mm_loadh_pd with clang 2.8
; 253  :   #define EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS 1
; 254  : #else
; 255  :   #define EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS 0
; 256  : #endif
; 257  : 
; 258  : template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float* from)
; 259  : {
; 260  :   EIGEN_DEBUG_UNALIGNED_LOAD
; 261  : #if EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS
; 262  :   return _mm_loadu_ps(from);
; 263  : #else
; 264  :   __m128d res;
; 265  :   res =  _mm_load_sd((const double*)(from)) ;
; 266  :   res =  _mm_loadh_pd(res, (const double*)(from+2)) ;
; 267  :   return _mm_castpd_ps(res);
; 268  : #endif
; 269  : }
; 270  : template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from)
; 271  : {
; 272  :   EIGEN_DEBUG_UNALIGNED_LOAD
; 273  : #if EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS
; 274  :   return _mm_loadu_pd(from);
; 275  : #else
; 276  :   __m128d res;
; 277  :   res = _mm_load_sd(from) ;
; 278  :   res = _mm_loadh_pd(res,from+1);
; 279  :   return res;
; 280  : #endif
; 281  : }
; 282  : template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int* from)
; 283  : {
; 284  :   EIGEN_DEBUG_UNALIGNED_LOAD
; 285  : #if EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS
; 286  :   return _mm_loadu_si128(reinterpret_cast<const Packet4i*>(from));
; 287  : #else
; 288  :   __m128d res;
; 289  :   res =  _mm_load_sd((const double*)(from)) ;
; 290  :   res =  _mm_loadh_pd(res, (const double*)(from+2)) ;
; 291  :   return _mm_castpd_si128(res);
; 292  : #endif
; 293  : }
; 294  : #endif
; 295  : 
; 296  : template<> EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float*   from)
; 297  : {
; 298  :   return vec4f_swizzle1(_mm_castpd_ps(_mm_load_sd(reinterpret_cast<const double*>(from))), 0, 0, 1, 1);
; 299  : }
; 300  : template<> EIGEN_STRONG_INLINE Packet2d ploaddup<Packet2d>(const double*  from)
; 301  : { return pset1<Packet2d>(from[0]); }
; 302  : template<> EIGEN_STRONG_INLINE Packet4i ploaddup<Packet4i>(const int*     from)
; 303  : {
; 304  :   Packet4i tmp;
; 305  :   tmp = _mm_loadl_epi64(reinterpret_cast<const Packet4i*>(from));
; 306  :   return vec4i_swizzle1(tmp, 0, 0, 1, 1);
; 307  : }
; 308  : 
; 309  : template<> EIGEN_STRONG_INLINE void pstore<float>(float*   to, const Packet4f& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_ps(to, from); }
; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [r11], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	cmp	rax, r8
	jl	SHORT $LL3@run
$LN1@run:

; 409  :     {
; 410  :       dst.template copyPacket<Derived2, dstAlignment, srcAlignment>(index, src);
; 411  :     }
; 412  : 
; 413  :     unaligned_assign_impl<>::run(src,dst,alignedEnd,size);

	mov	rdx, rcx
	mov	rcx, rbx

; 414  :   }

	add	rsp, 32					; 00000020H
	pop	rbx

; 409  :     {
; 410  :       dst.template copyPacket<Derived2, dstAlignment, srcAlignment>(index, src);
; 411  :     }
; 412  : 
; 413  :     unaligned_assign_impl<>::run(src,dst,alignedEnd,size);

	jmp	??$run@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@@?$unaligned_assign_impl@$0A@@internal@Eigen@@SAXAEBV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@_J2@Z ; Eigen::internal::unaligned_assign_impl<0>::run<Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Matrix<double,-1,-1,0,-1,-1> >
?run@?$assign_impl@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$02$0A@$0A@@internal@Eigen@@SAXAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z ENDP ; Eigen::internal::assign_impl<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::Matrix<double,-1,1,0,-1,1>,3,0,0>::run
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h
;	COMDAT ?run@?$checkTransposeAliasing_impl@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@$0A@@internal@Eigen@@SAXAEBV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@3@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
__formal$dead$ = 16
?run@?$checkTransposeAliasing_impl@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@$0A@@internal@Eigen@@SAXAEBV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@3@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Z PROC ; Eigen::internal::checkTransposeAliasing_impl<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,0>::run, COMDAT

; 404  :     }

	ret	0
?run@?$checkTransposeAliasing_impl@V?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@$0A@@internal@Eigen@@SAXAEBV?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@3@AEBV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Z ENDP ; Eigen::internal::checkTransposeAliasing_impl<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,0>::run
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\blasutil.h
;	COMDAT ?run@?$extract_data_selector@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@internal@Eigen@@SAPEBNAEBV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@@Z
_TEXT	SEGMENT
m$ = 8
?run@?$extract_data_selector@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@internal@Eigen@@SAPEBNAEBV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@@Z PROC ; Eigen::internal::extract_data_selector<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,1>::run, COMDAT

; 246  :     return blas_traits<T>::extract(m).data();

	mov	rax, QWORD PTR [rcx]

; 247  :   }

	ret	0
?run@?$extract_data_selector@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@internal@Eigen@@SAPEBNAEBV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@@Z ENDP ; Eigen::internal::extract_data_selector<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,1>::run
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\blasutil.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\blasutil.h
;	COMDAT ?run@?$extract_data_selector@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@$00@internal@Eigen@@SAPEBNAEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Z
_TEXT	SEGMENT
m$ = 8
?run@?$extract_data_selector@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@$00@internal@Eigen@@SAPEBNAEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Z PROC ; Eigen::internal::extract_data_selector<Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> >,1>::run, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 262  :     inline T *data() { return m_data; }

	mov	rax, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\blasutil.h

; 246  :     return blas_traits<T>::extract(m).data();

	mov	rax, QWORD PTR [rax]

; 247  :   }

	ret	0
?run@?$extract_data_selector@V?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@$00@internal@Eigen@@SAPEBNAEBV?$Transpose@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@3@@Z ENDP ; Eigen::internal::extract_data_selector<Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> >,1>::run
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h
;	COMDAT ?data@?$TransposeImpl@$$CBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@UDense@2@@Eigen@@QEAAPEBNXZ
_TEXT	SEGMENT
this$ = 8
?data@?$TransposeImpl@$$CBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@UDense@2@@Eigen@@QEAAPEBNXZ PROC ; Eigen::TransposeImpl<Eigen::Matrix<double,-1,-1,0,-1,-1> const ,Eigen::Dense>::data, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 262  :     inline T *data() { return m_data; }

	mov	rax, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h

; 118  :     inline ScalarWithConstIfNotLvalue* data() { return derived().nestedExpression().data(); }

	mov	rax, QWORD PTR [rax]
	ret	0
?data@?$TransposeImpl@$$CBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@UDense@2@@Eigen@@QEAAPEBNXZ ENDP ; Eigen::TransposeImpl<Eigen::Matrix<double,-1,-1,0,-1,-1> const ,Eigen::Dense>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
;	COMDAT ?data@?$MapBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEBAPEBNXZ
_TEXT	SEGMENT
this$ = 8
?data@?$MapBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEBAPEBNXZ PROC ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,1>::data, COMDAT

; 199  :     inline const Scalar* data() const { return this->m_data; }

	mov	rax, QWORD PTR [rcx]
	ret	0
?data@?$MapBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEBAPEBNXZ ENDP ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,1>::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\blasutil.h
;	COMDAT ?extract@?$blas_traits@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@internal@Eigen@@SAAEBV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV43@@Z
_TEXT	SEGMENT
x$ = 8
?extract@?$blas_traits@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@internal@Eigen@@SAAEBV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV43@@Z PROC ; Eigen::internal::blas_traits<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::extract, COMDAT

; 169  :   static inline ExtractType extract(const XprType& x) { return x; }

	mov	rax, rcx
	ret	0
?extract@?$blas_traits@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@@internal@Eigen@@SAAEBV?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@3@AEBV43@@Z ENDP ; Eigen::internal::blas_traits<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0> >::extract
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h
;	COMDAT ?nestedExpression@?$Transpose@$$CBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@XZ
_TEXT	SEGMENT
this$ = 8
?nestedExpression@?$Transpose@$$CBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@XZ PROC ; Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> const >::nestedExpression, COMDAT

; 78   :     nestedExpression() { return m_matrix.const_cast_derived(); }

	mov	rax, QWORD PTR [rcx]
	ret	0
?nestedExpression@?$Transpose@$$CBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAAEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@XZ ENDP ; Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> const >::nestedExpression
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
;	COMDAT ?derived@?$EigenBase@V?$Transpose@$$CBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@Eigen@@QEAAAEAV?$Transpose@$$CBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?derived@?$EigenBase@V?$Transpose@$$CBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@Eigen@@QEAAAEAV?$Transpose@$$CBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@XZ PROC ; Eigen::EigenBase<Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> const > >::derived, COMDAT

; 34   :   Derived& derived() { return *static_cast<Derived*>(this); }

	mov	rax, rcx
	ret	0
?derived@?$EigenBase@V?$Transpose@$$CBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@@Eigen@@QEAAAEAV?$Transpose@$$CBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@2@XZ ENDP ; Eigen::EigenBase<Eigen::Transpose<Eigen::Matrix<double,-1,-1,0,-1,-1> const > >::derived
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
;	COMDAT ??$resizeLike@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAXAEBU?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_other$ = 56
??$resizeLike@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAXAEBU?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z PROC ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,1,0,-1,1> >::resizeLike<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const >,4> >, COMDAT

; 315  :     EIGEN_STRONG_INLINE void resizeLike(const EigenBase<OtherDerived>& _other)

$LN212:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rax, QWORD PTR [rdx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 315  :     EIGEN_STRONG_INLINE void resizeLike(const EigenBase<OtherDerived>& _other)

	mov	rdi, rcx

; 44   :                : (rows > max_index / cols);

	mov	rsi, 9223372036854775807		; 7fffffffffffffffH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rbx, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	test	rbx, rbx
	je	SHORT $LN207@resizeLike
	cmp	rbx, rsi
	setg	al

; 45   :     if (error)

	test	al, al
	jne	SHORT $LN209@resizeLike

; 47   :   }
; 48   : };
; 49   : 
; 50   : template <typename Derived,
; 51   :           typename OtherDerived = Derived,
; 52   :           bool IsVector = bool(Derived::IsVectorAtCompileTime) && bool(OtherDerived::IsVectorAtCompileTime)>
; 53   : struct conservative_resize_like_impl;
; 54   : 
; 55   : template<typename MatrixTypeA, typename MatrixTypeB, bool SwapPointers> struct matrix_swap_impl;
; 56   : 
; 57   : } // end namespace internal
; 58   : 
; 59   : /** \class PlainObjectBase
; 60   :   * \brief %Dense storage base class for matrices and arrays.
; 61   :   *
; 62   :   * This class can be extended with the help of the plugin mechanism described on the page
; 63   :   * \ref TopicCustomizingEigen by defining the preprocessor symbol \c EIGEN_PLAINOBJECTBASE_PLUGIN.
; 64   :   *
; 65   :   * \sa \ref TopicClassHierarchy
; 66   :   */
; 67   : #ifdef EIGEN_PARSED_BY_DOXYGEN
; 68   : namespace internal {
; 69   : 
; 70   : // this is a warkaround to doxygen not being able to understand the inheritence logic
; 71   : // when it is hidden by the dense_xpr_base helper struct.
; 72   : template<typename Derived> struct dense_xpr_base_dispatcher_for_doxygen;// : public MatrixBase<Derived> {};
; 73   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 74   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 75   : struct dense_xpr_base_dispatcher_for_doxygen<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 76   :     : public MatrixBase<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 77   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 78   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 79   : struct dense_xpr_base_dispatcher_for_doxygen<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 80   :     : public ArrayBase<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 81   : 
; 82   : } // namespace internal
; 83   : 
; 84   : template<typename Derived>
; 85   : class PlainObjectBase : public internal::dense_xpr_base_dispatcher_for_doxygen<Derived>
; 86   : #else
; 87   : template<typename Derived>
; 88   : class PlainObjectBase : public internal::dense_xpr_base<Derived>::type
; 89   : #endif
; 90   : {
; 91   :   public:
; 92   :     enum { Options = internal::traits<Derived>::Options };
; 93   :     typedef typename internal::dense_xpr_base<Derived>::type Base;
; 94   : 
; 95   :     typedef typename internal::traits<Derived>::StorageKind StorageKind;
; 96   :     typedef typename internal::traits<Derived>::Index Index;
; 97   :     typedef typename internal::traits<Derived>::Scalar Scalar;
; 98   :     typedef typename internal::packet_traits<Scalar>::type PacketScalar;
; 99   :     typedef typename NumTraits<Scalar>::Real RealScalar;
; 100  :     typedef Derived DenseType;
; 101  : 
; 102  :     using Base::RowsAtCompileTime;
; 103  :     using Base::ColsAtCompileTime;
; 104  :     using Base::SizeAtCompileTime;
; 105  :     using Base::MaxRowsAtCompileTime;
; 106  :     using Base::MaxColsAtCompileTime;
; 107  :     using Base::MaxSizeAtCompileTime;
; 108  :     using Base::IsVectorAtCompileTime;
; 109  :     using Base::Flags;
; 110  : 
; 111  :     template<typename PlainObjectType, int MapOptions, typename StrideType> friend class Eigen::Map;
; 112  :     friend  class Eigen::Map<Derived, Unaligned>;
; 113  :     typedef Eigen::Map<Derived, Unaligned>  MapType;
; 114  :     friend  class Eigen::Map<const Derived, Unaligned>;
; 115  :     typedef const Eigen::Map<const Derived, Unaligned> ConstMapType;
; 116  :     friend  class Eigen::Map<Derived, Aligned>;
; 117  :     typedef Eigen::Map<Derived, Aligned> AlignedMapType;
; 118  :     friend  class Eigen::Map<const Derived, Aligned>;
; 119  :     typedef const Eigen::Map<const Derived, Aligned> ConstAlignedMapType;
; 120  :     template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };
; 121  :     template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };
; 122  :     template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, Aligned, StrideType> type; };
; 123  :     template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, Aligned, StrideType> type; };
; 124  : 
; 125  :   protected:
; 126  :     DenseStorage<Scalar, Base::MaxSizeAtCompileTime, Base::RowsAtCompileTime, Base::ColsAtCompileTime, Options> m_storage;
; 127  : 
; 128  :   public:
; 129  :     enum { NeedsToAlign = SizeAtCompileTime != Dynamic && (internal::traits<Derived>::Flags & AlignedBit) != 0 };
; 130  :     EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(NeedsToAlign)
; 131  : 
; 132  :     Base& base() { return *static_cast<Base*>(this); }
; 133  :     const Base& base() const { return *static_cast<const Base*>(this); }
; 134  : 
; 135  :     EIGEN_STRONG_INLINE Index rows() const { return m_storage.rows(); }
; 136  :     EIGEN_STRONG_INLINE Index cols() const { return m_storage.cols(); }
; 137  : 
; 138  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index rowId, Index colId) const
; 139  :     {
; 140  :       if(Flags & RowMajorBit)
; 141  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 142  :       else // column-major
; 143  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 144  :     }
; 145  : 
; 146  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index index) const
; 147  :     {
; 148  :       return m_storage.data()[index];
; 149  :     }
; 150  : 
; 151  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index rowId, Index colId)
; 152  :     {
; 153  :       if(Flags & RowMajorBit)
; 154  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 155  :       else // column-major
; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 157  :     }
; 158  : 
; 159  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
; 160  :     {
; 161  :       return m_storage.data()[index];
; 162  :     }
; 163  : 
; 164  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
; 165  :     {
; 166  :       if(Flags & RowMajorBit)
; 167  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 168  :       else // column-major
; 169  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 170  :     }
; 171  : 
; 172  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
; 173  :     {
; 174  :       return m_storage.data()[index];
; 175  :     }
; 176  : 
; 177  :     /** \internal */
; 178  :     template<int LoadMode>
; 179  :     EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const
; 180  :     {
; 181  :       return internal::ploadt<PacketScalar, LoadMode>
; 182  :                (m_storage.data() + (Flags & RowMajorBit
; 183  :                                    ? colId + rowId * m_storage.cols()
; 184  :                                    : rowId + colId * m_storage.rows()));
; 185  :     }
; 186  : 
; 187  :     /** \internal */
; 188  :     template<int LoadMode>
; 189  :     EIGEN_STRONG_INLINE PacketScalar packet(Index index) const
; 190  :     {
; 191  :       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);
; 192  :     }
; 193  : 
; 194  :     /** \internal */
; 195  :     template<int StoreMode>
; 196  :     EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)
; 197  :     {
; 198  :       internal::pstoret<Scalar, PacketScalar, StoreMode>
; 199  :               (m_storage.data() + (Flags & RowMajorBit
; 200  :                                    ? colId + rowId * m_storage.cols()
; 201  :                                    : rowId + colId * m_storage.rows()), val);
; 202  :     }
; 203  : 
; 204  :     /** \internal */
; 205  :     template<int StoreMode>
; 206  :     EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
; 207  :     {
; 208  :       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
; 209  :     }
; 210  : 
; 211  :     /** \returns a const pointer to the data array of this matrix */
; 212  :     EIGEN_STRONG_INLINE const Scalar *data() const
; 213  :     { return m_storage.data(); }
; 214  : 
; 215  :     /** \returns a pointer to the data array of this matrix */
; 216  :     EIGEN_STRONG_INLINE Scalar *data()
; 217  :     { return m_storage.data(); }
; 218  : 
; 219  :     /** Resizes \c *this to a \a rows x \a cols matrix.
; 220  :       *
; 221  :       * This method is intended for dynamic-size matrices, although it is legal to call it on any
; 222  :       * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
; 223  :       * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
; 224  :       *
; 225  :       * If the current number of coefficients of \c *this exactly matches the
; 226  :       * product \a rows * \a cols, then no memory allocation is performed and
; 227  :       * the current values are left unchanged. In all other cases, including
; 228  :       * shrinking, the data is reallocated and all previous values are lost.
; 229  :       *
; 230  :       * Example: \include Matrix_resize_int_int.cpp
; 231  :       * Output: \verbinclude Matrix_resize_int_int.out
; 232  :       *
; 233  :       * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
; 234  :       */
; 235  :     EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)
; 236  :     {
; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rbx, rbx
$LN207@resizeLike:
	jns	SHORT $LN126@resizeLike
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	mov	r8d, 241				; 000000f1H
	call	QWORD PTR __imp__wassert
$LN126@resizeLike:

; 44   :                : (rows > max_index / cols);

	test	rbx, rbx
	je	SHORT $LN133@resizeLike
	cmp	rbx, rsi
	setg	al

; 45   :     if (error)

	test	al, al
	jne	SHORT $LN211@resizeLike
$LN133@resizeLike:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 322  :       if(size != m_rows*_Cols)

	cmp	rbx, QWORD PTR [rdi+8]
	je	SHORT $LN138@resizeLike
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR [rdi]
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 325  :         if (size)

	test	rbx, rbx
	je	SHORT $LN139@resizeLike

; 326  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

	mov	rcx, rbx
	call	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
	mov	QWORD PTR [rdi], rax

; 327  :         else

	jmp	SHORT $LN138@resizeLike
$LN139@resizeLike:

; 328  :           m_data = 0;

	mov	QWORD PTR [rdi], 0
$LN138@resizeLike:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 331  :     }

	mov	rsi, QWORD PTR [rsp+56]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 331  :       m_rows = nbRows;

	mov	QWORD PTR [rdi+8], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 331  :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN209@resizeLike:

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN211@resizeLike:
	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN206@resizeLike:
??$resizeLike@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAXAEBU?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@$$CBV?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z ENDP ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,1,0,-1,1> >::resizeLike<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> const > const > const >,4> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
;	COMDAT ??$resizeLike@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAXAEBU?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_other$ = 56
??$resizeLike@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAXAEBU?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z PROC ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,1,0,-1,1> >::resizeLike<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4> >, COMDAT

; 315  :     EIGEN_STRONG_INLINE void resizeLike(const EigenBase<OtherDerived>& _other)

$LN212:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rax, QWORD PTR [rdx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 315  :     EIGEN_STRONG_INLINE void resizeLike(const EigenBase<OtherDerived>& _other)

	mov	rdi, rcx

; 44   :                : (rows > max_index / cols);

	mov	rsi, 9223372036854775807		; 7fffffffffffffffH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rbx, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	test	rbx, rbx
	je	SHORT $LN207@resizeLike
	cmp	rbx, rsi
	setg	al

; 45   :     if (error)

	test	al, al
	jne	SHORT $LN209@resizeLike

; 47   :   }
; 48   : };
; 49   : 
; 50   : template <typename Derived,
; 51   :           typename OtherDerived = Derived,
; 52   :           bool IsVector = bool(Derived::IsVectorAtCompileTime) && bool(OtherDerived::IsVectorAtCompileTime)>
; 53   : struct conservative_resize_like_impl;
; 54   : 
; 55   : template<typename MatrixTypeA, typename MatrixTypeB, bool SwapPointers> struct matrix_swap_impl;
; 56   : 
; 57   : } // end namespace internal
; 58   : 
; 59   : /** \class PlainObjectBase
; 60   :   * \brief %Dense storage base class for matrices and arrays.
; 61   :   *
; 62   :   * This class can be extended with the help of the plugin mechanism described on the page
; 63   :   * \ref TopicCustomizingEigen by defining the preprocessor symbol \c EIGEN_PLAINOBJECTBASE_PLUGIN.
; 64   :   *
; 65   :   * \sa \ref TopicClassHierarchy
; 66   :   */
; 67   : #ifdef EIGEN_PARSED_BY_DOXYGEN
; 68   : namespace internal {
; 69   : 
; 70   : // this is a warkaround to doxygen not being able to understand the inheritence logic
; 71   : // when it is hidden by the dense_xpr_base helper struct.
; 72   : template<typename Derived> struct dense_xpr_base_dispatcher_for_doxygen;// : public MatrixBase<Derived> {};
; 73   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 74   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 75   : struct dense_xpr_base_dispatcher_for_doxygen<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 76   :     : public MatrixBase<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 77   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 78   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 79   : struct dense_xpr_base_dispatcher_for_doxygen<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 80   :     : public ArrayBase<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 81   : 
; 82   : } // namespace internal
; 83   : 
; 84   : template<typename Derived>
; 85   : class PlainObjectBase : public internal::dense_xpr_base_dispatcher_for_doxygen<Derived>
; 86   : #else
; 87   : template<typename Derived>
; 88   : class PlainObjectBase : public internal::dense_xpr_base<Derived>::type
; 89   : #endif
; 90   : {
; 91   :   public:
; 92   :     enum { Options = internal::traits<Derived>::Options };
; 93   :     typedef typename internal::dense_xpr_base<Derived>::type Base;
; 94   : 
; 95   :     typedef typename internal::traits<Derived>::StorageKind StorageKind;
; 96   :     typedef typename internal::traits<Derived>::Index Index;
; 97   :     typedef typename internal::traits<Derived>::Scalar Scalar;
; 98   :     typedef typename internal::packet_traits<Scalar>::type PacketScalar;
; 99   :     typedef typename NumTraits<Scalar>::Real RealScalar;
; 100  :     typedef Derived DenseType;
; 101  : 
; 102  :     using Base::RowsAtCompileTime;
; 103  :     using Base::ColsAtCompileTime;
; 104  :     using Base::SizeAtCompileTime;
; 105  :     using Base::MaxRowsAtCompileTime;
; 106  :     using Base::MaxColsAtCompileTime;
; 107  :     using Base::MaxSizeAtCompileTime;
; 108  :     using Base::IsVectorAtCompileTime;
; 109  :     using Base::Flags;
; 110  : 
; 111  :     template<typename PlainObjectType, int MapOptions, typename StrideType> friend class Eigen::Map;
; 112  :     friend  class Eigen::Map<Derived, Unaligned>;
; 113  :     typedef Eigen::Map<Derived, Unaligned>  MapType;
; 114  :     friend  class Eigen::Map<const Derived, Unaligned>;
; 115  :     typedef const Eigen::Map<const Derived, Unaligned> ConstMapType;
; 116  :     friend  class Eigen::Map<Derived, Aligned>;
; 117  :     typedef Eigen::Map<Derived, Aligned> AlignedMapType;
; 118  :     friend  class Eigen::Map<const Derived, Aligned>;
; 119  :     typedef const Eigen::Map<const Derived, Aligned> ConstAlignedMapType;
; 120  :     template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };
; 121  :     template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };
; 122  :     template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, Aligned, StrideType> type; };
; 123  :     template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, Aligned, StrideType> type; };
; 124  : 
; 125  :   protected:
; 126  :     DenseStorage<Scalar, Base::MaxSizeAtCompileTime, Base::RowsAtCompileTime, Base::ColsAtCompileTime, Options> m_storage;
; 127  : 
; 128  :   public:
; 129  :     enum { NeedsToAlign = SizeAtCompileTime != Dynamic && (internal::traits<Derived>::Flags & AlignedBit) != 0 };
; 130  :     EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(NeedsToAlign)
; 131  : 
; 132  :     Base& base() { return *static_cast<Base*>(this); }
; 133  :     const Base& base() const { return *static_cast<const Base*>(this); }
; 134  : 
; 135  :     EIGEN_STRONG_INLINE Index rows() const { return m_storage.rows(); }
; 136  :     EIGEN_STRONG_INLINE Index cols() const { return m_storage.cols(); }
; 137  : 
; 138  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index rowId, Index colId) const
; 139  :     {
; 140  :       if(Flags & RowMajorBit)
; 141  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 142  :       else // column-major
; 143  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 144  :     }
; 145  : 
; 146  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index index) const
; 147  :     {
; 148  :       return m_storage.data()[index];
; 149  :     }
; 150  : 
; 151  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index rowId, Index colId)
; 152  :     {
; 153  :       if(Flags & RowMajorBit)
; 154  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 155  :       else // column-major
; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 157  :     }
; 158  : 
; 159  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
; 160  :     {
; 161  :       return m_storage.data()[index];
; 162  :     }
; 163  : 
; 164  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
; 165  :     {
; 166  :       if(Flags & RowMajorBit)
; 167  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 168  :       else // column-major
; 169  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 170  :     }
; 171  : 
; 172  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
; 173  :     {
; 174  :       return m_storage.data()[index];
; 175  :     }
; 176  : 
; 177  :     /** \internal */
; 178  :     template<int LoadMode>
; 179  :     EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const
; 180  :     {
; 181  :       return internal::ploadt<PacketScalar, LoadMode>
; 182  :                (m_storage.data() + (Flags & RowMajorBit
; 183  :                                    ? colId + rowId * m_storage.cols()
; 184  :                                    : rowId + colId * m_storage.rows()));
; 185  :     }
; 186  : 
; 187  :     /** \internal */
; 188  :     template<int LoadMode>
; 189  :     EIGEN_STRONG_INLINE PacketScalar packet(Index index) const
; 190  :     {
; 191  :       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);
; 192  :     }
; 193  : 
; 194  :     /** \internal */
; 195  :     template<int StoreMode>
; 196  :     EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)
; 197  :     {
; 198  :       internal::pstoret<Scalar, PacketScalar, StoreMode>
; 199  :               (m_storage.data() + (Flags & RowMajorBit
; 200  :                                    ? colId + rowId * m_storage.cols()
; 201  :                                    : rowId + colId * m_storage.rows()), val);
; 202  :     }
; 203  : 
; 204  :     /** \internal */
; 205  :     template<int StoreMode>
; 206  :     EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
; 207  :     {
; 208  :       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
; 209  :     }
; 210  : 
; 211  :     /** \returns a const pointer to the data array of this matrix */
; 212  :     EIGEN_STRONG_INLINE const Scalar *data() const
; 213  :     { return m_storage.data(); }
; 214  : 
; 215  :     /** \returns a pointer to the data array of this matrix */
; 216  :     EIGEN_STRONG_INLINE Scalar *data()
; 217  :     { return m_storage.data(); }
; 218  : 
; 219  :     /** Resizes \c *this to a \a rows x \a cols matrix.
; 220  :       *
; 221  :       * This method is intended for dynamic-size matrices, although it is legal to call it on any
; 222  :       * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
; 223  :       * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
; 224  :       *
; 225  :       * If the current number of coefficients of \c *this exactly matches the
; 226  :       * product \a rows * \a cols, then no memory allocation is performed and
; 227  :       * the current values are left unchanged. In all other cases, including
; 228  :       * shrinking, the data is reallocated and all previous values are lost.
; 229  :       *
; 230  :       * Example: \include Matrix_resize_int_int.cpp
; 231  :       * Output: \verbinclude Matrix_resize_int_int.out
; 232  :       *
; 233  :       * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
; 234  :       */
; 235  :     EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)
; 236  :     {
; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rbx, rbx
$LN207@resizeLike:
	jns	SHORT $LN126@resizeLike
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	mov	r8d, 241				; 000000f1H
	call	QWORD PTR __imp__wassert
$LN126@resizeLike:

; 44   :                : (rows > max_index / cols);

	test	rbx, rbx
	je	SHORT $LN133@resizeLike
	cmp	rbx, rsi
	setg	al

; 45   :     if (error)

	test	al, al
	jne	SHORT $LN211@resizeLike
$LN133@resizeLike:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 322  :       if(size != m_rows*_Cols)

	cmp	rbx, QWORD PTR [rdi+8]
	je	SHORT $LN138@resizeLike
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR [rdi]
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 325  :         if (size)

	test	rbx, rbx
	je	SHORT $LN139@resizeLike

; 326  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

	mov	rcx, rbx
	call	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
	mov	QWORD PTR [rdi], rax

; 327  :         else

	jmp	SHORT $LN138@resizeLike
$LN139@resizeLike:

; 328  :           m_data = 0;

	mov	QWORD PTR [rdi], 0
$LN138@resizeLike:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 331  :     }

	mov	rsi, QWORD PTR [rsp+56]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 331  :       m_rows = nbRows;

	mov	QWORD PTR [rdi+8], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 331  :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN209@resizeLike:

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN211@resizeLike:
	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN206@resizeLike:
??$resizeLike@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAAXAEBU?$EigenBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@@1@@Z ENDP ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,1,0,-1,1> >::resizeLike<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwisenullaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\generalproduct.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\generalproduct.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h
;	COMDAT ??$evalTo@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEBAXAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$ = 112
dst$ = 120
??$evalTo@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEBAXAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@@Z PROC ; Eigen::ProductBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >::evalTo<Eigen::Matrix<double,-1,1,0,-1,1> >, COMDAT

; 109  :     inline void evalTo(Dest& dst) const { dst.setZero(); scaleAndAddTo(dst,Scalar(1)); }

$LN417:
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 80					; 00000050H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 313  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rsi, QWORD PTR [rdx+8]
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h

; 109  :     inline void evalTo(Dest& dst) const { dst.setZero(); scaleAndAddTo(dst,Scalar(1)); }

	mov	rdi, rdx
	mov	r14, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\xprhelper.h

; 63   :     explicit variable_if_dynamic(T value) : m_value(value) {}

	mov	QWORD PTR $T2[rsp+8], rsi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h

; 517  :   EIGEN_STRONG_INLINE scalar_constant_op(const scalar_constant_op& other) : m_other(other.m_other) { }

	movsdx	QWORD PTR $T2[rsp+24], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\cwisenullaryop.h

; 60   :       eigen_assert(nbRows >= 0

	test	rsi, rsi
	jns	SHORT $LN34@evalTo
	lea	rdx, OFFSET FLAT:??_C@_1LO@HNEDKPLG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1BDK@EFDGPJJE@?$AAn?$AAb?$AAR?$AAo?$AAw?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm@
	mov	r8d, 63					; 0000003fH
	call	QWORD PTR __imp__wassert
$LN34@evalTo:
	mov	QWORD PTR [rsp+128], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	test	rsi, rsi
	je	SHORT $LN172@evalTo
	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	rsi, rax
	setg	bl

; 45   :     if (error)

	test	bl, bl
	jne	$LN414@evalTo

; 47   :   }
; 48   : };
; 49   : 
; 50   : template <typename Derived,
; 51   :           typename OtherDerived = Derived,
; 52   :           bool IsVector = bool(Derived::IsVectorAtCompileTime) && bool(OtherDerived::IsVectorAtCompileTime)>
; 53   : struct conservative_resize_like_impl;
; 54   : 
; 55   : template<typename MatrixTypeA, typename MatrixTypeB, bool SwapPointers> struct matrix_swap_impl;
; 56   : 
; 57   : } // end namespace internal
; 58   : 
; 59   : /** \class PlainObjectBase
; 60   :   * \brief %Dense storage base class for matrices and arrays.
; 61   :   *
; 62   :   * This class can be extended with the help of the plugin mechanism described on the page
; 63   :   * \ref TopicCustomizingEigen by defining the preprocessor symbol \c EIGEN_PLAINOBJECTBASE_PLUGIN.
; 64   :   *
; 65   :   * \sa \ref TopicClassHierarchy
; 66   :   */
; 67   : #ifdef EIGEN_PARSED_BY_DOXYGEN
; 68   : namespace internal {
; 69   : 
; 70   : // this is a warkaround to doxygen not being able to understand the inheritence logic
; 71   : // when it is hidden by the dense_xpr_base helper struct.
; 72   : template<typename Derived> struct dense_xpr_base_dispatcher_for_doxygen;// : public MatrixBase<Derived> {};
; 73   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 74   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 75   : struct dense_xpr_base_dispatcher_for_doxygen<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 76   :     : public MatrixBase<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 77   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 78   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 79   : struct dense_xpr_base_dispatcher_for_doxygen<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 80   :     : public ArrayBase<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 81   : 
; 82   : } // namespace internal
; 83   : 
; 84   : template<typename Derived>
; 85   : class PlainObjectBase : public internal::dense_xpr_base_dispatcher_for_doxygen<Derived>
; 86   : #else
; 87   : template<typename Derived>
; 88   : class PlainObjectBase : public internal::dense_xpr_base<Derived>::type
; 89   : #endif
; 90   : {
; 91   :   public:
; 92   :     enum { Options = internal::traits<Derived>::Options };
; 93   :     typedef typename internal::dense_xpr_base<Derived>::type Base;
; 94   : 
; 95   :     typedef typename internal::traits<Derived>::StorageKind StorageKind;
; 96   :     typedef typename internal::traits<Derived>::Index Index;
; 97   :     typedef typename internal::traits<Derived>::Scalar Scalar;
; 98   :     typedef typename internal::packet_traits<Scalar>::type PacketScalar;
; 99   :     typedef typename NumTraits<Scalar>::Real RealScalar;
; 100  :     typedef Derived DenseType;
; 101  : 
; 102  :     using Base::RowsAtCompileTime;
; 103  :     using Base::ColsAtCompileTime;
; 104  :     using Base::SizeAtCompileTime;
; 105  :     using Base::MaxRowsAtCompileTime;
; 106  :     using Base::MaxColsAtCompileTime;
; 107  :     using Base::MaxSizeAtCompileTime;
; 108  :     using Base::IsVectorAtCompileTime;
; 109  :     using Base::Flags;
; 110  : 
; 111  :     template<typename PlainObjectType, int MapOptions, typename StrideType> friend class Eigen::Map;
; 112  :     friend  class Eigen::Map<Derived, Unaligned>;
; 113  :     typedef Eigen::Map<Derived, Unaligned>  MapType;
; 114  :     friend  class Eigen::Map<const Derived, Unaligned>;
; 115  :     typedef const Eigen::Map<const Derived, Unaligned> ConstMapType;
; 116  :     friend  class Eigen::Map<Derived, Aligned>;
; 117  :     typedef Eigen::Map<Derived, Aligned> AlignedMapType;
; 118  :     friend  class Eigen::Map<const Derived, Aligned>;
; 119  :     typedef const Eigen::Map<const Derived, Aligned> ConstAlignedMapType;
; 120  :     template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };
; 121  :     template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };
; 122  :     template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, Aligned, StrideType> type; };
; 123  :     template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, Aligned, StrideType> type; };
; 124  : 
; 125  :   protected:
; 126  :     DenseStorage<Scalar, Base::MaxSizeAtCompileTime, Base::RowsAtCompileTime, Base::ColsAtCompileTime, Options> m_storage;
; 127  : 
; 128  :   public:
; 129  :     enum { NeedsToAlign = SizeAtCompileTime != Dynamic && (internal::traits<Derived>::Flags & AlignedBit) != 0 };
; 130  :     EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(NeedsToAlign)
; 131  : 
; 132  :     Base& base() { return *static_cast<Base*>(this); }
; 133  :     const Base& base() const { return *static_cast<const Base*>(this); }
; 134  : 
; 135  :     EIGEN_STRONG_INLINE Index rows() const { return m_storage.rows(); }
; 136  :     EIGEN_STRONG_INLINE Index cols() const { return m_storage.cols(); }
; 137  : 
; 138  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index rowId, Index colId) const
; 139  :     {
; 140  :       if(Flags & RowMajorBit)
; 141  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 142  :       else // column-major
; 143  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 144  :     }
; 145  : 
; 146  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index index) const
; 147  :     {
; 148  :       return m_storage.data()[index];
; 149  :     }
; 150  : 
; 151  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index rowId, Index colId)
; 152  :     {
; 153  :       if(Flags & RowMajorBit)
; 154  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 155  :       else // column-major
; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 157  :     }
; 158  : 
; 159  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
; 160  :     {
; 161  :       return m_storage.data()[index];
; 162  :     }
; 163  : 
; 164  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
; 165  :     {
; 166  :       if(Flags & RowMajorBit)
; 167  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 168  :       else // column-major
; 169  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 170  :     }
; 171  : 
; 172  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
; 173  :     {
; 174  :       return m_storage.data()[index];
; 175  :     }
; 176  : 
; 177  :     /** \internal */
; 178  :     template<int LoadMode>
; 179  :     EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const
; 180  :     {
; 181  :       return internal::ploadt<PacketScalar, LoadMode>
; 182  :                (m_storage.data() + (Flags & RowMajorBit
; 183  :                                    ? colId + rowId * m_storage.cols()
; 184  :                                    : rowId + colId * m_storage.rows()));
; 185  :     }
; 186  : 
; 187  :     /** \internal */
; 188  :     template<int LoadMode>
; 189  :     EIGEN_STRONG_INLINE PacketScalar packet(Index index) const
; 190  :     {
; 191  :       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);
; 192  :     }
; 193  : 
; 194  :     /** \internal */
; 195  :     template<int StoreMode>
; 196  :     EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)
; 197  :     {
; 198  :       internal::pstoret<Scalar, PacketScalar, StoreMode>
; 199  :               (m_storage.data() + (Flags & RowMajorBit
; 200  :                                    ? colId + rowId * m_storage.cols()
; 201  :                                    : rowId + colId * m_storage.rows()), val);
; 202  :     }
; 203  : 
; 204  :     /** \internal */
; 205  :     template<int StoreMode>
; 206  :     EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
; 207  :     {
; 208  :       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
; 209  :     }
; 210  : 
; 211  :     /** \returns a const pointer to the data array of this matrix */
; 212  :     EIGEN_STRONG_INLINE const Scalar *data() const
; 213  :     { return m_storage.data(); }
; 214  : 
; 215  :     /** \returns a pointer to the data array of this matrix */
; 216  :     EIGEN_STRONG_INLINE Scalar *data()
; 217  :     { return m_storage.data(); }
; 218  : 
; 219  :     /** Resizes \c *this to a \a rows x \a cols matrix.
; 220  :       *
; 221  :       * This method is intended for dynamic-size matrices, although it is legal to call it on any
; 222  :       * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
; 223  :       * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
; 224  :       *
; 225  :       * If the current number of coefficients of \c *this exactly matches the
; 226  :       * product \a rows * \a cols, then no memory allocation is performed and
; 227  :       * the current values are left unchanged. In all other cases, including
; 228  :       * shrinking, the data is reallocated and all previous values are lost.
; 229  :       *
; 230  :       * Example: \include Matrix_resize_int_int.cpp
; 231  :       * Output: \verbinclude Matrix_resize_int_int.out
; 232  :       *
; 233  :       * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
; 234  :       */
; 235  :     EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)
; 236  :     {
; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rsi, rsi
	jns	SHORT $LN165@evalTo
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	mov	r8d, 241				; 000000f1H
	call	QWORD PTR __imp__wassert
$LN165@evalTo:

; 45   :     if (error)

	test	bl, bl
	jne	$LN416@evalTo
$LN172@evalTo:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 322  :       if(size != m_rows*_Cols)

	xor	ebx, ebx
	cmp	rsi, QWORD PTR [rdi+8]
	je	SHORT $LN177@evalTo
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR [rdi]
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 325  :         if (size)

	test	rsi, rsi
	je	SHORT $LN178@evalTo

; 326  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

	mov	rcx, rsi
	call	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
	mov	QWORD PTR [rdi], rax

; 327  :         else

	jmp	SHORT $LN177@evalTo
$LN178@evalTo:

; 328  :           m_data = 0;

	mov	QWORD PTR [rdi], rbx
$LN177@evalTo:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 404  :     const Index alignedEnd = alignedStart + ((size-alignedStart)/packetSize)*packetSize;

	mov	rax, rsi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 331  :       m_rows = nbRows;

	mov	QWORD PTR [rdi+8], rsi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 404  :     const Index alignedEnd = alignedStart + ((size-alignedStart)/packetSize)*packetSize;

	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r8, rax
	add	r8, r8

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	test	r8, r8
	jle	SHORT $LN287@evalTo
	xorps	xmm0, xmm0
	npad	1
$LL289@evalTo:
	mov	rax, QWORD PTR [rdi]
	add	rbx, 2
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [rax+rbx*8-16], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	cmp	rbx, r8
	jl	SHORT $LL289@evalTo
$LN287@evalTo:

; 409  :     {
; 410  :       dst.template copyPacket<Derived2, dstAlignment, srcAlignment>(index, src);
; 411  :     }
; 412  : 
; 413  :     unaligned_assign_impl<>::run(src,dst,alignedEnd,size);

	lea	rcx, QWORD PTR $T2[rsp]
	mov	r9, rsi
	mov	rdx, rdi
	call	??$run@V?$CwiseNullaryOp@U?$scalar_constant_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@?$unaligned_assign_impl@$0A@@internal@Eigen@@SAXAEBV?$CwiseNullaryOp@U?$scalar_constant_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@@2@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@_J2@Z ; Eigen::internal::unaligned_assign_impl<0>::run<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>,Eigen::Matrix<double,-1,1,0,-1,1> >,Eigen::Matrix<double,-1,1,0,-1,1> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\generalproduct.h

; 347  :       eigen_assert(m_lhs.rows() == dst.rows() && m_rhs.cols() == dst.cols());

	mov	r8, QWORD PTR [r14]
	mov	rax, QWORD PTR [rdi+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h

; 109  :     inline void evalTo(Dest& dst) const { dst.setZero(); scaleAndAddTo(dst,Scalar(1)); }

	movsdx	xmm0, QWORD PTR __real@3ff0000000000000
	movsdx	QWORD PTR $T1[rsp], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\generalproduct.h

; 347  :       eigen_assert(m_lhs.rows() == dst.rows() && m_rhs.cols() == dst.cols());

	cmp	QWORD PTR [r8+8], rax
	je	SHORT $LN377@evalTo
	lea	rdx, OFFSET FLAT:??_C@_1LO@HNIIIKFI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1HC@EELIINB@?$AAm?$AA_?$AAl?$AAh?$AAs?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAd?$AAs?$AAt?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAm?$AA_@
	mov	r8d, 347				; 0000015bH
	call	QWORD PTR __imp__wassert
$LN377@evalTo:

; 348  :       internal::gemv_selector<Side,(int(MatrixType::Flags)&RowMajorBit) ? RowMajor : ColMajor,
; 349  :                        bool(internal::blas_traits<MatrixType>::HasUsableDirectAccess)>::run(*this, dst, alpha);

	lea	r8, QWORD PTR $T1[rsp]
	mov	rdx, rdi
	mov	rcx, r14
	call	??$run@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@?$gemv_selector@$01$0A@$00@internal@Eigen@@SAXAEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEBN@Z ; Eigen::internal::gemv_selector<2,0,1>::run<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,1,0,-1,1> >
	mov	rbx, QWORD PTR [rsp+128]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h

; 109  :     inline void evalTo(Dest& dst) const { dst.setZero(); scaleAndAddTo(dst,Scalar(1)); }

	add	rsp, 80					; 00000050H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN414@evalTo:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN416@evalTo:
	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN412@evalTo:
??$evalTo@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEBAXAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@@Z ENDP ; Eigen::ProductBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >::evalTo<Eigen::Matrix<double,-1,1,0,-1,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
;	COMDAT ??$resizeLike@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAXAEBU?$EigenBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_other$ = 56
??$resizeLike@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAXAEBU?$EigenBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z PROC ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::resizeLike<Eigen::Matrix<double,-1,1,0,-1,1> >, COMDAT

; 315  :     EIGEN_STRONG_INLINE void resizeLike(const EigenBase<OtherDerived>& _other)

$LN159:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 313  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rbx, QWORD PTR [rdx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 315  :     EIGEN_STRONG_INLINE void resizeLike(const EigenBase<OtherDerived>& _other)

	mov	rdi, rcx

; 44   :                : (rows > max_index / cols);

	mov	rsi, 9223372036854775807		; 7fffffffffffffffH
	test	rbx, rbx
	je	SHORT $LN154@resizeLike
	cmp	rbx, rsi
	setg	al

; 45   :     if (error)

	test	al, al
	jne	SHORT $LN156@resizeLike

; 47   :   }
; 48   : };
; 49   : 
; 50   : template <typename Derived,
; 51   :           typename OtherDerived = Derived,
; 52   :           bool IsVector = bool(Derived::IsVectorAtCompileTime) && bool(OtherDerived::IsVectorAtCompileTime)>
; 53   : struct conservative_resize_like_impl;
; 54   : 
; 55   : template<typename MatrixTypeA, typename MatrixTypeB, bool SwapPointers> struct matrix_swap_impl;
; 56   : 
; 57   : } // end namespace internal
; 58   : 
; 59   : /** \class PlainObjectBase
; 60   :   * \brief %Dense storage base class for matrices and arrays.
; 61   :   *
; 62   :   * This class can be extended with the help of the plugin mechanism described on the page
; 63   :   * \ref TopicCustomizingEigen by defining the preprocessor symbol \c EIGEN_PLAINOBJECTBASE_PLUGIN.
; 64   :   *
; 65   :   * \sa \ref TopicClassHierarchy
; 66   :   */
; 67   : #ifdef EIGEN_PARSED_BY_DOXYGEN
; 68   : namespace internal {
; 69   : 
; 70   : // this is a warkaround to doxygen not being able to understand the inheritence logic
; 71   : // when it is hidden by the dense_xpr_base helper struct.
; 72   : template<typename Derived> struct dense_xpr_base_dispatcher_for_doxygen;// : public MatrixBase<Derived> {};
; 73   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 74   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 75   : struct dense_xpr_base_dispatcher_for_doxygen<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 76   :     : public MatrixBase<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 77   : /** This class is just a workaround for Doxygen and it does not not actually exist. */
; 78   : template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
; 79   : struct dense_xpr_base_dispatcher_for_doxygen<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
; 80   :     : public ArrayBase<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > {};
; 81   : 
; 82   : } // namespace internal
; 83   : 
; 84   : template<typename Derived>
; 85   : class PlainObjectBase : public internal::dense_xpr_base_dispatcher_for_doxygen<Derived>
; 86   : #else
; 87   : template<typename Derived>
; 88   : class PlainObjectBase : public internal::dense_xpr_base<Derived>::type
; 89   : #endif
; 90   : {
; 91   :   public:
; 92   :     enum { Options = internal::traits<Derived>::Options };
; 93   :     typedef typename internal::dense_xpr_base<Derived>::type Base;
; 94   : 
; 95   :     typedef typename internal::traits<Derived>::StorageKind StorageKind;
; 96   :     typedef typename internal::traits<Derived>::Index Index;
; 97   :     typedef typename internal::traits<Derived>::Scalar Scalar;
; 98   :     typedef typename internal::packet_traits<Scalar>::type PacketScalar;
; 99   :     typedef typename NumTraits<Scalar>::Real RealScalar;
; 100  :     typedef Derived DenseType;
; 101  : 
; 102  :     using Base::RowsAtCompileTime;
; 103  :     using Base::ColsAtCompileTime;
; 104  :     using Base::SizeAtCompileTime;
; 105  :     using Base::MaxRowsAtCompileTime;
; 106  :     using Base::MaxColsAtCompileTime;
; 107  :     using Base::MaxSizeAtCompileTime;
; 108  :     using Base::IsVectorAtCompileTime;
; 109  :     using Base::Flags;
; 110  : 
; 111  :     template<typename PlainObjectType, int MapOptions, typename StrideType> friend class Eigen::Map;
; 112  :     friend  class Eigen::Map<Derived, Unaligned>;
; 113  :     typedef Eigen::Map<Derived, Unaligned>  MapType;
; 114  :     friend  class Eigen::Map<const Derived, Unaligned>;
; 115  :     typedef const Eigen::Map<const Derived, Unaligned> ConstMapType;
; 116  :     friend  class Eigen::Map<Derived, Aligned>;
; 117  :     typedef Eigen::Map<Derived, Aligned> AlignedMapType;
; 118  :     friend  class Eigen::Map<const Derived, Aligned>;
; 119  :     typedef const Eigen::Map<const Derived, Aligned> ConstAlignedMapType;
; 120  :     template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };
; 121  :     template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };
; 122  :     template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, Aligned, StrideType> type; };
; 123  :     template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, Aligned, StrideType> type; };
; 124  : 
; 125  :   protected:
; 126  :     DenseStorage<Scalar, Base::MaxSizeAtCompileTime, Base::RowsAtCompileTime, Base::ColsAtCompileTime, Options> m_storage;
; 127  : 
; 128  :   public:
; 129  :     enum { NeedsToAlign = SizeAtCompileTime != Dynamic && (internal::traits<Derived>::Flags & AlignedBit) != 0 };
; 130  :     EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(NeedsToAlign)
; 131  : 
; 132  :     Base& base() { return *static_cast<Base*>(this); }
; 133  :     const Base& base() const { return *static_cast<const Base*>(this); }
; 134  : 
; 135  :     EIGEN_STRONG_INLINE Index rows() const { return m_storage.rows(); }
; 136  :     EIGEN_STRONG_INLINE Index cols() const { return m_storage.cols(); }
; 137  : 
; 138  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index rowId, Index colId) const
; 139  :     {
; 140  :       if(Flags & RowMajorBit)
; 141  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 142  :       else // column-major
; 143  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 144  :     }
; 145  : 
; 146  :     EIGEN_STRONG_INLINE const Scalar& coeff(Index index) const
; 147  :     {
; 148  :       return m_storage.data()[index];
; 149  :     }
; 150  : 
; 151  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index rowId, Index colId)
; 152  :     {
; 153  :       if(Flags & RowMajorBit)
; 154  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 155  :       else // column-major
; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 157  :     }
; 158  : 
; 159  :     EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
; 160  :     {
; 161  :       return m_storage.data()[index];
; 162  :     }
; 163  : 
; 164  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
; 165  :     {
; 166  :       if(Flags & RowMajorBit)
; 167  :         return m_storage.data()[colId + rowId * m_storage.cols()];
; 168  :       else // column-major
; 169  :         return m_storage.data()[rowId + colId * m_storage.rows()];
; 170  :     }
; 171  : 
; 172  :     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
; 173  :     {
; 174  :       return m_storage.data()[index];
; 175  :     }
; 176  : 
; 177  :     /** \internal */
; 178  :     template<int LoadMode>
; 179  :     EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const
; 180  :     {
; 181  :       return internal::ploadt<PacketScalar, LoadMode>
; 182  :                (m_storage.data() + (Flags & RowMajorBit
; 183  :                                    ? colId + rowId * m_storage.cols()
; 184  :                                    : rowId + colId * m_storage.rows()));
; 185  :     }
; 186  : 
; 187  :     /** \internal */
; 188  :     template<int LoadMode>
; 189  :     EIGEN_STRONG_INLINE PacketScalar packet(Index index) const
; 190  :     {
; 191  :       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);
; 192  :     }
; 193  : 
; 194  :     /** \internal */
; 195  :     template<int StoreMode>
; 196  :     EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)
; 197  :     {
; 198  :       internal::pstoret<Scalar, PacketScalar, StoreMode>
; 199  :               (m_storage.data() + (Flags & RowMajorBit
; 200  :                                    ? colId + rowId * m_storage.cols()
; 201  :                                    : rowId + colId * m_storage.rows()), val);
; 202  :     }
; 203  : 
; 204  :     /** \internal */
; 205  :     template<int StoreMode>
; 206  :     EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
; 207  :     {
; 208  :       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
; 209  :     }
; 210  : 
; 211  :     /** \returns a const pointer to the data array of this matrix */
; 212  :     EIGEN_STRONG_INLINE const Scalar *data() const
; 213  :     { return m_storage.data(); }
; 214  : 
; 215  :     /** \returns a pointer to the data array of this matrix */
; 216  :     EIGEN_STRONG_INLINE Scalar *data()
; 217  :     { return m_storage.data(); }
; 218  : 
; 219  :     /** Resizes \c *this to a \a rows x \a cols matrix.
; 220  :       *
; 221  :       * This method is intended for dynamic-size matrices, although it is legal to call it on any
; 222  :       * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
; 223  :       * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
; 224  :       *
; 225  :       * If the current number of coefficients of \c *this exactly matches the
; 226  :       * product \a rows * \a cols, then no memory allocation is performed and
; 227  :       * the current values are left unchanged. In all other cases, including
; 228  :       * shrinking, the data is reallocated and all previous values are lost.
; 229  :       *
; 230  :       * Example: \include Matrix_resize_int_int.cpp
; 231  :       * Output: \verbinclude Matrix_resize_int_int.out
; 232  :       *
; 233  :       * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
; 234  :       */
; 235  :     EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)
; 236  :     {
; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rbx, rbx
$LN154@resizeLike:
	jns	SHORT $LN124@resizeLike
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	mov	r8d, 241				; 000000f1H
	call	QWORD PTR __imp__wassert
$LN124@resizeLike:

; 44   :                : (rows > max_index / cols);

	test	rbx, rbx
	je	SHORT $LN131@resizeLike
	cmp	rbx, rsi
	setg	al

; 45   :     if (error)

	test	al, al
	jne	SHORT $LN158@resizeLike
$LN131@resizeLike:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 249  :       if(size != m_rows*m_cols)

	mov	rax, QWORD PTR [rdi+16]
	imul	rax, QWORD PTR [rdi+8]
	cmp	rbx, rax
	je	SHORT $LN136@resizeLike
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, QWORD PTR [rdi]
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 252  :         if (size)

	test	rbx, rbx
	je	SHORT $LN137@resizeLike

; 253  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

	mov	rcx, rbx
	call	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
	mov	QWORD PTR [rdi], rax

; 254  :         else

	jmp	SHORT $LN136@resizeLike
$LN137@resizeLike:

; 255  :           m_data = 0;

	mov	QWORD PTR [rdi], 0
$LN136@resizeLike:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 331  :     }

	mov	rsi, QWORD PTR [rsp+56]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 258  :       m_rows = nbRows;

	mov	QWORD PTR [rdi+8], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 331  :     }

	mov	rbx, QWORD PTR [rsp+48]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 259  :       m_cols = nbCols;

	mov	QWORD PTR [rdi+16], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 331  :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN156@resizeLike:

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN158@resizeLike:
	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN153@resizeLike:
??$resizeLike@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEAAXAEBU?$EigenBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z ENDP ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::resizeLike<Eigen::Matrix<double,-1,1,0,-1,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h
;	COMDAT ??$checkTransposeAliasing@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEBAXAEBV?$Matrix@N$0?0$00$0A@$0?0$00@1@@Z
_TEXT	SEGMENT
this$dead$ = 8
other$dead$ = 16
??$checkTransposeAliasing@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEBAXAEBV?$Matrix@N$0?0$00$0A@$0?0$00@1@@Z PROC ; Eigen::DenseBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::checkTransposeAliasing<Eigen::Matrix<double,-1,1,0,-1,1> >, COMDAT

; 413  :     internal::checkTransposeAliasing_impl<Derived, OtherDerived>::run(derived(), other);
; 414  : }

	ret	0
??$checkTransposeAliasing@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$DenseBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@IEBAXAEBV?$Matrix@N$0?0$00$0A@$0?0$00@1@@Z ENDP ; Eigen::DenseBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::checkTransposeAliasing<Eigen::Matrix<double,-1,1,0,-1,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
;	COMDAT ??$packet@$0A@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEBA?AU__m128d@@_J0@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
rowId$ = 24
colId$ = 32
??$packet@$0A@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEBA?AU__m128d@@_J0@Z PROC ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,1,0,-1,1> >::packet<0>, COMDAT

; 184  :                                    : rowId + colId * m_storage.rows()));

	mov	rax, QWORD PTR [rcx]
	mov	r10, QWORD PTR [rcx+8]
	imul	r10, r9
	add	r10, r8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 238  :   template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm_loadu_pd(from); }

	movups	xmm0, XMMWORD PTR [rax+r10*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 184  :                                    : rowId + colId * m_storage.rows()));

	mov	rax, rdx
	movaps	XMMWORD PTR [rdx], xmm0

; 185  :     }

	ret	0
??$packet@$0A@@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEBA?AU__m128d@@_J0@Z ENDP ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,1,0,-1,1> >::packet<0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
;	COMDAT ??$writePacket@$00@?$MapBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBU__m128d@@@Z
_TEXT	SEGMENT
this$ = 8
row$ = 16
col$ = 24
val$ = 32
??$writePacket@$00@?$MapBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBU__m128d@@@Z PROC ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,1>::writePacket<1>, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	mov	r10, QWORD PTR [rcx+32]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 217  :                (this->m_data + (col * colStride() + row * rowStride()), val);

	mov	rax, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	xmm0, XMMWORD PTR [r9]
	imul	r10, r8
	add	r10, rdx
	movaps	XMMWORD PTR [rax+r10*8], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 218  :     }

	ret	0
??$writePacket@$00@?$MapBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBU__m128d@@@Z ENDP ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,1>::writePacket<1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
;	COMDAT ??$packet@$0A@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA?AU__m128d@@_J0@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
rowId$ = 24
colId$ = 32
??$packet@$0A@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA?AU__m128d@@_J0@Z PROC ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::packet<0>, COMDAT

; 184  :                                    : rowId + colId * m_storage.rows()));

	mov	rax, QWORD PTR [rcx]
	mov	r10, QWORD PTR [rcx+8]
	imul	r10, r9
	add	r10, r8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 238  :   template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm_loadu_pd(from); }

	movups	xmm0, XMMWORD PTR [rax+r10*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 184  :                                    : rowId + colId * m_storage.rows()));

	mov	rax, rdx
	movaps	XMMWORD PTR [rdx], xmm0

; 185  :     }

	ret	0
??$packet@$0A@@?$PlainObjectBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@@Eigen@@QEBA?AU__m128d@@_J0@Z ENDP ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,-1,0,-1,-1> >::packet<0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
;	COMDAT ??$writePacket@$00@?$MapBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBU__m128d@@@Z
_TEXT	SEGMENT
this$ = 8
row$ = 16
col$ = 24
val$ = 32
??$writePacket@$00@?$MapBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBU__m128d@@@Z PROC ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,1>::writePacket<1>, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	mov	r10, QWORD PTR [rcx+32]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 217  :                (this->m_data + (col * colStride() + row * rowStride()), val);

	mov	rax, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	xmm0, XMMWORD PTR [r9]
	imul	r10, r8
	add	r10, rdx
	movaps	XMMWORD PTR [rax+r10*8], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 218  :     }

	ret	0
??$writePacket@$00@?$MapBase@V?$Block@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$0?0$0?0$0A@@Eigen@@$00@Eigen@@QEAAX_J0AEBU__m128d@@@Z ENDP ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,-1,0,-1,-1>,-1,-1,0>,1>::writePacket<1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h
;	COMDAT ??$copyCoeff@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 8
row$ = 16
col$ = 24
other$ = 32
??$copyCoeff@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@1@@Z PROC ; Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::copyCoeff<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >, COMDAT

; 89   :     {
; 90   :       OtherDerived& _other = other.const_cast_derived();
; 91   :       eigen_internal_assert(row >= 0 && row < rows()
; 92   :                          && col >= 0 && col < cols());
; 93   :       Scalar& tmp = m_matrix.coeffRef(row,col);

	mov	rax, QWORD PTR [rcx]

; 94   :       tmp = m_functor(tmp, _other.coeff(row,col));

	mov	rcx, QWORD PTR [r9+32]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];

	mov	r11, QWORD PTR [rax+8]
	mov	r10, QWORD PTR [rax]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h

; 26   :   EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& b) const { return a + b; }

	mov	rax, QWORD PTR [r9]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h

; 94   :       tmp = m_functor(tmp, _other.coeff(row,col));

	imul	rcx, r8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 156  :         return m_storage.data()[rowId + colId * m_storage.rows()];

	imul	r11, r8
	add	r11, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h

; 94   :       tmp = m_functor(tmp, _other.coeff(row,col));

	add	rcx, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h

; 26   :   EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& b) const { return a + b; }

	movsdx	xmm0, QWORD PTR [rax+rcx*8]
	addsd	xmm0, QWORD PTR [r10+r11*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h

; 94   :       tmp = m_functor(tmp, _other.coeff(row,col));

	movsdx	QWORD PTR [r10+r11*8], xmm0

; 95   :     }

	ret	0
??$copyCoeff@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@1@@Z ENDP ; Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::copyCoeff<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h
;	COMDAT ??$copyPacket@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$00$0A@@?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 8
row$ = 16
col$ = 24
other$ = 32
??$copyPacket@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$00$0A@@?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@1@@Z PROC ; Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::copyPacket<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,1,0>, COMDAT

; 108  :     {
; 109  :       OtherDerived& _other = other.const_cast_derived();
; 110  :       eigen_internal_assert(row >= 0 && row < rows()
; 111  :                         && col >= 0 && col < cols());
; 112  :       m_matrix.template writePacket<StoreMode>(row, col,
; 113  :         m_functor.packetOp(m_matrix.template packet<StoreMode>(row, col),_other.template packet<LoadMode>(row, col)) );

	mov	r10, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 201  :                                    : rowId + colId * m_storage.rows()), val);

	mov	rax, QWORD PTR [r10]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	mov	rcx, QWORD PTR [r10+8]
	imul	rcx, r8
	add	rcx, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 201  :                                    : rowId + colId * m_storage.rows()), val);

	lea	r11, QWORD PTR [rax+rcx*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	mov	rcx, QWORD PTR [r10+8]
	imul	rcx, r8
	add	rcx, rdx

; 124  : template<> EIGEN_STRONG_INLINE Packet4i padd<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_add_epi32(a,b); }
; 125  : 
; 126  : template<> EIGEN_STRONG_INLINE Packet4f psub<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_sub_ps(a,b); }
; 127  : template<> EIGEN_STRONG_INLINE Packet2d psub<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_sub_pd(a,b); }
; 128  : template<> EIGEN_STRONG_INLINE Packet4i psub<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_sub_epi32(a,b); }
; 129  : 
; 130  : template<> EIGEN_STRONG_INLINE Packet4f pnegate(const Packet4f& a)
; 131  : {
; 132  :   const Packet4f mask = _mm_castsi128_ps(_mm_setr_epi32(0x80000000,0x80000000,0x80000000,0x80000000));
; 133  :   return _mm_xor_ps(a,mask);
; 134  : }
; 135  : template<> EIGEN_STRONG_INLINE Packet2d pnegate(const Packet2d& a)
; 136  : {
; 137  :   const Packet2d mask = _mm_castsi128_pd(_mm_setr_epi32(0x0,0x80000000,0x0,0x80000000));
; 138  :   return _mm_xor_pd(a,mask);
; 139  : }
; 140  : template<> EIGEN_STRONG_INLINE Packet4i pnegate(const Packet4i& a)
; 141  : {
; 142  :   return psub(_mm_setr_epi32(0,0,0,0), a);
; 143  : }
; 144  : 
; 145  : template<> EIGEN_STRONG_INLINE Packet4f pconj(const Packet4f& a) { return a; }
; 146  : template<> EIGEN_STRONG_INLINE Packet2d pconj(const Packet2d& a) { return a; }
; 147  : template<> EIGEN_STRONG_INLINE Packet4i pconj(const Packet4i& a) { return a; }
; 148  : 
; 149  : template<> EIGEN_STRONG_INLINE Packet4f pmul<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_mul_ps(a,b); }
; 150  : template<> EIGEN_STRONG_INLINE Packet2d pmul<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_mul_pd(a,b); }
; 151  : template<> EIGEN_STRONG_INLINE Packet4i pmul<Packet4i>(const Packet4i& a, const Packet4i& b)
; 152  : {
; 153  : #ifdef EIGEN_VECTORIZE_SSE4_1
; 154  :   return _mm_mullo_epi32(a,b);
; 155  : #else
; 156  :   // this version is slightly faster than 4 scalar products
; 157  :   return vec4i_swizzle1(
; 158  :             vec4i_swizzle2(
; 159  :               _mm_mul_epu32(a,b),
; 160  :               _mm_mul_epu32(vec4i_swizzle1(a,1,0,3,2),
; 161  :                             vec4i_swizzle1(b,1,0,3,2)),
; 162  :               0,2,0,2),
; 163  :             0,2,1,3);
; 164  : #endif
; 165  : }
; 166  : 
; 167  : template<> EIGEN_STRONG_INLINE Packet4f pdiv<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_div_ps(a,b); }
; 168  : template<> EIGEN_STRONG_INLINE Packet2d pdiv<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_div_pd(a,b); }
; 169  : template<> EIGEN_STRONG_INLINE Packet4i pdiv<Packet4i>(const Packet4i& /*a*/, const Packet4i& /*b*/)
; 170  : { eigen_assert(false && "packet integer division are not supported by SSE");
; 171  :   return pset1<Packet4i>(0);
; 172  : }
; 173  : 
; 174  : // for some weird raisons, it has to be overloaded for packet of integers
; 175  : template<> EIGEN_STRONG_INLINE Packet4i pmadd(const Packet4i& a, const Packet4i& b, const Packet4i& c) { return padd(pmul(a,b), c); }
; 176  : 
; 177  : template<> EIGEN_STRONG_INLINE Packet4f pmin<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_min_ps(a,b); }
; 178  : template<> EIGEN_STRONG_INLINE Packet2d pmin<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_min_pd(a,b); }
; 179  : template<> EIGEN_STRONG_INLINE Packet4i pmin<Packet4i>(const Packet4i& a, const Packet4i& b)
; 180  : {
; 181  : #ifdef EIGEN_VECTORIZE_SSE4_1
; 182  :   return _mm_min_epi32(a,b);
; 183  : #else
; 184  :   // after some bench, this version *is* faster than a scalar implementation
; 185  :   Packet4i mask = _mm_cmplt_epi32(a,b);
; 186  :   return _mm_or_si128(_mm_and_si128(mask,a),_mm_andnot_si128(mask,b));
; 187  : #endif
; 188  : }
; 189  : 
; 190  : template<> EIGEN_STRONG_INLINE Packet4f pmax<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_max_ps(a,b); }
; 191  : template<> EIGEN_STRONG_INLINE Packet2d pmax<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_max_pd(a,b); }
; 192  : template<> EIGEN_STRONG_INLINE Packet4i pmax<Packet4i>(const Packet4i& a, const Packet4i& b)
; 193  : {
; 194  : #ifdef EIGEN_VECTORIZE_SSE4_1
; 195  :   return _mm_max_epi32(a,b);
; 196  : #else
; 197  :   // after some bench, this version *is* faster than a scalar implementation
; 198  :   Packet4i mask = _mm_cmpgt_epi32(a,b);
; 199  :   return _mm_or_si128(_mm_and_si128(mask,a),_mm_andnot_si128(mask,b));
; 200  : #endif
; 201  : }
; 202  : 
; 203  : template<> EIGEN_STRONG_INLINE Packet4f pand<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_and_ps(a,b); }
; 204  : template<> EIGEN_STRONG_INLINE Packet2d pand<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_and_pd(a,b); }
; 205  : template<> EIGEN_STRONG_INLINE Packet4i pand<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_and_si128(a,b); }
; 206  : 
; 207  : template<> EIGEN_STRONG_INLINE Packet4f por<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_or_ps(a,b); }
; 208  : template<> EIGEN_STRONG_INLINE Packet2d por<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_or_pd(a,b); }
; 209  : template<> EIGEN_STRONG_INLINE Packet4i por<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_or_si128(a,b); }
; 210  : 
; 211  : template<> EIGEN_STRONG_INLINE Packet4f pxor<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_xor_ps(a,b); }
; 212  : template<> EIGEN_STRONG_INLINE Packet2d pxor<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_xor_pd(a,b); }
; 213  : template<> EIGEN_STRONG_INLINE Packet4i pxor<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_xor_si128(a,b); }
; 214  : 
; 215  : template<> EIGEN_STRONG_INLINE Packet4f pandnot<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_andnot_ps(a,b); }
; 216  : template<> EIGEN_STRONG_INLINE Packet2d pandnot<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_andnot_pd(a,b); }
; 217  : template<> EIGEN_STRONG_INLINE Packet4i pandnot<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_andnot_si128(a,b); }
; 218  : 
; 219  : template<> EIGEN_STRONG_INLINE Packet4f pload<Packet4f>(const float*   from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_ps(from); }
; 220  : template<> EIGEN_STRONG_INLINE Packet2d pload<Packet2d>(const double*  from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_pd(from); }

	movaps	xmm1, XMMWORD PTR [rax+rcx*8]

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	mov	rcx, QWORD PTR [r9+32]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 116  :                (m_data + (colId * colStride() + rowId * rowStride()));

	mov	rax, QWORD PTR [r9]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	imul	rcx, r8
	add	rcx, rdx

; 221  : template<> EIGEN_STRONG_INLINE Packet4i pload<Packet4i>(const int*     from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_si128(reinterpret_cast<const Packet4i*>(from)); }
; 222  : 
; 223  : #if defined(_MSC_VER)
; 224  :   template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float*  from) {
; 225  :     EIGEN_DEBUG_UNALIGNED_LOAD
; 226  :     #if (_MSC_VER==1600)
; 227  :     // NOTE Some version of MSVC10 generates bad code when using _mm_loadu_ps
; 228  :     // (i.e., it does not generate an unaligned load!!
; 229  :     // TODO On most architectures this version should also be faster than a single _mm_loadu_ps
; 230  :     // so we could also enable it for MSVC08 but first we have to make this later does not generate crap when doing so...
; 231  :     __m128 res = _mm_loadl_pi(_mm_set1_ps(0.0f), (const __m64*)(from));
; 232  :     res = _mm_loadh_pi(res, (const __m64*)(from+2));
; 233  :     return res;
; 234  :     #else
; 235  :     return _mm_loadu_ps(from);
; 236  :     #endif
; 237  :   }
; 238  :   template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm_loadu_pd(from); }

	movups	xmm0, XMMWORD PTR [rax+rcx*8]

; 123  : template<> EIGEN_STRONG_INLINE Packet2d padd<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_add_pd(a,b); }

	addpd	xmm1, xmm0

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [r11], xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\selfcwisebinaryop.h

; 114  :     }

	ret	0
??$copyPacket@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$00$0A@@?$SelfCwiseBinaryOp@U?$scalar_sum_op@N@internal@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@3@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@3@@Eigen@@QEAAX_J0AEBV?$DenseBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@1@@Z ENDP ; Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>,Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::copyPacket<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,1,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
;	COMDAT ??$run@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@@?$unaligned_assign_impl@$00@internal@Eigen@@SAXAEBV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@_J2@Z
_TEXT	SEGMENT
__formal$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
__formal$dead$ = 32
??$run@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@@?$unaligned_assign_impl@$00@internal@Eigen@@SAXAEBV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@_J2@Z PROC ; Eigen::internal::unaligned_assign_impl<1>::run<Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Matrix<double,-1,-1,0,-1,-1> >, COMDAT

; 368  :   static EIGEN_STRONG_INLINE void run(const Derived&, OtherDerived&, typename Derived::Index, typename Derived::Index) {}

	ret	0
??$run@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@@?$unaligned_assign_impl@$00@internal@Eigen@@SAXAEBV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@_J2@Z ENDP ; Eigen::internal::unaligned_assign_impl<1>::run<Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Matrix<double,-1,-1,0,-1,-1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
;	COMDAT ??$copyPacket@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$00$00@?$DenseCoeffsBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$00@Eigen@@QEAAX_JAEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 8
index$ = 16
other$ = 24
??$copyPacket@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$00$00@?$DenseCoeffsBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$00@Eigen@@QEAAX_JAEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z PROC ; Eigen::DenseCoeffsBase<Eigen::Matrix<double,-1,-1,0,-1,-1>,1>::copyPacket<Eigen::Matrix<double,-1,1,0,-1,1>,1,1>, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 208  :       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);

	mov	rax, QWORD PTR [rcx]
	lea	rcx, QWORD PTR [rax+rdx*8]

; 191  :       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);

	mov	rax, QWORD PTR [r8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 220  : template<> EIGEN_STRONG_INLINE Packet2d pload<Packet2d>(const double*  from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_pd(from); }

	movaps	xmm0, XMMWORD PTR [rax+rdx*8]

; 221  : template<> EIGEN_STRONG_INLINE Packet4i pload<Packet4i>(const int*     from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_si128(reinterpret_cast<const Packet4i*>(from)); }
; 222  : 
; 223  : #if defined(_MSC_VER)
; 224  :   template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float*  from) {
; 225  :     EIGEN_DEBUG_UNALIGNED_LOAD
; 226  :     #if (_MSC_VER==1600)
; 227  :     // NOTE Some version of MSVC10 generates bad code when using _mm_loadu_ps
; 228  :     // (i.e., it does not generate an unaligned load!!
; 229  :     // TODO On most architectures this version should also be faster than a single _mm_loadu_ps
; 230  :     // so we could also enable it for MSVC08 but first we have to make this later does not generate crap when doing so...
; 231  :     __m128 res = _mm_loadl_pi(_mm_set1_ps(0.0f), (const __m64*)(from));
; 232  :     res = _mm_loadh_pi(res, (const __m64*)(from+2));
; 233  :     return res;
; 234  :     #else
; 235  :     return _mm_loadu_ps(from);
; 236  :     #endif
; 237  :   }
; 238  :   template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm_loadu_pd(from); }
; 239  :   template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int*    from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm_loadu_si128(reinterpret_cast<const Packet4i*>(from)); }
; 240  : #else
; 241  : // Fast unaligned loads. Note that here we cannot directly use intrinsics: this would
; 242  : // require pointer casting to incompatible pointer types and leads to invalid code
; 243  : // because of the strict aliasing rule. The "dummy" stuff are required to enforce
; 244  : // a correct instruction dependency.
; 245  : // TODO: do the same for MSVC (ICC is compatible)
; 246  : // NOTE: with the code below, MSVC's compiler crashes!
; 247  : 
; 248  : #if defined(__GNUC__) && defined(__i386__)
; 249  :   // bug 195: gcc/i386 emits weird x87 fldl/fstpl instructions for _mm_load_sd
; 250  :   #define EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS 1
; 251  : #elif defined(__clang__)
; 252  :   // bug 201: Segfaults in __mm_loadh_pd with clang 2.8
; 253  :   #define EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS 1
; 254  : #else
; 255  :   #define EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS 0
; 256  : #endif
; 257  : 
; 258  : template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float* from)
; 259  : {
; 260  :   EIGEN_DEBUG_UNALIGNED_LOAD
; 261  : #if EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS
; 262  :   return _mm_loadu_ps(from);
; 263  : #else
; 264  :   __m128d res;
; 265  :   res =  _mm_load_sd((const double*)(from)) ;
; 266  :   res =  _mm_loadh_pd(res, (const double*)(from+2)) ;
; 267  :   return _mm_castpd_ps(res);
; 268  : #endif
; 269  : }
; 270  : template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from)
; 271  : {
; 272  :   EIGEN_DEBUG_UNALIGNED_LOAD
; 273  : #if EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS
; 274  :   return _mm_loadu_pd(from);
; 275  : #else
; 276  :   __m128d res;
; 277  :   res = _mm_load_sd(from) ;
; 278  :   res = _mm_loadh_pd(res,from+1);
; 279  :   return res;
; 280  : #endif
; 281  : }
; 282  : template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int* from)
; 283  : {
; 284  :   EIGEN_DEBUG_UNALIGNED_LOAD
; 285  : #if EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS
; 286  :   return _mm_loadu_si128(reinterpret_cast<const Packet4i*>(from));
; 287  : #else
; 288  :   __m128d res;
; 289  :   res =  _mm_load_sd((const double*)(from)) ;
; 290  :   res =  _mm_loadh_pd(res, (const double*)(from+2)) ;
; 291  :   return _mm_castpd_si128(res);
; 292  : #endif
; 293  : }
; 294  : #endif
; 295  : 
; 296  : template<> EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float*   from)
; 297  : {
; 298  :   return vec4f_swizzle1(_mm_castpd_ps(_mm_load_sd(reinterpret_cast<const double*>(from))), 0, 0, 1, 1);
; 299  : }
; 300  : template<> EIGEN_STRONG_INLINE Packet2d ploaddup<Packet2d>(const double*  from)
; 301  : { return pset1<Packet2d>(from[0]); }
; 302  : template<> EIGEN_STRONG_INLINE Packet4i ploaddup<Packet4i>(const int*     from)
; 303  : {
; 304  :   Packet4i tmp;
; 305  :   tmp = _mm_loadl_epi64(reinterpret_cast<const Packet4i*>(from));
; 306  :   return vec4i_swizzle1(tmp, 0, 0, 1, 1);
; 307  : }
; 308  : 
; 309  : template<> EIGEN_STRONG_INLINE void pstore<float>(float*   to, const Packet4f& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_ps(to, from); }
; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [rcx], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 539  :     }

	ret	0
??$copyPacket@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$00$00@?$DenseCoeffsBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$00@Eigen@@QEAAX_JAEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z ENDP ; Eigen::DenseCoeffsBase<Eigen::Matrix<double,-1,-1,0,-1,-1>,1>::copyPacket<Eigen::Matrix<double,-1,1,0,-1,1>,1,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
;	COMDAT ??$run@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@@?$unaligned_assign_impl@$0A@@internal@Eigen@@SAXAEBV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@_J2@Z
_TEXT	SEGMENT
src$ = 8
dst$ = 16
start$ = 24
end$ = 32
??$run@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@@?$unaligned_assign_impl@$0A@@internal@Eigen@@SAXAEBV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@_J2@Z PROC ; Eigen::internal::unaligned_assign_impl<0>::run<Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Matrix<double,-1,-1,0,-1,-1> >, COMDAT

; 378  :   static EIGEN_DONT_INLINE void run(const Derived& src, OtherDerived& dst, typename Derived::Index start, typename Derived::Index end)

$LN31:
	mov	QWORD PTR [rsp+8], rbx
	mov	rbx, rdx
	mov	r10, r9
	mov	r11, r8
	mov	rdx, rcx
	cmp	r8, r9
	jge	$LN25@run

; 384  :     for (typename Derived::Index index = start; index < end; ++index)

	mov	rax, r9
	sub	rax, r8
	cmp	rax, 4
	jl	SHORT $LC26@run
	mov	rax, QWORD PTR [rbx]
	lea	r9, QWORD PTR [r8+1]
	mov	r8, QWORD PTR [rcx]
	mov	rcx, r10
	sub	r8, rax
	lea	r9, QWORD PTR [rax+r9*8]
	sub	rcx, r11
	sub	rcx, 4
	shr	rcx, 2
	inc	rcx
	lea	r11, QWORD PTR [r11+rcx*4]
	npad	4
$LL27@run:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 495  :       derived().coeffRef(index) = other.derived().coeff(index);

	mov	rax, QWORD PTR [r8+r9-8]
	lea	r9, QWORD PTR [r9+32]
	mov	QWORD PTR [r9-40], rax
	mov	rax, QWORD PTR [r8+r9-32]
	mov	QWORD PTR [r9-32], rax
	mov	rax, QWORD PTR [r8+r9-24]
	mov	QWORD PTR [r9-24], rax
	mov	rax, QWORD PTR [r8+r9-16]
	mov	QWORD PTR [r9-16], rax
	dec	rcx
	jne	SHORT $LL27@run
$LC26@run:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 384  :     for (typename Derived::Index index = start; index < end; ++index)

	cmp	r11, r10
	jge	SHORT $LN25@run
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 262  :     inline T *data() { return m_data; }

	mov	rax, QWORD PTR [rbx]

; 333  :     inline const T *data() const { return m_data; }

	mov	rdx, QWORD PTR [rdx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 384  :     for (typename Derived::Index index = start; index < end; ++index)

	sub	rdx, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 333  :     inline const T *data() const { return m_data; }

	lea	rcx, QWORD PTR [rax+r11*8]
	sub	r10, r11
$LC22@run:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h

; 495  :       derived().coeffRef(index) = other.derived().coeff(index);

	mov	rax, QWORD PTR [rcx+rdx]
	lea	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx-8], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 384  :     for (typename Derived::Index index = start; index < end; ++index)

	dec	r10
	jne	SHORT $LC22@run
$LN25@run:

; 385  :       dst.copyCoeff(index, src);
; 386  :   }

	mov	rbx, QWORD PTR [rsp+8]
	ret	0
??$run@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@@?$unaligned_assign_impl@$0A@@internal@Eigen@@SAXAEBV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEAV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@_J2@Z ENDP ; Eigen::internal::unaligned_assign_impl<0>::run<Eigen::Matrix<double,-1,1,0,-1,1>,Eigen::Matrix<double,-1,-1,0,-1,-1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
;	COMDAT ?coeff@?$MapBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEBAAEBN_J0@Z
_TEXT	SEGMENT
this$ = 8
rowId$ = 16
colId$ = 24
?coeff@?$MapBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEBAAEBN_J0@Z PROC ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,0>::coeff, COMDAT

; 92   :       return m_data[colId * colStride() + rowId * rowStride()];

	mov	r9, QWORD PTR [rcx+32]
	mov	rax, QWORD PTR [rcx]
	imul	r9, r8
	add	r9, rdx
	lea	rax, QWORD PTR [rax+r9*8]

; 93   :     }

	ret	0
?coeff@?$MapBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEBAAEBN_J0@Z ENDP ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,0>::coeff
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
;	COMDAT ?const_cast_derived@?$EigenBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBAAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@XZ
_TEXT	SEGMENT
this$ = 8
?const_cast_derived@?$EigenBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBAAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@XZ PROC ; Eigen::EigenBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::const_cast_derived, COMDAT

; 39   :   { return *static_cast<Derived*>(const_cast<EigenBase*>(this)); }

	mov	rax, rcx
	ret	0
?const_cast_derived@?$EigenBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@@Eigen@@QEBAAEAV?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@2@XZ ENDP ; Eigen::EigenBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0> >::const_cast_derived
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\transpose.h
;	COMDAT ?run@?$checkTransposeAliasing_impl@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$0A@@internal@Eigen@@SAXAEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
__formal$dead$ = 16
?run@?$checkTransposeAliasing_impl@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$0A@@internal@Eigen@@SAXAEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z PROC ; Eigen::internal::checkTransposeAliasing_impl<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::Matrix<double,-1,1,0,-1,1>,0>::run, COMDAT

; 404  :     }

	ret	0
?run@?$checkTransposeAliasing_impl@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@$0A@@internal@Eigen@@SAXAEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@3@AEBV?$Matrix@N$0?0$00$0A@$0?0$00@3@@Z ENDP ; Eigen::internal::checkTransposeAliasing_impl<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::Matrix<double,-1,1,0,-1,1>,0>::run
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\generalproduct.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\generalproduct.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\generalproduct.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h
;	COMDAT ??$scaleAndAddTo@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEBAXAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBN@Z
_TEXT	SEGMENT
this$ = 48
dst$ = 56
alpha$ = 64
??$scaleAndAddTo@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEBAXAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBN@Z PROC ; Eigen::ProductBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >::scaleAndAddTo<Eigen::Matrix<double,-1,1,0,-1,1> >, COMDAT

; 118  :     inline void scaleAndAddTo(Dest& dst, const Scalar& alpha) const { derived().scaleAndAddTo(dst,alpha); }

$LN32:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\generalproduct.h

; 347  :       eigen_assert(m_lhs.rows() == dst.rows() && m_rhs.cols() == dst.cols());

	mov	r9, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rdx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h

; 118  :     inline void scaleAndAddTo(Dest& dst, const Scalar& alpha) const { derived().scaleAndAddTo(dst,alpha); }

	mov	rsi, r8
	mov	rbx, rdx
	mov	rdi, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\generalproduct.h

; 347  :       eigen_assert(m_lhs.rows() == dst.rows() && m_rhs.cols() == dst.cols());

	cmp	QWORD PTR [r9+8], rax
	je	SHORT $LN8@scaleAndAd
	lea	rdx, OFFSET FLAT:??_C@_1LO@HNIIIKFI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1HC@EELIINB@?$AAm?$AA_?$AAl?$AAh?$AAs?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAd?$AAs?$AAt?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAm?$AA_@
	mov	r8d, 347				; 0000015bH
	call	QWORD PTR __imp__wassert
$LN8@scaleAndAd:

; 349  :                        bool(internal::blas_traits<MatrixType>::HasUsableDirectAccess)>::run(*this, dst, alpha);

	mov	r8, rsi
	mov	rdx, rbx
	mov	rcx, rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h

; 118  :     inline void scaleAndAddTo(Dest& dst, const Scalar& alpha) const { derived().scaleAndAddTo(dst,alpha); }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\generalproduct.h

; 349  :                        bool(internal::blas_traits<MatrixType>::HasUsableDirectAccess)>::run(*this, dst, alpha);

	jmp	??$run@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@?$gemv_selector@$01$0A@$00@internal@Eigen@@SAXAEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEBN@Z ; Eigen::internal::gemv_selector<2,0,1>::run<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,1,0,-1,1> >
??$scaleAndAddTo@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEBAXAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBN@Z ENDP ; Eigen::ProductBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >::scaleAndAddTo<Eigen::Matrix<double,-1,1,0,-1,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
;	COMDAT ??$packet@$00@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEBA?AU__m128d@@_J0@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
rowId$ = 24
colId$ = 32
??$packet@$00@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEBA?AU__m128d@@_J0@Z PROC ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,1,0,-1,1> >::packet<1>, COMDAT

; 184  :                                    : rowId + colId * m_storage.rows()));

	mov	rax, QWORD PTR [rcx]
	mov	r10, QWORD PTR [rcx+8]
	imul	r10, r9
	add	r10, r8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 220  : template<> EIGEN_STRONG_INLINE Packet2d pload<Packet2d>(const double*  from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_pd(from); }

	movaps	xmm0, XMMWORD PTR [rax+r10*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 184  :                                    : rowId + colId * m_storage.rows()));

	mov	rax, rdx
	movaps	XMMWORD PTR [rdx], xmm0

; 185  :     }

	ret	0
??$packet@$00@?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEBA?AU__m128d@@_J0@Z ENDP ; Eigen::PlainObjectBase<Eigen::Matrix<double,-1,1,0,-1,1> >::packet<1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h
;	COMDAT ??$packet@$0A@@?$MapBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEBA?AU__m128d@@_J0@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
rowId$ = 24
colId$ = 32
??$packet@$0A@@?$MapBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEBA?AU__m128d@@_J0@Z PROC ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,0>::packet<0>, COMDAT

; 116  :                (m_data + (colId * colStride() + rowId * rowStride()));

	mov	rax, QWORD PTR [rcx]
	mov	r10, QWORD PTR [rcx+32]
	imul	r10, r9
	add	r10, r8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 238  :   template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm_loadu_pd(from); }

	movups	xmm0, XMMWORD PTR [rax+r10*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\mapbase.h

; 116  :                (m_data + (colId * colStride() + rowId * rowStride()));

	mov	rax, rdx
	movaps	XMMWORD PTR [rdx], xmm0

; 117  :     }

	ret	0
??$packet@$0A@@?$MapBase@V?$Block@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@$0?0$0?0$0A@@Eigen@@$0A@@Eigen@@QEBA?AU__m128d@@_J0@Z ENDP ; Eigen::MapBase<Eigen::Block<Eigen::Matrix<double,-1,1,0,-1,1>,-1,-1,0>,0>::packet<0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densecoeffsbase.h
;	COMDAT ??$copyCoeff@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$DenseCoeffsBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$00@Eigen@@QEAAX_JAEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z
_TEXT	SEGMENT
this$ = 8
index$ = 16
other$ = 24
??$copyCoeff@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$DenseCoeffsBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$00@Eigen@@QEAAX_JAEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z PROC ; Eigen::DenseCoeffsBase<Eigen::Matrix<double,-1,-1,0,-1,-1>,1>::copyCoeff<Eigen::Matrix<double,-1,1,0,-1,1> >, COMDAT

; 493  :     {
; 494  :       eigen_internal_assert(index >= 0 && index < size());
; 495  :       derived().coeffRef(index) = other.derived().coeff(index);

	mov	rax, QWORD PTR [r8]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+rdx*8]
	mov	QWORD PTR [rcx+rdx*8], rax

; 496  :     }

	ret	0
??$copyCoeff@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$DenseCoeffsBase@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@$00@Eigen@@QEAAX_JAEBV?$DenseBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@1@@Z ENDP ; Eigen::DenseCoeffsBase<Eigen::Matrix<double,-1,-1,0,-1,-1>,1>::copyCoeff<Eigen::Matrix<double,-1,1,0,-1,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\generalproduct.h
;	COMDAT ??$scaleAndAddTo@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@QEBAXAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBN@Z
_TEXT	SEGMENT
this$ = 48
dst$ = 56
alpha$ = 64
??$scaleAndAddTo@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@QEBAXAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBN@Z PROC ; Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>::scaleAndAddTo<Eigen::Matrix<double,-1,1,0,-1,1> >, COMDAT

; 345  :     template<typename Dest> void scaleAndAddTo(Dest& dst, const Scalar& alpha) const

$LN28:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 346  :     {
; 347  :       eigen_assert(m_lhs.rows() == dst.rows() && m_rhs.cols() == dst.cols());

	mov	r9, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rdx+8]
	mov	rsi, r8
	mov	rbx, rdx
	mov	rdi, rcx
	cmp	QWORD PTR [r9+8], rax
	je	SHORT $LN4@scaleAndAd
	lea	rdx, OFFSET FLAT:??_C@_1LO@HNIIIKFI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1HC@EELIINB@?$AAm?$AA_?$AAl?$AAh?$AAs?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAd?$AAs?$AAt?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAm?$AA_@
	mov	r8d, 347				; 0000015bH
	call	QWORD PTR __imp__wassert
$LN4@scaleAndAd:

; 348  :       internal::gemv_selector<Side,(int(MatrixType::Flags)&RowMajorBit) ? RowMajor : ColMajor,
; 349  :                        bool(internal::blas_traits<MatrixType>::HasUsableDirectAccess)>::run(*this, dst, alpha);

	mov	r8, rsi
	mov	rdx, rbx
	mov	rcx, rdi

; 350  :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi

; 348  :       internal::gemv_selector<Side,(int(MatrixType::Flags)&RowMajorBit) ? RowMajor : ColMajor,
; 349  :                        bool(internal::blas_traits<MatrixType>::HasUsableDirectAccess)>::run(*this, dst, alpha);

	jmp	??$run@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@?$gemv_selector@$01$0A@$00@internal@Eigen@@SAXAEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEBN@Z ; Eigen::internal::gemv_selector<2,0,1>::run<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,1,0,-1,1> >
??$scaleAndAddTo@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@QEBAXAEAV?$Matrix@N$0?0$00$0A@$0?0$00@1@AEBN@Z ENDP ; Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>::scaleAndAddTo<Eigen::Matrix<double,-1,1,0,-1,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\generalproduct.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arraywrapper.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\generalproduct.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\generalproduct.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\generalproduct.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\generalproduct.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\generalproduct.h
;	COMDAT ??$run@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@?$gemv_selector@$01$0A@$00@internal@Eigen@@SAXAEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEBN@Z
_TEXT	SEGMENT
actualLhs$1$ = 0
alpha$1$ = 8
dest$GSCopy$1$ = 16
$T1 = 24
$T2 = 32
actualRhs$ = 48
actualDestPtr_stack_memory_destructor$ = 64
__$ArrayPad$ = 88
prod$ = 176
dest$ = 184
alpha$ = 192
??$run@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@?$gemv_selector@$01$0A@$00@internal@Eigen@@SAXAEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEBN@Z PROC ; Eigen::internal::gemv_selector<2,0,1>::run<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,1,0,-1,1> >, COMDAT

; 409  :   static inline void run(const ProductType& prod, Dest& dest, const typename ProductType::Scalar& alpha)

$LN1729:
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 192				; 000000c0H
	lea	rbp, QWORD PTR [rsp+80]
	mov	QWORD PTR $T1[rbp], -2
	mov	QWORD PTR [rbp+192], rbx
	movaps	XMMWORD PTR [rbp+96], xmm6
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	mov	QWORD PTR alpha$1$[rbp], r8
	mov	r12, rdx
	mov	QWORD PTR dest$GSCopy$1$[rbp], rdx

; 410  :   {
; 411  :     typedef typename ProductType::Index Index;
; 412  :     typedef typename ProductType::LhsScalar   LhsScalar;
; 413  :     typedef typename ProductType::RhsScalar   RhsScalar;
; 414  :     typedef typename ProductType::Scalar      ResScalar;
; 415  :     typedef typename ProductType::RealScalar  RealScalar;
; 416  :     typedef typename ProductType::ActualLhsType ActualLhsType;
; 417  :     typedef typename ProductType::ActualRhsType ActualRhsType;
; 418  :     typedef typename ProductType::LhsBlasTraits LhsBlasTraits;
; 419  :     typedef typename ProductType::RhsBlasTraits RhsBlasTraits;
; 420  :     typedef Map<Matrix<ResScalar,Dynamic,1>, Aligned> MappedDest;
; 421  : 
; 422  :     ActualLhsType actualLhs = LhsBlasTraits::extract(prod.lhs());

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR actualLhs$1$[rbp], rax
	xor	edx, edx
	mov	QWORD PTR actualRhs$[rbp], rdx
	mov	QWORD PTR actualRhs$[rbp+8], rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h

; 121  :     const _RhsNested& rhs() const { return m_rhs; }

	lea	r13, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 313  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rax, QWORD PTR [r13+8]
	mov	rbx, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 420  :   if(size==0)

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	xor	r15d, r15d
	test	rbx, rbx
	jne	SHORT $LN100@run

; 421  :     return 0; // short-cut. Also fixes Bug 884

	mov	edi, r15d
	jmp	SHORT $LN101@run
$LN100@run:

; 365  :   if(size > size_t(-1) / sizeof(T))

	cmp	rbx, rax
	jbe	SHORT $LN103@run

; 366  :     throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN103@run:

; 422  :   check_size_for_overflow<T>(size);
; 423  :   T *result = reinterpret_cast<T*>(conditional_aligned_malloc<Align>(sizeof(T)*size));

	lea	rsi, QWORD PTR [rbx*8]

; 220  :     result = std::malloc(size);

	mov	rcx, rsi
	call	QWORD PTR __imp_malloc
	mov	rdi, rax

; 221  :   #elif EIGEN_HAS_POSIX_MEMALIGN
; 222  :     if(posix_memalign(&result, 16, size)) result = 0;
; 223  :   #elif EIGEN_HAS_MM_MALLOC
; 224  :     result = _mm_malloc(size, 16);
; 225  :   #elif defined(_MSC_VER) && (!defined(_WIN32_WCE))
; 226  :     result = _aligned_malloc(size, 16);
; 227  :   #else
; 228  :     result = handmade_aligned_malloc(size);
; 229  :   #endif
; 230  : 
; 231  :   if(!result && size)

	test	rax, rax
	jne	SHORT $LN101@run
	test	rsi, rsi
	je	SHORT $LN101@run

; 232  :     throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN101@run:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 310  :     { EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN }

	mov	QWORD PTR actualRhs$[rbp], rdi
	mov	QWORD PTR actualRhs$[rbp+8], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 44   :                : (rows > max_index / cols);

	mov	rsi, 9223372036854775807		; 7fffffffffffffffH
	test	rbx, rbx
	je	SHORT $LN1727@run
	cmp	rbx, rsi
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN164@run

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN164@run:

; 192  :     }
; 193  : 
; 194  :     /** \internal */
; 195  :     template<int StoreMode>
; 196  :     EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)
; 197  :     {
; 198  :       internal::pstoret<Scalar, PacketScalar, StoreMode>
; 199  :               (m_storage.data() + (Flags & RowMajorBit
; 200  :                                    ? colId + rowId * m_storage.cols()
; 201  :                                    : rowId + colId * m_storage.rows()), val);
; 202  :     }
; 203  : 
; 204  :     /** \internal */
; 205  :     template<int StoreMode>
; 206  :     EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
; 207  :     {
; 208  :       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
; 209  :     }
; 210  : 
; 211  :     /** \returns a const pointer to the data array of this matrix */
; 212  :     EIGEN_STRONG_INLINE const Scalar *data() const
; 213  :     { return m_storage.data(); }
; 214  : 
; 215  :     /** \returns a pointer to the data array of this matrix */
; 216  :     EIGEN_STRONG_INLINE Scalar *data()
; 217  :     { return m_storage.data(); }
; 218  : 
; 219  :     /** Resizes \c *this to a \a rows x \a cols matrix.
; 220  :       *
; 221  :       * This method is intended for dynamic-size matrices, although it is legal to call it on any
; 222  :       * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
; 223  :       * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
; 224  :       *
; 225  :       * If the current number of coefficients of \c *this exactly matches the
; 226  :       * product \a rows * \a cols, then no memory allocation is performed and
; 227  :       * the current values are left unchanged. In all other cases, including
; 228  :       * shrinking, the data is reallocated and all previous values are lost.
; 229  :       *
; 230  :       * Example: \include Matrix_resize_int_int.cpp
; 231  :       * Output: \verbinclude Matrix_resize_int_int.out
; 232  :       *
; 233  :       * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
; 234  :       */
; 235  :     EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)
; 236  :     {
; 237  :       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,nbRows==RowsAtCompileTime)

	test	rbx, rbx
$LN1727@run:
	jns	SHORT $LN267@run
	mov	r8d, 241				; 000000f1H
	lea	rdx, OFFSET FLAT:??_C@_1MA@MCOBPGHC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1DDG@BMAHIJFL@?$AA?$CI?$AA?$CB?$AA?$CI?$AAR?$AAo?$AAw?$AAs?$AAA?$AAt?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AA?$CJ?$AA?5?$AA?$HM@
	call	QWORD PTR __imp__wassert
$LN267@run:

; 44   :                : (rows > max_index / cols);

	test	rbx, rbx
	je	SHORT $LN274@run
	cmp	rbx, rsi
	setg	al

; 45   :     if (error)

	test	al, al
	je	SHORT $LN274@run

; 46   :       throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN274@run:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 322  :       if(size != m_rows*_Cols)

	cmp	rbx, rbx
	je	SHORT $LN279@run
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 243  :     std::free(ptr);

	mov	rcx, rdi
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 325  :         if (size)

	test	rbx, rbx
	je	SHORT $LN280@run

; 326  :           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);

	mov	rcx, rbx
	call	??$conditional_aligned_new_auto@N$00@internal@Eigen@@YAPEAN_K@Z ; Eigen::internal::conditional_aligned_new_auto<double,1>
	mov	rdi, rax
	mov	QWORD PTR actualRhs$[rbp], rax

; 327  :         else

	jmp	SHORT $LN279@run
$LN280@run:

; 328  :           m_data = 0;

	mov	rdi, r15
	mov	QWORD PTR actualRhs$[rbp], r15
$LN279@run:

; 329  :         EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN
; 330  :       }
; 331  :       m_rows = nbRows;

	mov	QWORD PTR actualRhs$[rbp+8], rbx

; 313  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rax, QWORD PTR [r13+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 498  :   eigen_assert(rows() == other.rows() && cols() == other.cols());

	cmp	rbx, QWORD PTR [rax+8]
	je	SHORT $LN356@run
	mov	r8d, 498				; 000001f2H
	lea	rdx, OFFSET FLAT:??_C@_1KO@HDGCFKMN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	lea	rcx, OFFSET FLAT:??_C@_1GC@PBCDNLIH@?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAt?$AAh?$AAe?$AAr?$AA?4?$AAr?$AAo?$AAw?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAo?$AAl?$AAs?$AA?$CI?$AA?$CJ@
	call	QWORD PTR __imp__wassert
$LN356@run:

; 404  :     const Index alignedEnd = alignedStart + ((size-alignedStart)/packetSize)*packetSize;

	mov	rax, rbx
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r14, rax
	add	r14, r14

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	mov	rsi, r15
	test	r14, r14
	jle	SHORT $LN405@run
	lea	r12, QWORD PTR [r13+1]
$LL407@run:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\eigenbase.h

; 36   :   const Derived& derived() const { return *static_cast<const Derived*>(this); }

	mov	rax, r15
	test	r12, r12
	cmovne	rax, r13
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arraywrapper.h

; 111  :       return m_expression.template packet<LoadMode>(index);

	mov	rax, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 333  :     inline const T *data() const { return m_data; }

	mov	rcx, QWORD PTR [rax]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 220  : template<> EIGEN_STRONG_INLINE Packet2d pload<Packet2d>(const double*  from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_pd(from); }

	movaps	xmm0, XMMWORD PTR [rcx+rsi*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\plainobjectbase.h

; 191  :       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);

	movaps	XMMWORD PTR $T2[rbp], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\functors.h

; 427  :   inline Packet packetOp(const Packet& a) const { return internal::pexp(a); }

	lea	rcx, QWORD PTR $T2[rbp]
	call	??$pexp@U__m128d@@@internal@Eigen@@YA?AU__m128d@@AEBU2@@Z ; Eigen::internal::pexp<__m128d>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\arch\sse\packetmath.h

; 310  : template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }

	movaps	XMMWORD PTR [rdi+rsi*8], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\assign.h

; 408  :     for(Index index = alignedStart; index < alignedEnd; index += packetSize)

	add	rsi, 2
	cmp	rsi, r14
	jl	SHORT $LL407@run
	mov	r12, QWORD PTR dest$GSCopy$1$[rbp]
$LN405@run:

; 409  :     {
; 410  :       dst.template copyPacket<Derived2, dstAlignment, srcAlignment>(index, src);
; 411  :     }
; 412  : 
; 413  :     unaligned_assign_impl<>::run(src,dst,alignedEnd,size);

	mov	r9, rbx
	mov	r8, r14
	lea	rdx, QWORD PTR actualRhs$[rbp]
	mov	rcx, r13
	call	??$run@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@?$unaligned_assign_impl@$0A@@internal@Eigen@@SAXAEBV?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@_J2@Z ; Eigen::internal::unaligned_assign_impl<0>::run<Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,Eigen::Matrix<double,-1,1,0,-1,1> >
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\generalproduct.h

; 426  :                                   * RhsBlasTraits::extractScalarFactor(prod.rhs());

	mov	rax, QWORD PTR alpha$1$[rbp]
	movsdx	xmm6, QWORD PTR [rax]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 313  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rbx, QWORD PTR [r12+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 365  :   if(size > size_t(-1) / sizeof(T))

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rbx, rax
	jbe	SHORT $LN1723@run

; 366  :     throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN1723@run:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 334  :     inline T *data() { return m_data; }

	mov	rsi, QWORD PTR [r12]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\generalproduct.h

; 444  :                                                   evalToDest ? dest.data() : static_dest.data());

	test	rsi, rsi
	je	SHORT $LN17@run
	mov	rdx, rsi
	jmp	SHORT $LN18@run
$LN17@run:
	lea	rax, QWORD PTR [rbx*8]
	cmp	rax, 131072				; 00020000H
	ja	SHORT $LN15@run
	lea	rax, QWORD PTR [rbx*8+16]
	lea	rcx, QWORD PTR [rax+15]
	cmp	rcx, rax
	ja	SHORT $LN1725@run
	mov	rcx, 1152921504606846960		; 0ffffffffffffff0H
$LN1725@run:
	and	rcx, -16
	mov	rax, rcx
	call	__chkstk
	sub	rsp, rcx
	lea	rdx, QWORD PTR [rsp+80]
	and	rdx, -16
	add	rdx, 16
	jmp	SHORT $LN18@run
$LN15@run:
	lea	r14, QWORD PTR [rbx*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 220  :     result = std::malloc(size);

	mov	rcx, r14
	call	QWORD PTR __imp_malloc
	mov	rdx, rax

; 221  :   #elif EIGEN_HAS_POSIX_MEMALIGN
; 222  :     if(posix_memalign(&result, 16, size)) result = 0;
; 223  :   #elif EIGEN_HAS_MM_MALLOC
; 224  :     result = _mm_malloc(size, 16);
; 225  :   #elif defined(_MSC_VER) && (!defined(_WIN32_WCE))
; 226  :     result = _aligned_malloc(size, 16);
; 227  :   #else
; 228  :     result = handmade_aligned_malloc(size);
; 229  :   #endif
; 230  : 
; 231  :   if(!result && size)

	test	rax, rax
	jne	SHORT $LN18@run
	test	r14, r14
	je	SHORT $LN18@run

; 232  :     throw_std_bad_alloc();

	call	?throw_std_bad_alloc@internal@Eigen@@YAXXZ ; Eigen::internal::throw_std_bad_alloc
	int	3
$LN18@run:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\generalproduct.h

; 444  :                                                   evalToDest ? dest.data() : static_dest.data());

	test	rsi, rsi
	cmove	r15, rdx
	lea	rax, QWORD PTR [rbx*8]
	cmp	rax, 131072				; 00020000H
	seta	bl
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\densestorage.h

; 239  :     inline DenseIndex rows(void) const {return m_rows;}

	mov	rax, QWORD PTR actualLhs$1$[rbp]
	mov	rcx, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\generalproduct.h

; 467  :         compatibleAlpha);

	movsdx	QWORD PTR [rsp+64], xmm6
	mov	QWORD PTR [rsp+48], rdx
	mov	QWORD PTR [rsp+40], 1
	mov	QWORD PTR [rsp+32], rdi
	mov	r9, rcx
	mov	r8, QWORD PTR [rax]
	mov	rdx, QWORD PTR [rax+16]
	call	?run@?$general_matrix_vector_product@_JN$0A@$0A@N$0A@$0A@@internal@Eigen@@SAX_J0PEBN010PEAN0N@Z ; Eigen::internal::general_matrix_vector_product<__int64,double,0,0,double,0,0>::run
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\memory.h

; 554  :       if(m_deallocate)

	test	bl, bl
	je	SHORT $LN1687@run

; 243  :     std::free(ptr);

	mov	rcx, r15
	call	QWORD PTR __imp_free
	npad	1
$LN1687@run:
	mov	rcx, rdi
	call	QWORD PTR __imp_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\generalproduct.h

; 476  :   }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rbp+192]
	movaps	xmm6, XMMWORD PTR [rbp+96]
	lea	rsp, QWORD PTR [rbp+112]
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN1726@run:
??$run@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@?$gemv_selector@$01$0A@$00@internal@Eigen@@SAXAEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEBN@Z ENDP ; Eigen::internal::gemv_selector<2,0,1>::run<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,1,0,-1,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
actualLhs$1$ = 0
alpha$1$ = 8
dest$GSCopy$1$ = 16
$T1 = 24
$T2 = 32
actualRhs$ = 48
actualDestPtr_stack_memory_destructor$ = 64
__$ArrayPad$ = 88
prod$ = 176
dest$ = 184
alpha$ = 192
?dtor$2@?0???$run@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@?$gemv_selector@$01$0A@$00@internal@Eigen@@SAXAEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEBN@Z@4HA PROC ; `Eigen::internal::gemv_selector<2,0,1>::run<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,1,0,-1,1> >'::`1'::dtor$2
	lea	rcx, QWORD PTR actualRhs$[rdx+80]
	jmp	??1?$PlainObjectBase@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@Eigen@@QEAA@XZ
?dtor$2@?0???$run@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@?$gemv_selector@$01$0A@$00@internal@Eigen@@SAXAEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEBN@Z@4HA ENDP ; `Eigen::internal::gemv_selector<2,0,1>::run<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,1,0,-1,1> >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
actualLhs$1$ = 0
alpha$1$ = 8
dest$GSCopy$1$ = 16
$T1 = 24
$T2 = 32
actualRhs$ = 48
actualDestPtr_stack_memory_destructor$ = 64
__$ArrayPad$ = 88
prod$ = 176
dest$ = 184
alpha$ = 192
?dtor$0@?0???$run@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@?$gemv_selector@$01$0A@$00@internal@Eigen@@SAXAEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEBN@Z@4HA PROC ; `Eigen::internal::gemv_selector<2,0,1>::run<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,1,0,-1,1> >'::`1'::dtor$0
	lea	rcx, QWORD PTR actualRhs$[rdx+80]
	jmp	??1?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@QEAA@XZ
?dtor$0@?0???$run@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@?$gemv_selector@$01$0A@$00@internal@Eigen@@SAXAEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEBN@Z@4HA ENDP ; `Eigen::internal::gemv_selector<2,0,1>::run<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,1,0,-1,1> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
actualLhs$1$ = 0
alpha$1$ = 8
dest$GSCopy$1$ = 16
$T1 = 24
$T2 = 32
actualRhs$ = 48
actualDestPtr_stack_memory_destructor$ = 64
__$ArrayPad$ = 88
prod$ = 176
dest$ = 184
alpha$ = 192
?dtor$1@?0???$run@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@?$gemv_selector@$01$0A@$00@internal@Eigen@@SAXAEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEBN@Z@4HA PROC ; `Eigen::internal::gemv_selector<2,0,1>::run<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,1,0,-1,1> >'::`1'::dtor$1
	lea	rcx, QWORD PTR actualDestPtr_stack_memory_destructor$[rdx+80]
	jmp	??1?$aligned_stack_memory_handler@N@internal@Eigen@@QEAA@XZ ; Eigen::internal::aligned_stack_memory_handler<double>::~aligned_stack_memory_handler<double>
?dtor$1@?0???$run@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$00$0A@$0?0$00@2@@?$gemv_selector@$01$0A@$00@internal@Eigen@@SAXAEBV?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@2@AEAV?$Matrix@N$0?0$00$0A@$0?0$00@2@AEBN@Z@4HA ENDP ; `Eigen::internal::gemv_selector<2,0,1>::run<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,1,0,-1,1> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h
;	COMDAT ?lhs@?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEBAAEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@XZ
_TEXT	SEGMENT
this$ = 8
?lhs@?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEBAAEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@XZ PROC ; Eigen::ProductBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >::lhs, COMDAT

; 120  :     const _LhsNested& lhs() const { return m_lhs; }

	mov	rax, QWORD PTR [rcx]
	ret	0
?lhs@?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEBAAEBV?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@XZ ENDP ; Eigen::ProductBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >::lhs
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\productbase.h
;	COMDAT ?rhs@?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEBAAEBV?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?rhs@?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEBAAEBV?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@XZ PROC ; Eigen::ProductBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >::rhs, COMDAT

; 121  :     const _RhsNested& rhs() const { return m_rhs; }

	lea	rax, QWORD PTR [rcx+8]
	ret	0
?rhs@?$ProductBase@V?$GeneralProduct@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@Eigen@@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@$03@Eigen@@V?$Matrix@N$0?0$0?0$0A@$0?0$0?0@2@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@@Eigen@@QEBAAEBV?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@2@XZ ENDP ; Eigen::ProductBase<Eigen::GeneralProduct<Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const >,4>,Eigen::Matrix<double,-1,-1,0,-1,-1>,Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >::rhs
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\blasutil.h
;	COMDAT ?extract@?$blas_traits@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@Eigen@@@internal@Eigen@@SAAEBV?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@3@AEBV43@@Z
_TEXT	SEGMENT
x$ = 8
?extract@?$blas_traits@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@Eigen@@@internal@Eigen@@SAAEBV?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@3@AEBV43@@Z PROC ; Eigen::internal::blas_traits<Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >::extract, COMDAT

; 169  :   static inline ExtractType extract(const XprType& x) { return x; }

	mov	rax, rcx
	ret	0
?extract@?$blas_traits@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@Eigen@@@internal@Eigen@@SAAEBV?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@3@AEBV43@@Z ENDP ; Eigen::internal::blas_traits<Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >::extract
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\eigen\src\core\util\blasutil.h
;	COMDAT ?extractScalarFactor@?$blas_traits@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@Eigen@@@internal@Eigen@@SA?BNAEBV?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@3@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?extractScalarFactor@?$blas_traits@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@Eigen@@@internal@Eigen@@SA?BNAEBV?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@3@@Z PROC ; Eigen::internal::blas_traits<Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >::extractScalarFactor, COMDAT

; 170  :   static inline const Scalar extractScalarFactor(const XprType&) { return Scalar(1); }

	movsdx	xmm0, QWORD PTR __real@3ff0000000000000
	ret	0
?extractScalarFactor@?$blas_traits@V?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@Eigen@@@internal@Eigen@@SA?BNAEBV?$MatrixWrapper@$$CBV?$CwiseUnaryOp@U?$scalar_exp_op@N@internal@Eigen@@$$CBV?$ArrayWrapper@V?$Matrix@N$0?0$00$0A@$0?0$00@Eigen@@@3@@Eigen@@@3@@Z ENDP ; Eigen::internal::blas_traits<Eigen::MatrixWrapper<Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<double>,Eigen::ArrayWrapper<Eigen::Matrix<double,-1,1,0,-1,1> > const > const > >::extractScalarFactor
_TEXT	ENDS
END
